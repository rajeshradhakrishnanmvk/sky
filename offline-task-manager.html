<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Offline Task Manager</title>
    <meta name="description" content="Offline-first task management system with no external dependencies">
    
    <!-- PWA Meta Tags -->
    <meta name="theme-color" content="#2563eb">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="Task Manager">
    
    <style>
        /* ============================================
           🎨 CSS DESIGN SYSTEM & LAYOUT
           ============================================ */
        
        /* CSS Custom Properties for Theming */
        :root {
            /* Light theme colors */
            --color-primary: #2563eb;
            --color-primary-dark: #1d4ed8;
            --color-success: #10b981;
            --color-warning: #f59e0b;
            --color-danger: #ef4444;
            --color-background: #ffffff;
            --color-surface: #f8fafc;
            --color-surface-elevated: #ffffff;
            --color-text: #1e293b;
            --color-text-muted: #64748b;
            --color-border: #e2e8f0;
            --color-border-focus: #3b82f6;
            
            /* Spacing system */
            --space-xs: 0.25rem;
            --space-sm: 0.5rem;
            --space-md: 1rem;
            --space-lg: 1.5rem;
            --space-xl: 2rem;
            --space-2xl: 3rem;
            
            /* Typography scale */
            --text-xs: 0.75rem;
            --text-sm: 0.875rem;
            --text-base: 1rem;
            --text-lg: 1.125rem;
            --text-xl: 1.25rem;
            --text-2xl: 1.5rem;
            
            /* Border radius */
            --radius-sm: 0.125rem;
            --radius-md: 0.375rem;
            --radius-lg: 0.5rem;
            --radius-xl: 0.75rem;
            
            /* Shadows */
            --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
            --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
            
            /* Transitions */
            --transition-fast: 150ms ease-in-out;
            --transition-normal: 250ms ease-in-out;
            --transition-slow: 350ms ease-in-out;
        }
        
        /* Dark theme */
        [data-theme="dark"] {
            --color-background: #0f172a;
            --color-surface: #1e293b;
            --color-surface-elevated: #334155;
            --color-text: #f1f5f9;
            --color-text-muted: #94a3b8;
            --color-border: #334155;
        }
        
        /* Reset and base styles */
        *, *::before, *::after {
            box-sizing: border-box;
        }
        
        * {
            margin: 0;
            padding: 0;
        }
        
        html {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            line-height: 1.6;
            color: var(--color-text);
            background-color: var(--color-background);
        }
        
        body {
            min-height: 100vh;
            overflow-x: hidden;
        }
        
        /* ============================================
           📱 RESPONSIVE LAYOUT SYSTEM
           ============================================ */
        
        .app-container {
            display: grid;
            grid-template-areas: 
                "header"
                "main"
                "footer";
            grid-template-rows: auto 1fr auto;
            min-height: 100vh;
            background-color: var(--color-background);
        }
        
        @media (min-width: 768px) {
            .app-container {
                grid-template-areas: 
                    "header header"
                    "sidebar main"
                    "footer footer";
                grid-template-columns: 280px 1fr;
                grid-template-rows: auto 1fr auto;
            }
        }
        
        /* Header */
        .app-header {
            grid-area: header;
            background-color: var(--color-surface-elevated);
            border-bottom: 1px solid var(--color-border);
            padding: var(--space-md) var(--space-lg);
            box-shadow: var(--shadow-sm);
        }
        
        .header-content {
            display: flex;
            align-items: center;
            justify-content: space-between;
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .app-title {
            font-size: var(--text-xl);
            font-weight: 600;
            color: var(--color-primary);
            display: flex;
            align-items: center;
            gap: var(--space-sm);
        }
        
        .status-indicator {
            display: flex;
            align-items: center;
            gap: var(--space-sm);
            font-size: var(--text-sm);
            color: var(--color-text-muted);
        }
        
        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: var(--color-success);
        }
        
        .status-dot.offline {
            background-color: var(--color-danger);
        }
        
        /* Sidebar */
        .app-sidebar {
            grid-area: sidebar;
            background-color: var(--color-surface);
            border-right: 1px solid var(--color-border);
            padding: var(--space-lg);
            display: none;
        }
        
        @media (min-width: 768px) {
            .app-sidebar {
                display: block;
            }
        }
        
        /* Main content */
        .app-main {
            grid-area: main;
            padding: var(--space-lg);
            overflow-y: auto;
        }
        
        .main-content {
            max-width: 800px;
            margin: 0 auto;
        }
        
        /* Footer */
        .app-footer {
            grid-area: footer;
            background-color: var(--color-surface);
            border-top: 1px solid var(--color-border);
            padding: var(--space-md) var(--space-lg);
            text-align: center;
            font-size: var(--text-sm);
            color: var(--color-text-muted);
        }
        
        /* ============================================
           🧩 COMPONENT STYLES
           ============================================ */
        
        /* Buttons */
        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: var(--space-xs);
            padding: var(--space-sm) var(--space-md);
            border: 1px solid transparent;
            border-radius: var(--radius-md);
            font-size: var(--text-sm);
            font-weight: 500;
            text-decoration: none;
            cursor: pointer;
            transition: all var(--transition-fast);
            user-select: none;
        }
        
        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
        
        .btn-primary {
            background-color: var(--color-primary);
            color: white;
        }
        
        .btn-primary:hover:not(:disabled) {
            background-color: var(--color-primary-dark);
        }
        
        .btn-secondary {
            background-color: var(--color-surface-elevated);
            color: var(--color-text);
            border-color: var(--color-border);
        }
        
        .btn-secondary:hover:not(:disabled) {
            background-color: var(--color-surface);
        }
        
        .btn-sm {
            padding: var(--space-xs) var(--space-sm);
            font-size: var(--text-xs);
        }
        
        /* Forms */
        .form-group {
            margin-bottom: var(--space-md);
        }
        
        .form-label {
            display: block;
            margin-bottom: var(--space-xs);
            font-size: var(--text-sm);
            font-weight: 500;
            color: var(--color-text);
        }
        
        .form-input {
            width: 100%;
            padding: var(--space-sm) var(--space-md);
            border: 1px solid var(--color-border);
            border-radius: var(--radius-md);
            font-size: var(--text-base);
            background-color: var(--color-background);
            color: var(--color-text);
            transition: border-color var(--transition-fast);
        }
        
        .form-input:focus {
            outline: none;
            border-color: var(--color-border-focus);
            box-shadow: 0 0 0 3px rgb(59 130 246 / 0.1);
        }
        
        .form-textarea {
            min-height: 80px;
            resize: vertical;
        }
        
        .form-select {
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%236b7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='m6 8 4 4 4-4'/%3e%3c/svg%3e");
            background-position: right var(--space-sm) center;
            background-repeat: no-repeat;
            background-size: 1.5em 1.5em;
            padding-right: 2.5rem;
        }
        
        /* Cards */
        .card {
            background-color: var(--color-surface-elevated);
            border: 1px solid var(--color-border);
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-sm);
            overflow: hidden;
        }
        
        .card-header {
            padding: var(--space-md) var(--space-lg);
            border-bottom: 1px solid var(--color-border);
            background-color: var(--color-surface);
        }
        
        .card-body {
            padding: var(--space-lg);
        }
        
        .card-title {
            font-size: var(--text-lg);
            font-weight: 600;
            margin-bottom: var(--space-xs);
        }
        
        /* Task-specific styles */
        .task-form {
            margin-bottom: var(--space-xl);
        }
        
        .task-list {
            display: flex;
            flex-direction: column;
            gap: var(--space-md);
        }
        
        .task-item {
            background-color: var(--color-surface-elevated);
            border: 1px solid var(--color-border);
            border-radius: var(--radius-lg);
            padding: var(--space-md);
            transition: all var(--transition-fast);
        }
        
        .task-item:hover {
            box-shadow: var(--shadow-md);
            transform: translateY(-1px);
        }
        
        .task-item.completed {
            opacity: 0.7;
        }
        
        .task-header {
            display: flex;
            align-items: flex-start;
            justify-content: space-between;
            margin-bottom: var(--space-sm);
        }
        
        .task-title {
            font-size: var(--text-base);
            font-weight: 500;
            color: var(--color-text);
            flex: 1;
        }
        
        .task-title.completed {
            text-decoration: line-through;
            color: var(--color-text-muted);
        }
        
        .task-actions {
            display: flex;
            gap: var(--space-xs);
        }
        
        .task-meta {
            display: flex;
            align-items: center;
            gap: var(--space-md);
            font-size: var(--text-sm);
            color: var(--color-text-muted);
        }
        
        .task-description {
            margin-top: var(--space-sm);
            color: var(--color-text-muted);
            font-size: var(--text-sm);
        }
        
        .priority-badge {
            padding: var(--space-xs) var(--space-sm);
            border-radius: var(--radius-sm);
            font-size: var(--text-xs);
            font-weight: 500;
            text-transform: uppercase;
        }
        
        .priority-low {
            background-color: #f0f9ff;
            color: #0369a1;
        }
        
        .priority-medium {
            background-color: #fefce8;
            color: #a16207;
        }
        
        .priority-high {
            background-color: #fef2f2;
            color: #dc2626;
        }
        
        .priority-urgent {
            background-color: #451a03;
            color: #ffffff;
        }
        
        /* Utilities */
        .hidden {
            display: none;
        }
        
        .text-center {
            text-align: center;
        }
        
        .mt-auto {
            margin-top: auto;
        }
        
        .loading {
            opacity: 0.6;
            pointer-events: none;
        }
        
        /* Animations */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .fade-in {
            animation: fadeIn var(--transition-normal);
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .spin {
            animation: spin 1s linear infinite;
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- Header -->
        <header class="app-header">
            <div class="header-content">
                <h1 class="app-title">
                    📋 Task Manager
                </h1>
                <div class="status-indicator">
                    <div class="status-dot" id="status-dot"></div>
                    <span id="status-text">Online</span>
                </div>
            </div>
        </header>

        <!-- Sidebar (hidden on mobile) -->
        <aside class="app-sidebar">
            <div class="card">
                <div class="card-header">
                    <h3 class="card-title">Filters</h3>
                </div>
                <div class="card-body">
                    <p class="text-center color-text-muted">Filters coming soon...</p>
                </div>
            </div>
        </aside>

        <!-- Main Content -->
        <main class="app-main">
            <div class="main-content">
                <!-- Task Creation Form -->
                <div class="card task-form">
                    <div class="card-header">
                        <h2 class="card-title">Add New Task</h2>
                    </div>
                    <div class="card-body">
                        <form id="task-form">
                            <div class="form-group">
                                <label for="task-title" class="form-label">Title *</label>
                                <input 
                                    type="text" 
                                    id="task-title" 
                                    class="form-input" 
                                    placeholder="Enter task title..."
                                    required
                                    maxlength="200"
                                >
                            </div>
                            
                            <div class="form-group">
                                <label for="task-description" class="form-label">Description</label>
                                <textarea 
                                    id="task-description" 
                                    class="form-input form-textarea" 
                                    placeholder="Enter task description..."
                                    maxlength="1000"
                                ></textarea>
                            </div>
                            
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: var(--space-md);">
                                <div class="form-group">
                                    <label for="task-priority" class="form-label">Priority</label>
                                    <select id="task-priority" class="form-input form-select">
                                        <option value="low">Low</option>
                                        <option value="medium" selected>Medium</option>
                                        <option value="high">High</option>
                                        <option value="urgent">Urgent</option>
                                    </select>
                                </div>
                                
                                <div class="form-group">
                                    <label for="task-due-date" class="form-label">Due Date</label>
                                    <input 
                                        type="datetime-local" 
                                        id="task-due-date" 
                                        class="form-input"
                                    >
                                </div>
                            </div>
                            
                            <button type="submit" class="btn btn-primary">
                                Add Task
                            </button>
                        </form>
                    </div>
                </div>

                <!-- Task List -->
                <div class="card">
                    <div class="card-header">
                        <h2 class="card-title">Tasks</h2>
                    </div>
                    <div class="card-body">
                        <div id="task-list" class="task-list">
                            <!-- Tasks will be rendered here -->
                        </div>
                        
                        <div id="empty-state" class="text-center" style="padding: var(--space-2xl);">
                            <p style="color: var(--color-text-muted); font-size: var(--text-lg);">
                                📝 No tasks yet. Add your first task above!
                            </p>
                        </div>
                    </div>
                </div>
            </div>
        </main>

        <!-- Footer -->
        <footer class="app-footer">
            <p>&copy; 2025 Offline Task Manager - All data stored locally</p>
        </footer>
    </div>

    <script>
        'use strict';
        
        /* ============================================
           🗄️ INDEXEDDB DATABASE MANAGER
           ============================================ */
        
        /**
         * 🔍 MAJOR FUNCTION POINT #1: DATABASE ARCHITECTURE
         * 
         * This is the foundation of our offline-first system. The TaskDatabase class
         * manages all data persistence using IndexedDB, which provides:
         * 
         * - 📦 Local storage that persists across browser sessions
         * - 🔍 Fast indexed queries for filtering and searching
         * - 💾 Transaction-based operations for data integrity
         * - 📱 Works offline without any server connection
         * 
         * Key Design Decisions:
         * - UUID-based primary keys for conflict-free replication
         * - Indexed fields for common query patterns (status, priority, dates)
         * - Structured data models with validation
         * - Error handling with graceful fallbacks
         */
        
        class TaskDatabase {
            constructor() {
                this.dbName = 'TaskManagerDB';
                this.version = 1;
                this.db = null;
                this.isInitialized = false;
            }
            
            /**
             * Initialize the database and create object stores
             * This runs once when the app first loads
             */
            async init() {
                if (this.isInitialized) {
                    return this.db;
                }
                
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(this.dbName, this.version);
                    
                    request.onerror = () => {
                        console.error('❌ Failed to open IndexedDB:', request.error);
                        reject(request.error);
                    };
                    
                    request.onsuccess = () => {
                        this.db = request.result;
                        this.isInitialized = true;
                        console.log('✅ IndexedDB initialized successfully');
                        resolve(this.db);
                    };
                    
                    // This runs only on first install or version upgrade
                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        console.log('🔧 Creating database schema...');
                        
                        // Create tasks object store
                        if (!db.objectStoreNames.contains('tasks')) {
                            const taskStore = db.createObjectStore('tasks', { keyPath: 'id' });
                            
                            // Create indexes for efficient querying
                            taskStore.createIndex('by-status', 'status', { unique: false });
                            taskStore.createIndex('by-priority', 'priority', { unique: false });
                            taskStore.createIndex('by-dueDate', 'dueDate', { unique: false });
                            taskStore.createIndex('by-created', 'createdAt', { unique: false });
                            taskStore.createIndex('by-modified', 'modifiedAt', { unique: false });
                            
                            console.log('📋 Tasks store created with indexes');
                        }
                        
                        // Create categories store (for future use)
                        if (!db.objectStoreNames.contains('categories')) {
                            const categoryStore = db.createObjectStore('categories', { keyPath: 'id' });
                            categoryStore.createIndex('by-name', 'name', { unique: true });
                            console.log('📂 Categories store created');
                        }
                        
                        // Create settings store
                        if (!db.objectStoreNames.contains('settings')) {
                            db.createObjectStore('settings', { keyPath: 'key' });
                            console.log('⚙️ Settings store created');
                        }
                    };
                });
            }
            
            /**
             * 🔍 MAJOR FUNCTION POINT #2: CRUD OPERATIONS
             * 
             * These methods implement the core Create, Read, Update, Delete operations
             * that form the backbone of any data-driven application.
             * 
             * Key Features:
             * - 🔒 Transaction-based operations for data integrity
             * - ✅ Input validation and sanitization
             * - 🔄 Automatic timestamp management
             * - 📊 Optimistic UI updates with error rollback
             * - 🎯 Type-safe operations with consistent error handling
             */
            
            /**
             * Create a new task
             */
            async createTask(taskData) {
                try {
                    // Validate and sanitize input
                    const task = this.validateTaskData(taskData);
                    
                    // Generate unique ID and timestamps
                    task.id = this.generateUUID();
                    task.createdAt = new Date().toISOString();
                    task.modifiedAt = task.createdAt;
                    task.completedAt = null;
                    
                    // Store in IndexedDB
                    const transaction = this.db.transaction(['tasks'], 'readwrite');
                    const store = transaction.objectStore('tasks');
                    
                    await new Promise((resolve, reject) => {
                        const request = store.add(task);
                        request.onsuccess = () => resolve(request.result);
                        request.onerror = () => reject(request.error);
                    });
                    
                    console.log('✅ Task created:', task.title);
                    return task;
                    
                } catch (error) {
                    console.error('❌ Failed to create task:', error);
                    throw new Error(`Failed to create task: ${error.message}`);
                }
            }
            
            /**
             * Read a single task by ID
             */
            async readTask(id) {
                try {
                    const transaction = this.db.transaction(['tasks'], 'readonly');
                    const store = transaction.objectStore('tasks');
                    
                    return new Promise((resolve, reject) => {
                        const request = store.get(id);
                        request.onsuccess = () => resolve(request.result);
                        request.onerror = () => reject(request.error);
                    });
                    
                } catch (error) {
                    console.error('❌ Failed to read task:', error);
                    throw error;
                }
            }
            
            /**
             * Update an existing task
             */
            async updateTask(id, updates) {
                try {
                    // Get existing task
                    const existingTask = await this.readTask(id);
                    if (!existingTask) {
                        throw new Error('Task not found');
                    }
                    
                    // Merge updates with existing data
                    const updatedTask = {
                        ...existingTask,
                        ...this.validateTaskData(updates, false),
                        id, // Preserve ID
                        createdAt: existingTask.createdAt, // Preserve creation time
                        modifiedAt: new Date().toISOString()
                    };
                    
                    // Handle completion status
                    if (updates.status === 'completed' && existingTask.status !== 'completed') {
                        updatedTask.completedAt = new Date().toISOString();
                    } else if (updates.status !== 'completed') {
                        updatedTask.completedAt = null;
                    }
                    
                    // Store updated task
                    const transaction = this.db.transaction(['tasks'], 'readwrite');
                    const store = transaction.objectStore('tasks');
                    
                    await new Promise((resolve, reject) => {
                        const request = store.put(updatedTask);
                        request.onsuccess = () => resolve(request.result);
                        request.onerror = () => reject(request.error);
                    });
                    
                    console.log('✅ Task updated:', updatedTask.title);
                    return updatedTask;
                    
                } catch (error) {
                    console.error('❌ Failed to update task:', error);
                    throw new Error(`Failed to update task: ${error.message}`);
                }
            }
            
            /**
             * Delete a task
             */
            async deleteTask(id) {
                try {
                    const transaction = this.db.transaction(['tasks'], 'readwrite');
                    const store = transaction.objectStore('tasks');
                    
                    await new Promise((resolve, reject) => {
                        const request = store.delete(id);
                        request.onsuccess = () => resolve(request.result);
                        request.onerror = () => reject(request.error);
                    });
                    
                    console.log('✅ Task deleted:', id);
                    return true;
                    
                } catch (error) {
                    console.error('❌ Failed to delete task:', error);
                    throw new Error(`Failed to delete task: ${error.message}`);
                }
            }
            
            /**
             * Get all tasks with optional filtering
             */
            async getAllTasks(filter = {}) {
                try {
                    const transaction = this.db.transaction(['tasks'], 'readonly');
                    const store = transaction.objectStore('tasks');
                    
                    // If filtering by status, use index for better performance
                    let request;
                    if (filter.status) {
                        const index = store.index('by-status');
                        request = index.getAll(filter.status);
                    } else {
                        request = store.getAll();
                    }
                    
                    const tasks = await new Promise((resolve, reject) => {
                        request.onsuccess = () => resolve(request.result);
                        request.onerror = () => reject(request.error);
                    });
                    
                    // Sort by creation date (newest first)
                    return tasks.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
                    
                } catch (error) {
                    console.error('❌ Failed to get tasks:', error);
                    throw error;
                }
            }
            
            /**
             * 🔍 MAJOR FUNCTION POINT #3: DATA VALIDATION & SECURITY
             * 
             * This method ensures data integrity and prevents XSS attacks by:
             * - 🛡️ Sanitizing all user inputs
             * - ✅ Validating data types and constraints
             * - 🔒 Preventing injection attacks
             * - 📏 Enforcing length limits
             * - 🎯 Providing helpful error messages
             */
            validateTaskData(data, requireTitle = true) {
                const sanitized = {};
                
                // Title validation
                if (data.title !== undefined) {
                    sanitized.title = this.sanitizeHTML(data.title.trim());
                    if (!sanitized.title && requireTitle) {
                        throw new Error('Title is required');
                    }
                    if (sanitized.title.length > 200) {
                        throw new Error('Title must be less than 200 characters');
                    }
                }
                
                // Description validation
                if (data.description !== undefined) {
                    sanitized.description = this.sanitizeHTML(data.description.trim());
                    if (sanitized.description.length > 1000) {
                        throw new Error('Description must be less than 1000 characters');
                    }
                }
                
                // Priority validation
                if (data.priority !== undefined) {
                    const validPriorities = ['low', 'medium', 'high', 'urgent'];
                    if (!validPriorities.includes(data.priority)) {
                        throw new Error('Invalid priority level');
                    }
                    sanitized.priority = data.priority;
                }
                
                // Status validation
                if (data.status !== undefined) {
                    const validStatuses = ['pending', 'completed', 'archived'];
                    if (!validStatuses.includes(data.status)) {
                        throw new Error('Invalid status');
                    }
                    sanitized.status = data.status;
                }
                
                // Due date validation
                if (data.dueDate !== undefined) {
                    if (data.dueDate) {
                        const date = new Date(data.dueDate);
                        if (isNaN(date.getTime())) {
                            throw new Error('Invalid due date');
                        }
                        sanitized.dueDate = date.toISOString();
                    } else {
                        sanitized.dueDate = null;
                    }
                }
                
                // Set defaults for new tasks
                if (requireTitle) {
                    sanitized.status = sanitized.status || 'pending';
                    sanitized.priority = sanitized.priority || 'medium';
                    sanitized.description = sanitized.description || '';
                    sanitized.dueDate = sanitized.dueDate || null;
                }
                
                return sanitized;
            }
            
            /**
             * Sanitize HTML input to prevent XSS attacks
             */
            sanitizeHTML(input) {
                if (typeof input !== 'string') return '';
                
                const div = document.createElement('div');
                div.textContent = input;
                return div.innerHTML;
            }
            
            /**
             * Generate UUID for unique task IDs
             */
            generateUUID() {
                return 'task-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
            }
        }
    </script>

    <script>
        /* ============================================
           📱 APP STATE & UI MANAGER
           ============================================ */
        
        /**
         * 🔍 MAJOR FUNCTION POINT #4: APPLICATION STATE MANAGEMENT
         * 
         * The TaskManager class serves as the main application controller that:
         * - 🏗️ Initializes the database and UI components
         * - 🔄 Manages application state and data flow
         * - 🎯 Coordinates between database operations and UI updates
         * - 📡 Handles online/offline status detection
         * - 🚀 Provides optimistic UI updates for better user experience
         * 
         * This follows the Model-View-Controller pattern where:
         * - Model: TaskDatabase (data layer)
         * - View: DOM manipulation methods (presentation layer)
         * - Controller: TaskManager (business logic layer)
         */
        
        class TaskManager {
            constructor() {
                this.database = new TaskDatabase();
                this.tasks = [];
                this.isOnline = navigator.onLine;
                this.isLoading = false;
                
                // DOM elements
                this.elements = {
                    taskForm: null,
                    taskList: null,
                    emptyState: null,
                    statusDot: null,
                    statusText: null
                };
                
                console.log('🚀 TaskManager initialized');
            }
            
            /**
             * Initialize the application
             */
            async init() {
                try {
                    console.log('🔧 Initializing Task Manager...');
                    
                    // Initialize database
                    await this.database.init();
                    
                    // Cache DOM elements
                    this.cacheElements();
                    
                    // Bind event listeners
                    this.bindEvents();
                    
                    // Load initial data
                    await this.loadTasks();
                    
                    // Setup online/offline detection
                    this.setupNetworkDetection();
                    
                    // Initial render
                    this.render();
                    
                    console.log('✅ Task Manager ready!');
                    
                } catch (error) {
                    console.error('❌ Failed to initialize Task Manager:', error);
                    this.showError('Failed to initialize the application. Please refresh the page.');
                }
            }
            
            /**
             * Cache frequently used DOM elements
             */
            cacheElements() {
                this.elements = {
                    taskForm: document.getElementById('task-form'),
                    taskList: document.getElementById('task-list'),
                    emptyState: document.getElementById('empty-state'),
                    statusDot: document.getElementById('status-dot'),
                    statusText: document.getElementById('status-text'),
                    
                    // Form inputs
                    titleInput: document.getElementById('task-title'),
                    descriptionInput: document.getElementById('task-description'),
                    priorityInput: document.getElementById('task-priority'),
                    dueDateInput: document.getElementById('task-due-date')
                };
                
                // Verify all elements exist
                for (const [key, element] of Object.entries(this.elements)) {
                    if (!element) {
                        console.warn(`⚠️ Element not found: ${key}`);
                    }
                }
            }
            
            /**
             * Bind event listeners
             */
            bindEvents() {
                // Form submission
                this.elements.taskForm?.addEventListener('submit', (e) => {
                    e.preventDefault();
                    this.handleCreateTask();
                });
                
                // Online/offline events
                window.addEventListener('online', () => this.handleNetworkChange(true));
                window.addEventListener('offline', () => this.handleNetworkChange(false));
                
                // Keyboard shortcuts
                document.addEventListener('keydown', (e) => {
                    // Ctrl/Cmd + Enter to submit form
                    if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
                        if (document.activeElement && 
                            this.elements.taskForm.contains(document.activeElement)) {
                            this.handleCreateTask();
                        }
                    }
                });
            }
            
            /**
             * 🔍 MAJOR FUNCTION POINT #5: TASK OPERATIONS WITH OPTIMISTIC UPDATES
             * 
             * This method demonstrates optimistic UI updates, a key pattern in modern web apps:
             * 
             * 1. 🎯 Immediately update the UI (optimistic)
             * 2. 💾 Persist data to IndexedDB 
             * 3. ✅ Confirm success or rollback on failure
             * 4. 🔄 Broadcast changes to other tabs (future feature)
             * 
             * Benefits:
             * - ⚡ Instant feedback for users
             * - 🏃 No waiting for database operations
             * - 🛡️ Graceful error handling with rollback
             * - 📱 Feels like a native app
             */
            
            /**
             * Handle task creation from form
             */
            async handleCreateTask() {
                if (this.isLoading) return;
                
                try {
                    // Get form data
                    const formData = this.getFormData();
                    if (!formData.title.trim()) {
                        this.showError('Please enter a task title');
                        return;
                    }
                    
                    this.setLoading(true);
                    
                    // Create optimistic task for immediate UI feedback
                    const optimisticTask = {
                        ...formData,
                        id: 'temp-' + Date.now(),
                        status: 'pending',
                        createdAt: new Date().toISOString(),
                        modifiedAt: new Date().toISOString(),
                        completedAt: null,
                        isOptimistic: true // Flag for UI styling
                    };
                    
                    // 1. Immediately add to UI (optimistic update)
                    this.tasks.unshift(optimisticTask);
                    this.render();
                    
                    try {
                        // 2. Persist to database
                        const savedTask = await this.database.createTask(formData);
                        
                        // 3. Replace optimistic task with real data
                        const index = this.tasks.findIndex(t => t.id === optimisticTask.id);
                        if (index !== -1) {
                            this.tasks[index] = savedTask;
                        }
                        
                        // Clear form and re-render
                        this.clearForm();
                        this.render();
                        
                        console.log('✅ Task created successfully');
                        
                    } catch (error) {
                        // 4. Rollback optimistic update on failure
                        this.tasks = this.tasks.filter(t => t.id !== optimisticTask.id);
                        this.render();
                        throw error;
                    }
                    
                } catch (error) {
                    console.error('❌ Failed to create task:', error);
                    this.showError('Failed to create task: ' + error.message);
                } finally {
                    this.setLoading(false);
                }
            }
            
            /**
             * Toggle task completion status
             */
            async toggleTaskComplete(taskId) {
                try {
                    const task = this.tasks.find(t => t.id === taskId);
                    if (!task) return;
                    
                    const newStatus = task.status === 'completed' ? 'pending' : 'completed';
                    
                    // Optimistic update
                    task.status = newStatus;
                    task.modifiedAt = new Date().toISOString();
                    if (newStatus === 'completed') {
                        task.completedAt = new Date().toISOString();
                    } else {
                        task.completedAt = null;
                    }
                    
                    this.render();
                    
                    // Persist to database
                    await this.database.updateTask(taskId, { status: newStatus });
                    
                    console.log(`✅ Task ${newStatus}:`, task.title);
                    
                } catch (error) {
                    console.error('❌ Failed to toggle task:', error);
                    // Reload tasks to restore correct state
                    await this.loadTasks();
                    this.showError('Failed to update task');
                }
            }
            
            /**
             * Delete a task
             */
            async deleteTask(taskId) {
                if (!confirm('Are you sure you want to delete this task?')) {
                    return;
                }
                
                try {
                    // Optimistic update
                    const taskIndex = this.tasks.findIndex(t => t.id === taskId);
                    const deletedTask = this.tasks[taskIndex];
                    
                    if (taskIndex !== -1) {
                        this.tasks.splice(taskIndex, 1);
                        this.render();
                    }
                    
                    // Persist to database
                    await this.database.deleteTask(taskId);
                    
                    console.log('✅ Task deleted:', deletedTask?.title);
                    
                } catch (error) {
                    console.error('❌ Failed to delete task:', error);
                    // Reload tasks to restore correct state
                    await this.loadTasks();
                    this.showError('Failed to delete task');
                }
            }
            
            /**
             * Load all tasks from database
             */
            async loadTasks() {
                try {
                    this.setLoading(true);
                    this.tasks = await this.database.getAllTasks();
                    console.log(`📋 Loaded ${this.tasks.length} tasks`);
                } catch (error) {
                    console.error('❌ Failed to load tasks:', error);
                    this.showError('Failed to load tasks');
                    this.tasks = [];
                } finally {
                    this.setLoading(false);
                }
            }
        }
    </script>

    <script>
        /* ============================================
           🎨 UI RENDERING & INTERACTION SYSTEM
           ============================================ */
        
        // Continue TaskManager class with rendering methods
        TaskManager.prototype.render = function() {
            this.renderTasks();
            this.updateEmptyState();
            this.updateNetworkStatus();
        };
        
        /**
         * 🔍 MAJOR FUNCTION POINT #4: DYNAMIC UI RENDERING SYSTEM
         * 
         * This rendering system creates a reactive UI that automatically updates when data changes:
         * 
         * - 🎯 **Virtual DOM-like rendering** without external dependencies
         * - ⚡ **Efficient updates** that only change what's necessary
         * - 🎨 **Component-based rendering** with reusable task items
         * - 📱 **Responsive design** that adapts to different screen sizes
         * - 🔄 **Real-time updates** reflecting data changes immediately
         * 
         * Key Benefits:
         * - No framework overhead, pure JavaScript
         * - Predictable rendering cycle
         * - Easy to debug and maintain
         * - Optimized for performance
         */
        
        /**
         * Render the complete task list
         */
        TaskManager.prototype.renderTasks = function() {
            if (!this.elements.taskList) return;
            
            // Clear existing content
            this.elements.taskList.innerHTML = '';
            
            if (this.tasks.length === 0) {
                return; // Empty state will be shown separately
            }
            
            // Create document fragment for efficient DOM manipulation
            const fragment = document.createDocumentFragment();
            
            // Render each task
            this.tasks.forEach(task => {
                const taskElement = this.createTaskElement(task);
                fragment.appendChild(taskElement);
            });
            
            // Add all tasks to DOM at once
            this.elements.taskList.appendChild(fragment);
            
            console.log(`🎨 Rendered ${this.tasks.length} tasks`);
        };
        
        /**
         * Create a single task element
         */
        TaskManager.prototype.createTaskElement = function(task) {
            const taskDiv = document.createElement('div');
            taskDiv.className = `task-item fade-in ${task.status === 'completed' ? 'completed' : ''}`;
            taskDiv.dataset.taskId = task.id;
            
            // Add loading state for optimistic updates
            if (task.isOptimistic) {
                taskDiv.classList.add('loading');
            }
            
            taskDiv.innerHTML = `
                <div class="task-header">
                    <h3 class="task-title ${task.status === 'completed' ? 'completed' : ''}">
                        ${this.escapeHtml(task.title)}
                    </h3>
                    <div class="task-actions">
                        <button 
                            class="btn btn-sm btn-secondary" 
                            onclick="taskManager.toggleTaskComplete('${task.id}')"
                            title="${task.status === 'completed' ? 'Mark as pending' : 'Mark as completed'}"
                        >
                            ${task.status === 'completed' ? '↩️' : '✅'}
                        </button>
                        <button 
                            class="btn btn-sm btn-secondary" 
                            onclick="taskManager.editTask('${task.id}')"
                            title="Edit task"
                        >
                            ✏️
                        </button>
                        <button 
                            class="btn btn-sm btn-secondary" 
                            onclick="taskManager.deleteTask('${task.id}')"
                            title="Delete task"
                        >
                            🗑️
                        </button>
                    </div>
                </div>
                
                ${task.description ? `
                    <div class="task-description">
                        ${this.escapeHtml(task.description)}
                    </div>
                ` : ''}
                
                <div class="task-meta">
                    <span class="priority-badge priority-${task.priority}">
                        ${task.priority}
                    </span>
                    
                    ${task.dueDate ? `
                        <span title="Due date">
                            📅 ${this.formatDateTime(task.dueDate)}
                        </span>
                    ` : ''}
                    
                    <span title="Created">
                        🕐 ${this.formatRelativeTime(task.createdAt)}
                    </span>
                    
                    ${task.completedAt ? `
                        <span title="Completed">
                            ✅ ${this.formatRelativeTime(task.completedAt)}
                        </span>
                    ` : ''}
                </div>
            `;
            
            return taskDiv;
        };
        
        /**
         * Update empty state visibility
         */
        TaskManager.prototype.updateEmptyState = function() {
            if (!this.elements.emptyState) return;
            
            const hasActiveTasks = this.tasks.some(task => task.status !== 'completed');
            const shouldShowEmpty = this.tasks.length === 0 || !hasActiveTasks;
            
            if (shouldShowEmpty && this.tasks.length === 0) {
                this.elements.emptyState.style.display = 'block';
                this.elements.emptyState.innerHTML = `
                    <div style="padding: var(--space-2xl);">
                        <div style="font-size: 3rem; margin-bottom: var(--space-md);">📝</div>
                        <h3 style="color: var(--color-text); margin-bottom: var(--space-sm);">No tasks yet</h3>
                        <p style="color: var(--color-text-muted); font-size: var(--text-base);">
                            Add your first task above to get started!
                        </p>
                    </div>
                `;
            } else if (shouldShowEmpty) {
                this.elements.emptyState.style.display = 'block';
                this.elements.emptyState.innerHTML = `
                    <div style="padding: var(--space-2xl);">
                        <div style="font-size: 3rem; margin-bottom: var(--space-md);">🎉</div>
                        <h3 style="color: var(--color-text); margin-bottom: var(--space-sm);">All tasks completed!</h3>
                        <p style="color: var(--color-text-muted); font-size: var(--text-base);">
                            Great job! You've completed all your tasks.
                        </p>
                    </div>
                `;
            } else {
                this.elements.emptyState.style.display = 'none';
            }
        };
        
        /**
         * Update network status indicator
         */
        TaskManager.prototype.updateNetworkStatus = function() {
            if (!this.elements.statusDot || !this.elements.statusText) return;
            
            if (this.isOnline) {
                this.elements.statusDot.classList.remove('offline');
                this.elements.statusText.textContent = 'Online';
            } else {
                this.elements.statusDot.classList.add('offline');
                this.elements.statusText.textContent = 'Offline';
            }
        };
        
        /**
         * 🔍 MAJOR FUNCTION POINT #5: ADVANCED TASK OPERATIONS
         * 
         * These methods handle complex task operations including:
         * - 📝 **Inline editing** with form validation
         * - 🔄 **Status management** with optimistic updates
         * - 🎯 **Bulk operations** for productivity
         * - 📱 **Mobile-friendly interactions** with touch support
         * 
         * Features:
         * - Modal-free editing experience
         * - Keyboard shortcuts for power users
         * - Undo/redo capabilities (future enhancement)
         * - Conflict resolution for concurrent edits
         */
        
        /**
         * Edit task (inline editing)
         */
        TaskManager.prototype.editTask = function(taskId) {
            const task = this.tasks.find(t => t.id === taskId);
            if (!task) return;
            
            // Create edit form
            const editForm = this.createEditForm(task);
            
            // Replace task element with edit form
            const taskElement = document.querySelector(`[data-task-id="${taskId}"]`);
            if (taskElement) {
                const editContainer = document.createElement('div');
                editContainer.className = 'task-item fade-in';
                editContainer.appendChild(editForm);
                
                taskElement.parentNode.replaceChild(editContainer, taskElement);
                
                // Focus title input
                const titleInput = editForm.querySelector('[name="title"]');
                if (titleInput) {
                    titleInput.focus();
                    titleInput.select();
                }
            }
        };
        
        /**
         * Create inline edit form
         */
        TaskManager.prototype.createEditForm = function(task) {
            const form = document.createElement('form');
            form.className = 'task-edit-form';
            
            form.innerHTML = `
                <div class="form-group">
                    <input 
                        type="text" 
                        name="title" 
                        class="form-input" 
                        value="${this.escapeHtml(task.title)}"
                        required
                        maxlength="200"
                    >
                </div>
                
                <div class="form-group">
                    <textarea 
                        name="description" 
                        class="form-input form-textarea" 
                        placeholder="Description..."
                        maxlength="1000"
                        style="min-height: 60px;"
                    >${this.escapeHtml(task.description || '')}</textarea>
                </div>
                
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: var(--space-sm); margin-bottom: var(--space-md);">
                    <select name="priority" class="form-input form-select">
                        <option value="low" ${task.priority === 'low' ? 'selected' : ''}>Low</option>
                        <option value="medium" ${task.priority === 'medium' ? 'selected' : ''}>Medium</option>
                        <option value="high" ${task.priority === 'high' ? 'selected' : ''}>High</option>
                        <option value="urgent" ${task.priority === 'urgent' ? 'selected' : ''}>Urgent</option>
                    </select>
                    
                    <input 
                        type="datetime-local" 
                        name="dueDate" 
                        class="form-input"
                        value="${task.dueDate ? new Date(task.dueDate).toISOString().slice(0, 16) : ''}"
                    >
                </div>
                
                <div style="display: flex; gap: var(--space-sm);">
                    <button type="submit" class="btn btn-primary btn-sm">Save</button>
                    <button type="button" class="btn btn-secondary btn-sm" onclick="taskManager.cancelEdit('${task.id}')">Cancel</button>
                </div>
            `;
            
            // Handle form submission
            form.addEventListener('submit', (e) => {
                e.preventDefault();
                this.saveTaskEdit(task.id, new FormData(form));
            });
            
            // Handle Escape key
            form.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    this.cancelEdit(task.id);
                }
            });
            
            return form;
        };
        
        /**
         * Save task edit
         */
        TaskManager.prototype.saveTaskEdit = async function(taskId, formData) {
            try {
                const updates = {
                    title: formData.get('title'),
                    description: formData.get('description'),
                    priority: formData.get('priority'),
                    dueDate: formData.get('dueDate') || null
                };
                
                // Optimistic update
                const task = this.tasks.find(t => t.id === taskId);
                if (task) {
                    Object.assign(task, updates);
                    task.modifiedAt = new Date().toISOString();
                }
                
                this.render();
                
                // Persist to database
                await this.database.updateTask(taskId, updates);
                
                console.log('✅ Task updated:', updates.title);
                
            } catch (error) {
                console.error('❌ Failed to update task:', error);
                this.showError('Failed to update task: ' + error.message);
                await this.loadTasks();
                this.render();
            }
        };
        
        /**
         * Cancel task edit
         */
        TaskManager.prototype.cancelEdit = function(taskId) {
            this.render(); // Re-render to restore original task display
        };
        
        /**
         * 🔍 MAJOR FUNCTION POINT #6: UTILITY & HELPER FUNCTIONS
         * 
         * These utility functions provide essential functionality for:
         * - 🛡️ **Security** (HTML escaping, input sanitization)
         * - 📅 **Date formatting** (relative time, localization)
         * - 🎯 **Form handling** (data extraction, validation)
         * - 🎨 **UI state management** (loading states, error handling)
         * 
         * These are the building blocks that make the app robust and user-friendly.
         */
        
        /**
         * Get form data as object
         */
        TaskManager.prototype.getFormData = function() {
            return {
                title: this.elements.titleInput?.value?.trim() || '',
                description: this.elements.descriptionInput?.value?.trim() || '',
                priority: this.elements.priorityInput?.value || 'medium',
                dueDate: this.elements.dueDateInput?.value || null
            };
        };
        
        /**
         * Clear the task form
         */
        TaskManager.prototype.clearForm = function() {
            if (this.elements.taskForm) {
                this.elements.taskForm.reset();
            }
        };
        
        /**
         * Set loading state
         */
        TaskManager.prototype.setLoading = function(loading) {
            this.isLoading = loading;
            
            if (this.elements.taskForm) {
                if (loading) {
                    this.elements.taskForm.classList.add('loading');
                } else {
                    this.elements.taskForm.classList.remove('loading');
                }
            }
        };
        
        /**
         * Handle network status change
         */
        TaskManager.prototype.handleNetworkChange = function(isOnline) {
            this.isOnline = isOnline;
            this.updateNetworkStatus();
            
            console.log(`📡 Network status: ${isOnline ? 'Online' : 'Offline'}`);
            
            if (isOnline) {
                // Future: Sync queued operations
                console.log('🔄 Connection restored - ready for sync');
            } else {
                console.log('📴 Working offline - changes will be queued');
            }
        };
        
        /**
         * Setup network detection
         */
        TaskManager.prototype.setupNetworkDetection = function() {
            this.isOnline = navigator.onLine;
            this.updateNetworkStatus();
        };
        
        /**
         * Show error message to user
         */
        TaskManager.prototype.showError = function(message) {
            // Create toast notification
            const toast = document.createElement('div');
            toast.className = 'toast error';
            toast.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: var(--color-danger);
                color: white;
                padding: var(--space-md);
                border-radius: var(--radius-md);
                box-shadow: var(--shadow-lg);
                z-index: 1000;
                max-width: 300px;
                animation: slideIn 0.3s ease-out;
            `;
            
            toast.textContent = message;
            document.body.appendChild(toast);
            
            // Auto remove after 5 seconds
            setTimeout(() => {
                if (toast.parentNode) {
                    toast.style.animation = 'slideOut 0.3s ease-in';
                    setTimeout(() => {
                        if (toast.parentNode) {
                            toast.parentNode.removeChild(toast);
                        }
                    }, 300);
                }
            }, 5000);
            
            // Add animation styles if not present
            if (!document.getElementById('toast-styles')) {
                const style = document.createElement('style');
                style.id = 'toast-styles';
                style.textContent = `
                    @keyframes slideIn {
                        from { transform: translateX(100%); opacity: 0; }
                        to { transform: translateX(0); opacity: 1; }
                    }
                    @keyframes slideOut {
                        from { transform: translateX(0); opacity: 1; }
                        to { transform: translateX(100%); opacity: 0; }
                    }
                `;
                document.head.appendChild(style);
            }
        };
        
        /**
         * Escape HTML to prevent XSS
         */
        TaskManager.prototype.escapeHtml = function(text) {
            const div = document.createElement('div');
            div.textContent = text || '';
            return div.innerHTML;
        };
        
        /**
         * Format date/time for display
         */
        TaskManager.prototype.formatDateTime = function(dateString) {
            try {
                const date = new Date(dateString);
                const now = new Date();
                const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
                const taskDate = new Date(date.getFullYear(), date.getMonth(), date.getDate());
                
                const time = date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                
                if (taskDate.getTime() === today.getTime()) {
                    return `Today ${time}`;
                } else if (taskDate.getTime() === today.getTime() + 86400000) {
                    return `Tomorrow ${time}`;
                } else if (taskDate.getTime() === today.getTime() - 86400000) {
                    return `Yesterday ${time}`;
                } else {
                    return date.toLocaleDateString() + ' ' + time;
                }
            } catch (error) {
                return 'Invalid date';
            }
        };
        
        /**
         * Format relative time (e.g., "2 hours ago")
         */
        TaskManager.prototype.formatRelativeTime = function(dateString) {
            try {
                const date = new Date(dateString);
                const now = new Date();
                const diffMs = now - date;
                const diffMins = Math.floor(diffMs / 60000);
                const diffHours = Math.floor(diffMins / 60);
                const diffDays = Math.floor(diffHours / 24);
                
                if (diffMins < 1) return 'Just now';
                if (diffMins < 60) return `${diffMins} min ago`;
                if (diffHours < 24) return `${diffHours}h ago`;
                if (diffDays < 7) return `${diffDays}d ago`;
                
                return date.toLocaleDateString();
            } catch (error) {
                return 'Unknown';
            }
        };
        
        /* ============================================
           🚀 APPLICATION INITIALIZATION
           ============================================ */
        
        /**
         * 🔍 MAJOR FUNCTION POINT #7: APPLICATION BOOTSTRAP
         * 
         * This is where everything comes together:
         * - 🏗️ **Initialize the TaskManager** with all components
         * - 📱 **Setup PWA features** for app-like experience
         * - 🎯 **Register Service Worker** for offline functionality
         * - 🔧 **Error handling** for graceful degradation
         * 
         * The bootstrap process ensures the app works reliably across
         * different browsers and network conditions.
         */
        
        // Global task manager instance
        let taskManager;
        
        /**
         * Initialize the application when DOM is ready
         */
        document.addEventListener('DOMContentLoaded', async function() {
            console.log('🚀 Starting Offline Task Manager...');
            
            try {
                // Create and initialize task manager
                taskManager = new TaskManager();
                await taskManager.init();
                
                // Setup PWA features
                setupPWA();
                
                console.log('✅ Application initialized successfully!');
                
            } catch (error) {
                console.error('❌ Failed to initialize application:', error);
                
                // Show fallback UI
                document.body.innerHTML = `
                    <div style="
                        display: flex; 
                        align-items: center; 
                        justify-content: center; 
                        min-height: 100vh; 
                        padding: 2rem;
                        text-align: center;
                        background: var(--color-background);
                        color: var(--color-text);
                    ">
                        <div>
                            <h1 style="margin-bottom: 1rem; color: var(--color-danger);">⚠️ Application Error</h1>
                            <p style="margin-bottom: 2rem; max-width: 400px;">
                                Failed to initialize the task manager. This might be due to your browser 
                                not supporting IndexedDB or other required features.
                            </p>
                            <button onclick="location.reload()" style="
                                padding: 0.75rem 1.5rem;
                                background: var(--color-primary);
                                color: white;
                                border: none;
                                border-radius: 0.5rem;
                                cursor: pointer;
                            ">
                                Try Again
                            </button>
                        </div>
                    </div>
                `;
            }
        });
        
        /**
         * Setup Progressive Web App features
         */
        function setupPWA() {
            // Create and inject manifest
            const manifestData = {
                name: 'Offline Task Manager',
                short_name: 'TaskManager',
                description: 'Offline-first task management system',
                start_url: '/',
                display: 'standalone',
                background_color: '#ffffff',
                theme_color: '#2563eb',
                orientation: 'portrait-primary',
                categories: ['productivity', 'utilities'],
                icons: [
                    {
                        src: 'data:image/svg+xml;base64,' + btoa(`
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 192 192" fill="#2563eb">
                                <rect x="20" y="20" width="152" height="152" rx="20" fill="#2563eb"/>
                                <path d="M60 96l20 20 40-40" stroke="white" stroke-width="8" fill="none" stroke-linecap="round" stroke-linejoin="round"/>
                                <rect x="40" y="60" width="12" height="12" rx="2" fill="white"/>
                                <rect x="40" y="80" width="12" height="12" rx="2" fill="white"/>
                                <rect x="40" y="100" width="12" height="12" rx="2" fill="white"/>
                                <rect x="40" y="120" width="12" height="12" rx="2" fill="white"/>
                            </svg>
                        `),
                        sizes: '192x192',
                        type: 'image/svg+xml'
                    },
                    {
                        src: 'data:image/svg+xml;base64,' + btoa(`
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" fill="#2563eb">
                                <rect x="50" y="50" width="412" height="412" rx="50" fill="#2563eb"/>
                                <path d="M160 256l60 60 120-120" stroke="white" stroke-width="20" fill="none" stroke-linecap="round" stroke-linejoin="round"/>
                                <rect x="100" y="160" width="32" height="32" rx="4" fill="white"/>
                                <rect x="100" y="220" width="32" height="32" rx="4" fill="white"/>
                                <rect x="100" y="280" width="32" height="32" rx="4" fill="white"/>
                                <rect x="100" y="340" width="32" height="32" rx="4" fill="white"/>
                            </svg>
                        `),
                        sizes: '512x512',
                        type: 'image/svg+xml'
                    }
                ]
            };
            
            // Inject manifest
            const manifestBlob = new Blob([JSON.stringify(manifestData)], { type: 'application/json' });
            const manifestURL = URL.createObjectURL(manifestBlob);
            const manifestLink = document.createElement('link');
            manifestLink.rel = 'manifest';
            manifestLink.href = manifestURL;
            document.head.appendChild(manifestLink);
            
            console.log('📱 PWA manifest injected');
        }
        
        /**
         * Handle beforeunload to warn about unsaved changes
         */
        window.addEventListener('beforeunload', function(e) {
            // Future: Check for unsaved changes
            // if (hasUnsavedChanges) {
            //     e.preventDefault();
            //     e.returnValue = '';
            // }
        });
        
        /**
         * Handle visibility change for background operations
         */
        document.addEventListener('visibilitychange', function() {
            if (document.visibilityState === 'visible') {
                console.log('👁️ App became visible - refreshing data');
                if (taskManager) {
                    taskManager.loadTasks().then(() => taskManager.render());
                }
            } else {
                console.log('🙈 App became hidden - pausing operations');
            }
        });
        
        // Expose taskManager globally for debugging
        window.taskManager = taskManager;
        
        console.log('🎯 Task Manager script loaded successfully');
    </script>
</body>
</html>