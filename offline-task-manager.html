<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Offline Task Manager</title>
    <meta name="description" content="Offline-first task management system with no external dependencies">
    
    <!-- PWA Meta Tags -->
    <meta name="theme-color" content="#2563eb">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="Task Manager">
    
    <style>
        /* ============================================
           🎨 CSS DESIGN SYSTEM & LAYOUT
           ============================================ */
        
        /* CSS Custom Properties for Theming */
        :root {
            /* Light theme colors */
            --color-primary: #2563eb;
            --color-primary-dark: #1d4ed8;
            --color-success: #10b981;
            --color-warning: #f59e0b;
            --color-danger: #ef4444;
            --color-background: #ffffff;
            --color-surface: #f8fafc;
            --color-surface-elevated: #ffffff;
            --color-text: #1e293b;
            --color-text-muted: #64748b;
            --color-border: #e2e8f0;
            --color-border-focus: #3b82f6;
            
            /* Spacing system */
            --space-xs: 0.25rem;
            --space-sm: 0.5rem;
            --space-md: 1rem;
            --space-lg: 1.5rem;
            --space-xl: 2rem;
            --space-2xl: 3rem;
            
            /* Typography scale */
            --text-xs: 0.75rem;
            --text-sm: 0.875rem;
            --text-base: 1rem;
            --text-lg: 1.125rem;
            --text-xl: 1.25rem;
            --text-2xl: 1.5rem;
            
            /* Border radius */
            --radius-sm: 0.125rem;
            --radius-md: 0.375rem;
            --radius-lg: 0.5rem;
            --radius-xl: 0.75rem;
            
            /* Shadows */
            --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
            --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
            
            /* Transitions */
            --transition-fast: 150ms ease-in-out;
            --transition-normal: 250ms ease-in-out;
            --transition-slow: 350ms ease-in-out;
        }
        
        /* Dark theme */
        [data-theme="dark"] {
            --color-background: #0f172a;
            --color-surface: #1e293b;
            --color-surface-elevated: #334155;
            --color-text: #f1f5f9;
            --color-text-muted: #94a3b8;
            --color-border: #334155;
        }
        
        /* Reset and base styles */
        *, *::before, *::after {
            box-sizing: border-box;
        }
        
        * {
            margin: 0;
            padding: 0;
        }
        
        html {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            line-height: 1.6;
            color: var(--color-text);
            background-color: var(--color-background);
        }
        
        body {
            min-height: 100vh;
            overflow-x: hidden;
        }
        
        /* ============================================
           📱 RESPONSIVE LAYOUT SYSTEM
           ============================================ */
        
        .app-container {
            display: grid;
            grid-template-areas: 
                "header"
                "main"
                "footer";
            grid-template-rows: auto 1fr auto;
            min-height: 100vh;
            background-color: var(--color-background);
        }
        
        @media (min-width: 768px) {
            .app-container {
                grid-template-areas: 
                    "header header"
                    "sidebar main"
                    "footer footer";
                grid-template-columns: 280px 1fr;
                grid-template-rows: auto 1fr auto;
            }
        }
        
        /* Header */
        .app-header {
            grid-area: header;
            background-color: var(--color-surface-elevated);
            border-bottom: 1px solid var(--color-border);
            padding: var(--space-md) var(--space-lg);
            box-shadow: var(--shadow-sm);
        }
        
        .header-content {
            display: flex;
            align-items: center;
            justify-content: space-between;
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .app-title {
            font-size: var(--text-xl);
            font-weight: 600;
            color: var(--color-primary);
            display: flex;
            align-items: center;
            gap: var(--space-sm);
        }
        
        .status-indicator {
            display: flex;
            align-items: center;
            gap: var(--space-sm);
            font-size: var(--text-sm);
            color: var(--color-text-muted);
        }
        
        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: var(--color-success);
        }
        
        .status-dot.offline {
            background-color: var(--color-danger);
        }
        
        /* Sync Status */
        .sync-status {
            display: flex;
            align-items: center;
            gap: var(--space-xs);
            margin-left: var(--space-md);
            font-size: 0.875rem;
            color: var(--color-text-secondary);
        }
        
        .sync-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: var(--color-primary);
            position: relative;
        }
        
        .sync-dot.syncing {
            background-color: var(--color-warning);
            animation: pulse 2s infinite;
        }
        
        .sync-dot.error {
            background-color: var(--color-danger);
        }
        
        .sync-dot.multi-tab {
            background-color: var(--color-success);
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.3);
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(1.2); }
        }
        
        /* Sidebar */
        .app-sidebar {
            grid-area: sidebar;
            background-color: var(--color-surface);
            border-right: 1px solid var(--color-border);
            padding: var(--space-lg);
            display: none;
        }
        
        @media (min-width: 768px) {
            .app-sidebar {
                display: block;
            }
        }
        
        /* Main content */
        .app-main {
            grid-area: main;
            padding: var(--space-lg);
            overflow-y: auto;
        }
        
        .main-content {
            max-width: 800px;
            margin: 0 auto;
        }
        
        /* Footer */
        .app-footer {
            grid-area: footer;
            background-color: var(--color-surface);
            border-top: 1px solid var(--color-border);
            padding: var(--space-md) var(--space-lg);
            text-align: center;
            font-size: var(--text-sm);
            color: var(--color-text-muted);
        }
        
        /* ============================================
           🧩 COMPONENT STYLES
           ============================================ */
        
        /* Buttons */
        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: var(--space-xs);
            padding: var(--space-sm) var(--space-md);
            border: 1px solid transparent;
            border-radius: var(--radius-md);
            font-size: var(--text-sm);
            font-weight: 500;
            text-decoration: none;
            cursor: pointer;
            transition: all var(--transition-fast);
            user-select: none;
        }
        
        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
        
        .btn-primary {
            background-color: var(--color-primary);
            color: white;
        }
        
        .btn-primary:hover:not(:disabled) {
            background-color: var(--color-primary-dark);
        }
        
        .btn-secondary {
            background-color: var(--color-surface-elevated);
            color: var(--color-text);
            border-color: var(--color-border);
        }
        
        .btn-secondary:hover:not(:disabled) {
            background-color: var(--color-surface);
        }
        
        .btn-sm {
            padding: var(--space-xs) var(--space-sm);
            font-size: var(--text-xs);
        }
        
        /* Forms */
        .form-group {
            margin-bottom: var(--space-md);
        }
        
        .form-label {
            display: block;
            margin-bottom: var(--space-xs);
            font-size: var(--text-sm);
            font-weight: 500;
            color: var(--color-text);
        }
        
        .form-input {
            width: 100%;
            padding: var(--space-sm) var(--space-md);
            border: 1px solid var(--color-border);
            border-radius: var(--radius-md);
            font-size: var(--text-base);
            background-color: var(--color-background);
            color: var(--color-text);
            transition: border-color var(--transition-fast);
        }
        
        .form-input:focus {
            outline: none;
            border-color: var(--color-border-focus);
            box-shadow: 0 0 0 3px rgb(59 130 246 / 0.1);
        }
        
        .form-textarea {
            min-height: 80px;
            resize: vertical;
        }
        
        .form-select {
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%236b7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='m6 8 4 4 4-4'/%3e%3c/svg%3e");
            background-position: right var(--space-sm) center;
            background-repeat: no-repeat;
            background-size: 1.5em 1.5em;
            padding-right: 2.5rem;
        }
        
        /* Cards */
        .card {
            background-color: var(--color-surface-elevated);
            border: 1px solid var(--color-border);
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-sm);
            overflow: hidden;
        }
        
        .card-header {
            padding: var(--space-md) var(--space-lg);
            border-bottom: 1px solid var(--color-border);
            background-color: var(--color-surface);
        }
        
        .card-body {
            padding: var(--space-lg);
        }
        
        .card-title {
            font-size: var(--text-lg);
            font-weight: 600;
            margin-bottom: var(--space-xs);
        }
        
        /* Task-specific styles */
        .task-form {
            margin-bottom: var(--space-xl);
        }
        
        .task-list {
            display: flex;
            flex-direction: column;
            gap: var(--space-md);
        }
        
        .task-item {
            background-color: var(--color-surface-elevated);
            border: 1px solid var(--color-border);
            border-radius: var(--radius-lg);
            padding: var(--space-md);
            transition: all var(--transition-fast);
        }
        
        .task-item:hover {
            box-shadow: var(--shadow-md);
            transform: translateY(-1px);
        }
        
        .task-item.completed {
            opacity: 0.7;
        }
        
        .task-header {
            display: flex;
            align-items: flex-start;
            justify-content: space-between;
            margin-bottom: var(--space-sm);
        }
        
        .task-title {
            font-size: var(--text-base);
            font-weight: 500;
            color: var(--color-text);
            flex: 1;
        }
        
        .task-title.completed {
            text-decoration: line-through;
            color: var(--color-text-muted);
        }
        
        .task-actions {
            display: flex;
            gap: var(--space-xs);
        }
        
        .task-meta {
            display: flex;
            align-items: center;
            gap: var(--space-md);
            font-size: var(--text-sm);
            color: var(--color-text-muted);
        }
        
        .task-description {
            margin-top: var(--space-sm);
            color: var(--color-text-muted);
            font-size: var(--text-sm);
        }
        
        .priority-badge {
            padding: var(--space-xs) var(--space-sm);
            border-radius: var(--radius-sm);
            font-size: var(--text-xs);
            font-weight: 500;
            text-transform: uppercase;
        }
        
        .priority-low {
            background-color: #f0f9ff;
            color: #0369a1;
        }
        
        .priority-medium {
            background-color: #fefce8;
            color: #a16207;
        }
        
        .priority-high {
            background-color: #fef2f2;
            color: #dc2626;
        }
        
        .priority-urgent {
            background-color: #451a03;
            color: #ffffff;
        }
        
        /* Utilities */
        .hidden {
            display: none;
        }
        
        .text-center {
            text-align: center;
        }
        
        .mt-auto {
            margin-top: auto;
        }
        
        .loading {
            opacity: 0.6;
            pointer-events: none;
        }
        
        /* Animations */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .fade-in {
            animation: fadeIn var(--transition-normal);
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .spin {
            animation: spin 1s linear infinite;
        }

        /* ============================================
           CATEGORY MANAGEMENT STYLES
           ============================================ */

        .color-picker {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: var(--space-xs);
            margin-top: var(--space-xs);
        }

        .color-option {
            width: 32px;
            height: 32px;
            border-radius: var(--radius-full);
            border: 2px solid transparent;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
        }

        .color-option:hover {
            transform: scale(1.1);
            border-color: var(--color-border);
        }

        .color-option.selected {
            border-color: var(--color-primary);
            transform: scale(1.2);
        }

        .color-option.selected::after {
            content: '✓';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-weight: bold;
            font-size: 12px;
            text-shadow: 0 0 2px rgba(0,0,0,0.8);
        }

        .icon-picker {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: var(--space-xs);
            margin-top: var(--space-xs);
        }

        .icon-option {
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 2px solid transparent;
            border-radius: var(--radius-md);
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 16px;
            background: var(--color-bg-secondary);
        }

        .icon-option:hover {
            border-color: var(--color-border);
            transform: scale(1.1);
        }

        .icon-option.selected {
            border-color: var(--color-primary);
            background: var(--color-primary-light);
        }

        .category-list {
            display: flex;
            flex-direction: column;
            gap: var(--space-sm);
        }

        .category-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: var(--space-md);
            border: 1px solid var(--color-border);
            border-radius: var(--radius-md);
            background: var(--color-bg);
        }

        .category-info {
            display: flex;
            align-items: center;
            gap: var(--space-sm);
            flex: 1;
        }

        .category-icon {
            font-size: 16px;
        }

        .category-color {
            width: 20px;
            height: 20px;
            border-radius: var(--radius-full);
            border: 2px solid var(--color-border);
        }

        .category-details {
            flex: 1;
        }

        .category-name {
            font-weight: 600;
            margin: 0;
            font-size: var(--text-sm);
        }

        .category-description {
            color: var(--color-text-muted);
            font-size: var(--text-xs);
            margin: 2px 0 0 0;
        }

        .category-stats {
            font-size: var(--text-xs);
            color: var(--color-text-muted);
            margin-left: var(--space-sm);
        }

        .category-actions {
            display: flex;
            gap: var(--space-xs);
        }

        .btn-icon {
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: none;
            border-radius: var(--radius-sm);
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s ease;
        }

        .btn-icon:hover {
            transform: scale(1.05);
        }

        .btn-edit {
            background: var(--color-warning-light);
            color: var(--color-warning);
        }

        .btn-edit:hover {
            background: var(--color-warning);
            color: white;
        }

        .btn-delete {
            background: var(--color-error-light);
            color: var(--color-error);
        }

        .btn-delete:hover {
            background: var(--color-error);
            color: white;
        }

        /* Category selector in task form */
        .task-category-tag {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 2px 8px;
            border-radius: var(--radius-full);
            font-size: var(--text-xs);
            font-weight: 500;
            color: white;
            margin-left: var(--space-xs);
        }

        /* Modal styles */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .modal-content {
            background: var(--color-bg);
            border-radius: var(--radius-lg);
            max-width: 600px;
            max-height: 90vh;
            width: 90%;
            overflow-y: auto;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
        }

        .modal-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: var(--space-lg);
            border-bottom: 1px solid var(--color-border);
        }

        .modal-title {
            margin: 0;
            font-size: var(--text-xl);
            font-weight: 600;
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: var(--color-text-muted);
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: var(--radius-sm);
            transition: all 0.2s ease;
        }

        .modal-close:hover {
            background: var(--color-bg-secondary);
            color: var(--color-text);
        }

        .modal-body {
            padding: var(--space-lg);
        }

        /* ============================================
           FILTER BAR STYLES
           ============================================ */

        .filter-bar {
            display: flex;
            align-items: center;
            gap: var(--space-md);
            padding: var(--space-md);
            background: var(--color-bg-secondary);
            border-top: 1px solid var(--color-border);
            border-bottom: 1px solid var(--color-border);
            flex-wrap: wrap;
        }

        .filter-group {
            display: flex;
            align-items: center;
            gap: var(--space-xs);
        }

        .filter-label {
            font-size: var(--text-sm);
            font-weight: 500;
            color: var(--color-text-muted);
            white-space: nowrap;
        }

        .filter-select {
            padding: 4px 8px;
            border: 1px solid var(--color-border);
            border-radius: var(--radius-sm);
            background: var(--color-bg);
            color: var(--color-text);
            font-size: var(--text-sm);
            min-width: 120px;
        }

        .filter-select:focus {
            outline: none;
            border-color: var(--color-primary);
            box-shadow: 0 0 0 2px var(--color-primary-light);
        }

        @media (max-width: 768px) {
            .filter-bar {
                flex-direction: column;
                align-items: stretch;
                gap: var(--space-sm);
            }
            
            .filter-group {
                justify-content: space-between;
            }
            
            .filter-select {
                flex: 1;
                margin-left: var(--space-sm);
            }
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- Header -->
        <header class="app-header">
            <div class="header-content">
                <h1 class="app-title">
                    📋 Task Manager
                </h1>
                <div class="status-indicator">
                    <div class="status-dot" id="status-dot"></div>
                    <span id="status-text">Online</span>
                    <div class="sync-status" id="sync-status">
                        <div class="sync-dot" id="sync-dot"></div>
                        <span id="sync-text">Sync Ready</span>
                    </div>
                </div>
            </div>
        </header>

        <!-- Sidebar (hidden on mobile) -->
        <aside class="app-sidebar">
            <div class="card">
                <div class="card-header">
                    <h3 class="card-title">Filters</h3>
                </div>
                <div class="card-body">
                    <p class="text-center color-text-muted">Filters coming soon...</p>
                </div>
            </div>
        </aside>

        <!-- Main Content -->
        <main class="app-main">
            <div class="main-content">
                <!-- Task Creation Form -->
                <div class="card task-form">
                    <div class="card-header">
                        <h2 class="card-title">Add New Task</h2>
                    </div>
                    <div class="card-body">
                        <form id="task-form">
                            <div class="form-group">
                                <label for="task-title" class="form-label">Title *</label>
                                <input 
                                    type="text" 
                                    id="task-title" 
                                    class="form-input" 
                                    placeholder="Enter task title..."
                                    required
                                    maxlength="200"
                                >
                            </div>
                            
                            <div class="form-group">
                                <label for="task-description" class="form-label">Description</label>
                                <textarea 
                                    id="task-description" 
                                    class="form-input form-textarea" 
                                    placeholder="Enter task description..."
                                    maxlength="1000"
                                ></textarea>
                            </div>
                            
                            <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: var(--space-md);">
                                <div class="form-group">
                                    <label for="task-category" class="form-label">Category</label>
                                    <select id="task-category" class="form-input form-select">
                                        <option value="">Loading categories...</option>
                                    </select>
                                </div>
                                
                                <div class="form-group">
                                    <label for="task-priority" class="form-label">Priority</label>
                                    <select id="task-priority" class="form-input form-select">
                                        <option value="low">Low</option>
                                        <option value="medium" selected>Medium</option>
                                        <option value="high">High</option>
                                        <option value="urgent">Urgent</option>
                                    </select>
                                </div>
                                
                                <div class="form-group">
                                    <label for="task-due-date" class="form-label">Due Date</label>
                                    <input 
                                        type="datetime-local" 
                                        id="task-due-date" 
                                        class="form-input"
                                    >
                                </div>
                            </div>
                            
                            <div style="display: flex; gap: var(--space-sm); align-items: center;">
                                <button type="submit" class="btn btn-primary">
                                    Add Task
                                </button>
                                <button type="button" class="btn btn-secondary" onclick="taskManager.openCategoryManager()" style="margin-left: auto;">
                                    📂 Manage Categories
                                </button>
                            </div>
                        </form>
                    </div>
                </div>

                <!-- Task List -->
                <div class="card">
                    <div class="card-header">
                        <h2 class="card-title">Tasks</h2>
                    </div>
                    
                    <!-- Filter Bar -->
                    <div class="filter-bar">
                        <div class="filter-group">
                            <label for="filter-category" class="filter-label">Category:</label>
                            <select id="filter-category" class="filter-select">
                                <option value="">All Categories</option>
                            </select>
                        </div>
                        
                        <div class="filter-group">
                            <label for="filter-status" class="filter-label">Status:</label>
                            <select id="filter-status" class="filter-select">
                                <option value="">All Tasks</option>
                                <option value="pending">Pending</option>
                                <option value="completed">Completed</option>
                            </select>
                        </div>
                        
                        <div class="filter-group">
                            <label for="filter-priority" class="filter-label">Priority:</label>
                            <select id="filter-priority" class="filter-select">
                                <option value="">All Priorities</option>
                                <option value="urgent">Urgent</option>
                                <option value="high">High</option>
                                <option value="medium">Medium</option>
                                <option value="low">Low</option>
                            </select>
                        </div>
                        
                        <button type="button" class="btn btn-secondary btn-sm" onclick="taskManager.clearFilters()">
                            Clear Filters
                        </button>
                    </div>
                    
                    <div class="card-body">
                        <div id="task-list" class="task-list">
                            <!-- Tasks will be rendered here -->
                        </div>
                        
                        <div id="empty-state" class="text-center" style="padding: var(--space-2xl);">
                            <p style="color: var(--color-text-muted); font-size: var(--text-lg);">
                                📝 No tasks yet. Add your first task above!
                            </p>
                        </div>
                    </div>
                </div>
            </div>
        </main>

        <!-- Category Management Modal -->
        <div id="category-modal" class="modal" style="display: none;">
            <div class="modal-content">
                <div class="modal-header">
                    <h2 class="modal-title">📂 Manage Categories</h2>
                    <button type="button" class="modal-close" onclick="taskManager.closeCategoryManager()">&times;</button>
                </div>
                <div class="modal-body">
                    <!-- Add New Category Form -->
                    <div class="card" style="margin-bottom: var(--space-lg);">
                        <div class="card-header">
                            <h3 class="card-title">Add New Category</h3>
                        </div>
                        <div class="card-body">
                            <form id="category-form">
                                <div class="form-group">
                                    <label for="category-name" class="form-label">Name *</label>
                                    <input 
                                        type="text" 
                                        id="category-name" 
                                        class="form-input" 
                                        placeholder="Enter category name..."
                                        required
                                        maxlength="50"
                                    >
                                </div>
                                
                                <div class="form-group">
                                    <label for="category-description" class="form-label">Description</label>
                                    <input 
                                        type="text" 
                                        id="category-description" 
                                        class="form-input" 
                                        placeholder="Enter category description..."
                                        maxlength="200"
                                    >
                                </div>
                                
                                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: var(--space-md);">
                                    <div class="form-group">
                                        <label class="form-label">Color</label>
                                        <div class="color-picker" id="category-color-picker">
                                            <!-- Color options will be rendered here -->
                                        </div>
                                        <input type="hidden" id="category-color" value="#3b82f6">
                                    </div>
                                    
                                    <div class="form-group">
                                        <label class="form-label">Icon</label>
                                        <div class="icon-picker" id="category-icon-picker">
                                            <!-- Icon options will be rendered here -->
                                        </div>
                                        <input type="hidden" id="category-icon" value="📋">
                                    </div>
                                </div>
                                
                                <button type="submit" class="btn btn-primary">
                                    Add Category
                                </button>
                            </form>
                        </div>
                    </div>
                    
                    <!-- Existing Categories List -->
                    <div class="card">
                        <div class="card-header">
                            <h3 class="card-title">Existing Categories</h3>
                        </div>
                        <div class="card-body">
                            <div id="category-list" class="category-list">
                                <!-- Categories will be rendered here -->
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Footer -->
        <footer class="app-footer">
            <p>&copy; 2025 Offline Task Manager - All data stored locally</p>
        </footer>
    </div>

    <script>
        'use strict';
        
        /* ============================================
           🗄️ INDEXEDDB DATABASE MANAGER
           ============================================ */
        
        /**
         * 🔍 MAJOR FUNCTION POINT #1: DATABASE ARCHITECTURE
         * 
         * This is the foundation of our offline-first system. The TaskDatabase class
         * manages all data persistence using IndexedDB, which provides:
         * 
         * - 📦 Local storage that persists across browser sessions
         * - 🔍 Fast indexed queries for filtering and searching
         * - 💾 Transaction-based operations for data integrity
         * - 📱 Works offline without any server connection
         * 
         * Key Design Decisions:
         * - UUID-based primary keys for conflict-free replication
         * - Indexed fields for common query patterns (status, priority, dates)
         * - Structured data models with validation
         * - Error handling with graceful fallbacks
         */
        
        class TaskDatabase {
            constructor() {
                this.dbName = 'TaskManagerDB';
                this.version = 1;
                this.db = null;
                this.isInitialized = false;
            }
            
            /**
             * Initialize the database and create object stores
             * This runs once when the app first loads
             */
            async init() {
                if (this.isInitialized) {
                    return this.db;
                }
                
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(this.dbName, this.version);
                    
                    request.onerror = () => {
                        console.error('❌ Failed to open IndexedDB:', request.error);
                        reject(request.error);
                    };
                    
                    request.onsuccess = () => {
                        this.db = request.result;
                        this.isInitialized = true;
                        console.log('✅ IndexedDB initialized successfully');
                        resolve(this.db);
                    };
                    
                    // This runs only on first install or version upgrade
                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        console.log('🔧 Creating database schema...');
                        
                        // Create tasks object store
                        if (!db.objectStoreNames.contains('tasks')) {
                            const taskStore = db.createObjectStore('tasks', { keyPath: 'id' });
                            
                            // Create indexes for efficient querying
                            taskStore.createIndex('by-status', 'status', { unique: false });
                            taskStore.createIndex('by-priority', 'priority', { unique: false });
                            taskStore.createIndex('by-dueDate', 'dueDate', { unique: false });
                            taskStore.createIndex('by-created', 'createdAt', { unique: false });
                            taskStore.createIndex('by-modified', 'modifiedAt', { unique: false });
                            
                            console.log('📋 Tasks store created with indexes');
                        }
                        
                        // Create categories store (for future use)
                        if (!db.objectStoreNames.contains('categories')) {
                            const categoryStore = db.createObjectStore('categories', { keyPath: 'id' });
                            categoryStore.createIndex('by-name', 'name', { unique: true });
                            console.log('📂 Categories store created');
                        }
                        
                        // Create settings store
                        if (!db.objectStoreNames.contains('settings')) {
                            db.createObjectStore('settings', { keyPath: 'key' });
                            console.log('⚙️ Settings store created');
                        }
                    };
                });
            }
            
            /**
             * 🔍 MAJOR FUNCTION POINT #2: CRUD OPERATIONS
             * 
             * These methods implement the core Create, Read, Update, Delete operations
             * that form the backbone of any data-driven application.
             * 
             * Key Features:
             * - 🔒 Transaction-based operations for data integrity
             * - ✅ Input validation and sanitization
             * - 🔄 Automatic timestamp management
             * - 📊 Optimistic UI updates with error rollback
             * - 🎯 Type-safe operations with consistent error handling
             */
            
            /**
             * Create a new task
             */
            async createTask(taskData) {
                try {
                    // Validate and sanitize input
                    const task = this.validateTaskData(taskData);
                    
                    // Generate unique ID and timestamps
                    task.id = this.generateUUID();
                    task.createdAt = new Date().toISOString();
                    task.modifiedAt = task.createdAt;
                    task.completedAt = null;
                    
                    // Store in IndexedDB
                    const transaction = this.db.transaction(['tasks'], 'readwrite');
                    const store = transaction.objectStore('tasks');
                    
                    await new Promise((resolve, reject) => {
                        const request = store.add(task);
                        request.onsuccess = () => resolve(request.result);
                        request.onerror = () => reject(request.error);
                    });
                    
                    console.log('✅ Task created:', task.title);
                    return task;
                    
                } catch (error) {
                    console.error('❌ Failed to create task:', error);
                    throw new Error(`Failed to create task: ${error.message}`);
                }
            }
            
            /**
             * Read a single task by ID
             */
            async readTask(id) {
                try {
                    const transaction = this.db.transaction(['tasks'], 'readonly');
                    const store = transaction.objectStore('tasks');
                    
                    return new Promise((resolve, reject) => {
                        const request = store.get(id);
                        request.onsuccess = () => resolve(request.result);
                        request.onerror = () => reject(request.error);
                    });
                    
                } catch (error) {
                    console.error('❌ Failed to read task:', error);
                    throw error;
                }
            }
            
            /**
             * Update an existing task
             */
            async updateTask(id, updates) {
                try {
                    // Get existing task
                    const existingTask = await this.readTask(id);
                    if (!existingTask) {
                        throw new Error('Task not found');
                    }
                    
                    // Merge updates with existing data
                    const updatedTask = {
                        ...existingTask,
                        ...this.validateTaskData(updates, false),
                        id, // Preserve ID
                        createdAt: existingTask.createdAt, // Preserve creation time
                        modifiedAt: new Date().toISOString()
                    };
                    
                    // Handle completion status
                    if (updates.status === 'completed' && existingTask.status !== 'completed') {
                        updatedTask.completedAt = new Date().toISOString();
                    } else if (updates.status !== 'completed') {
                        updatedTask.completedAt = null;
                    }
                    
                    // Store updated task
                    const transaction = this.db.transaction(['tasks'], 'readwrite');
                    const store = transaction.objectStore('tasks');
                    
                    await new Promise((resolve, reject) => {
                        const request = store.put(updatedTask);
                        request.onsuccess = () => resolve(request.result);
                        request.onerror = () => reject(request.error);
                    });
                    
                    console.log('✅ Task updated:', updatedTask.title);
                    return updatedTask;
                    
                } catch (error) {
                    console.error('❌ Failed to update task:', error);
                    throw new Error(`Failed to update task: ${error.message}`);
                }
            }
            
            /**
             * Delete a task
             */
            async deleteTask(id) {
                try {
                    const transaction = this.db.transaction(['tasks'], 'readwrite');
                    const store = transaction.objectStore('tasks');
                    
                    await new Promise((resolve, reject) => {
                        const request = store.delete(id);
                        request.onsuccess = () => resolve(request.result);
                        request.onerror = () => reject(request.error);
                    });
                    
                    console.log('✅ Task deleted:', id);
                    return true;
                    
                } catch (error) {
                    console.error('❌ Failed to delete task:', error);
                    throw new Error(`Failed to delete task: ${error.message}`);
                }
            }
            
            /**
             * Get all tasks with optional filtering
             */
            async getAllTasks(filter = {}) {
                try {
                    const transaction = this.db.transaction(['tasks'], 'readonly');
                    const store = transaction.objectStore('tasks');
                    
                    // If filtering by status, use index for better performance
                    let request;
                    if (filter.status) {
                        const index = store.index('by-status');
                        request = index.getAll(filter.status);
                    } else {
                        request = store.getAll();
                    }
                    
                    const tasks = await new Promise((resolve, reject) => {
                        request.onsuccess = () => resolve(request.result);
                        request.onerror = () => reject(request.error);
                    });
                    
                    // Sort by creation date (newest first)
                    return tasks.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
                    
                } catch (error) {
                    console.error('❌ Failed to get tasks:', error);
                    throw error;
                }
            }
            
            /**
             * 🔍 MAJOR FUNCTION POINT #3: DATA VALIDATION & SECURITY
             * 
             * This method ensures data integrity and prevents XSS attacks by:
             * - 🛡️ Sanitizing all user inputs
             * - ✅ Validating data types and constraints
             * - 🔒 Preventing injection attacks
             * - 📏 Enforcing length limits
             * - 🎯 Providing helpful error messages
             */
            validateTaskData(data, requireTitle = true) {
                const sanitized = {};
                
                // Title validation
                if (data.title !== undefined) {
                    sanitized.title = this.sanitizeHTML(data.title.trim());
                    if (!sanitized.title && requireTitle) {
                        throw new Error('Title is required');
                    }
                    if (sanitized.title.length > 200) {
                        throw new Error('Title must be less than 200 characters');
                    }
                }
                
                // Description validation
                if (data.description !== undefined) {
                    sanitized.description = this.sanitizeHTML(data.description.trim());
                    if (sanitized.description.length > 1000) {
                        throw new Error('Description must be less than 1000 characters');
                    }
                }
                
                // Priority validation
                if (data.priority !== undefined) {
                    const validPriorities = ['low', 'medium', 'high', 'urgent'];
                    if (!validPriorities.includes(data.priority)) {
                        throw new Error('Invalid priority level');
                    }
                    sanitized.priority = data.priority;
                }
                
                // Status validation
                if (data.status !== undefined) {
                    const validStatuses = ['pending', 'completed', 'archived'];
                    if (!validStatuses.includes(data.status)) {
                        throw new Error('Invalid status');
                    }
                    sanitized.status = data.status;
                }
                
                // Due date validation
                if (data.dueDate !== undefined) {
                    if (data.dueDate) {
                        const date = new Date(data.dueDate);
                        if (isNaN(date.getTime())) {
                            throw new Error('Invalid due date');
                        }
                        sanitized.dueDate = date.toISOString();
                    } else {
                        sanitized.dueDate = null;
                    }
                }
                
                // Category ID validation
                if (data.categoryId !== undefined) {
                    if (data.categoryId && typeof data.categoryId === 'string') {
                        sanitized.categoryId = data.categoryId;
                    } else {
                        sanitized.categoryId = null;
                    }
                }
                
                // Set defaults for new tasks
                if (requireTitle) {
                    sanitized.status = sanitized.status || 'pending';
                    sanitized.priority = sanitized.priority || 'medium';
                    sanitized.description = sanitized.description || '';
                    sanitized.dueDate = sanitized.dueDate || null;
                    sanitized.categoryId = sanitized.categoryId || null;
                }
                
                return sanitized;
            }
            
            /**
             * Sanitize HTML input to prevent XSS attacks
             */
            sanitizeHTML(input) {
                if (typeof input !== 'string') return '';
                
                const div = document.createElement('div');
                div.textContent = input;
                return div.innerHTML;
            }
            
            /**
             * Generate UUID for unique task IDs
             */
            generateUUID() {
                return 'task-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
            }

            /**
             * 🏷️ CATEGORY MANAGEMENT OPERATIONS
             * 
             * These methods provide CRUD operations for task categories/projects:
             * - ➕ Create new categories with validation
             * - 📋 Read categories with filtering and sorting
             * - ✏️ Update existing categories
             * - 🗑️ Delete categories with dependency checking
             */

            /**
             * Create a new category
             */
            async createCategory(categoryData) {
                try {
                    const category = this.validateCategoryData(categoryData);
                    category.id = this.generateCategoryUUID();
                    category.createdAt = new Date().toISOString();
                    category.modifiedAt = category.createdAt;
                    category.taskCount = 0;

                    const transaction = this.db.transaction(['categories'], 'readwrite');
                    const store = transaction.objectStore('categories');
                    
                    await new Promise((resolve, reject) => {
                        const request = store.add(category);
                        request.onsuccess = () => resolve(request.result);
                        request.onerror = () => reject(request.error);
                    });

                    console.log('📂 Category created:', category.name);
                    return category;
                } catch (error) {
                    console.error('❌ Error creating category:', error);
                    throw error;
                }
            }

            /**
             * Get all categories
             */
            async getAllCategories() {
                try {
                    const transaction = this.db.transaction(['categories'], 'readonly');
                    const store = transaction.objectStore('categories');
                    
                    const categories = await new Promise((resolve, reject) => {
                        const request = store.getAll();
                        request.onsuccess = () => resolve(request.result);
                        request.onerror = () => reject(request.error);
                    });

                    // Sort by name
                    return categories.sort((a, b) => a.name.localeCompare(b.name));
                } catch (error) {
                    console.error('❌ Error fetching categories:', error);
                    throw error;
                }
            }

            /**
             * Get category by ID
             */
            async getCategoryById(id) {
                try {
                    const transaction = this.db.transaction(['categories'], 'readonly');
                    const store = transaction.objectStore('categories');
                    
                    return await new Promise((resolve, reject) => {
                        const request = store.get(id);
                        request.onsuccess = () => resolve(request.result);
                        request.onerror = () => reject(request.error);
                    });
                } catch (error) {
                    console.error('❌ Error fetching category:', error);
                    throw error;
                }
            }

            /**
             * Update an existing category
             */
            async updateCategory(id, updates) {
                try {
                    const transaction = this.db.transaction(['categories'], 'readwrite');
                    const store = transaction.objectStore('categories');
                    
                    // Get existing category
                    const existing = await new Promise((resolve, reject) => {
                        const request = store.get(id);
                        request.onsuccess = () => resolve(request.result);
                        request.onerror = () => reject(request.error);
                    });

                    if (!existing) {
                        throw new Error('Category not found');
                    }

                    // Validate and merge updates
                    const validatedUpdates = this.validateCategoryData(updates, true);
                    const updatedCategory = {
                        ...existing,
                        ...validatedUpdates,
                        modifiedAt: new Date().toISOString()
                    };

                    await new Promise((resolve, reject) => {
                        const request = store.put(updatedCategory);
                        request.onsuccess = () => resolve(request.result);
                        request.onerror = () => reject(request.error);
                    });

                    console.log('📂 Category updated:', updatedCategory.name);
                    return updatedCategory;
                } catch (error) {
                    console.error('❌ Error updating category:', error);
                    throw error;
                }
            }

            /**
             * Delete a category
             */
            async deleteCategory(id) {
                try {
                    // Check if category has tasks
                    const tasksInCategory = await this.getTasksByCategory(id);
                    if (tasksInCategory.length > 0) {
                        throw new Error(`Cannot delete category: ${tasksInCategory.length} tasks are assigned to this category`);
                    }

                    const transaction = this.db.transaction(['categories'], 'readwrite');
                    const store = transaction.objectStore('categories');
                    
                    await new Promise((resolve, reject) => {
                        const request = store.delete(id);
                        request.onsuccess = () => resolve(request.result);
                        request.onerror = () => reject(request.error);
                    });

                    console.log('🗑️ Category deleted:', id);
                    return true;
                } catch (error) {
                    console.error('❌ Error deleting category:', error);
                    throw error;
                }
            }

            /**
             * Get tasks by category
             */
            async getTasksByCategory(categoryId) {
                try {
                    const transaction = this.db.transaction(['tasks'], 'readonly');
                    const store = transaction.objectStore('tasks');
                    
                    const tasks = await new Promise((resolve, reject) => {
                        const request = store.getAll();
                        request.onsuccess = () => resolve(request.result);
                        request.onerror = () => reject(request.error);
                    });

                    return tasks.filter(task => task.categoryId === categoryId);
                } catch (error) {
                    console.error('❌ Error fetching tasks by category:', error);
                    throw error;
                }
            }

            /**
             * Update category task count
             */
            async updateCategoryTaskCount(categoryId) {
                try {
                    const tasks = await this.getTasksByCategory(categoryId);
                    const category = await this.getCategoryById(categoryId);
                    
                    if (category) {
                        await this.updateCategory(categoryId, { taskCount: tasks.length });
                    }
                } catch (error) {
                    console.error('❌ Error updating category task count:', error);
                }
            }

            /**
             * Validate category data
             */
            validateCategoryData(data, isUpdate = false) {
                const sanitized = {};

                // Name validation (required for new categories)
                if (data.name !== undefined) {
                    if (typeof data.name !== 'string' || data.name.trim().length === 0) {
                        throw new Error('Category name is required');
                    }
                    if (data.name.trim().length > 50) {
                        throw new Error('Category name must be less than 50 characters');
                    }
                    sanitized.name = data.name.trim();
                } else if (!isUpdate) {
                    throw new Error('Category name is required');
                }

                // Description validation (optional)
                if (data.description !== undefined) {
                    if (typeof data.description !== 'string') {
                        throw new Error('Description must be a string');
                    }
                    if (data.description.length > 200) {
                        throw new Error('Description must be less than 200 characters');
                    }
                    sanitized.description = data.description.trim();
                }

                // Color validation
                if (data.color !== undefined) {
                    const validColors = [
                        '#3b82f6', // blue
                        '#10b981', // emerald
                        '#f59e0b', // amber
                        '#ef4444', // red
                        '#8b5cf6', // violet
                        '#06b6d4', // cyan
                        '#84cc16', // lime
                        '#f97316', // orange
                        '#ec4899', // pink
                        '#6b7280'  // gray
                    ];
                    if (!validColors.includes(data.color)) {
                        throw new Error('Invalid color selection');
                    }
                    sanitized.color = data.color;
                } else if (!isUpdate) {
                    // Default color for new categories
                    sanitized.color = '#3b82f6';
                }

                // Icon validation (optional)
                if (data.icon !== undefined) {
                    const validIcons = [
                        '📋', '💼', '🏠', '🎯', '⚡', '🔥', '📚', '🎨', 
                        '💻', '🚗', '✈️', '🏃', '🍎', '💡', '📈', '🔧'
                    ];
                    if (!validIcons.includes(data.icon)) {
                        throw new Error('Invalid icon selection');
                    }
                    sanitized.icon = data.icon;
                } else if (!isUpdate) {
                    // Default icon for new categories
                    sanitized.icon = '📋';
                }

                return sanitized;
            }

            /**
             * Generate a UUID for new categories
             */
            generateCategoryUUID() {
                return 'category-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
            }
        }
    </script>

    <script>
        /* ============================================
           📱 APP STATE & UI MANAGER
           ============================================ */
        
        /**
         * 🔍 MAJOR FUNCTION POINT #4: APPLICATION STATE MANAGEMENT
         * 
         * The TaskManager class serves as the main application controller that:
         * - 🏗️ Initializes the database and UI components
         * - 🔄 Manages application state and data flow
         * - 🎯 Coordinates between database operations and UI updates
         * - 📡 Handles online/offline status detection
         * - 🚀 Provides optimistic UI updates for better user experience
         * 
         * This follows the Model-View-Controller pattern where:
         * - Model: TaskDatabase (data layer)
         * - View: DOM manipulation methods (presentation layer)
         * - Controller: TaskManager (business logic layer)
         */
        
        /**
         * CrossTabSyncManager - Handles real-time synchronization across browser tabs
         * Uses BroadcastChannel API for inter-tab communication
         */
        class CrossTabSyncManager {
            constructor() {
                this.channelName = 'task-manager-sync';
                this.tabId = this.generateTabId();
                this.channel = null;
                this.isSupported = this.checkBroadcastChannelSupport();
                this.syncCallbacks = new Map();
                this.lastSyncTimestamp = Date.now();
                
                console.log(`🔄 CrossTabSyncManager initialized for tab: ${this.tabId}`);
                
                if (this.isSupported) {
                    this.initializeChannel();
                }
            }
            
            /**
             * Generate unique tab identifier
             */
            generateTabId() {
                return `tab-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
            }
            
            /**
             * Check if BroadcastChannel is supported
             */
            checkBroadcastChannelSupport() {
                return typeof BroadcastChannel !== 'undefined';
            }
            
            /**
             * Initialize BroadcastChannel for tab communication
             */
            initializeChannel() {
                try {
                    this.channel = new BroadcastChannel(this.channelName);
                    this.channel.addEventListener('message', this.handleMessage.bind(this));
                    
                    console.log(`✅ BroadcastChannel initialized: ${this.channelName}`);
                    
                    // Announce this tab's presence
                    this.broadcast({
                        type: 'TAB_CONNECTED',
                        tabId: this.tabId,
                        timestamp: Date.now()
                    });
                    
                } catch (error) {
                    console.error('❌ Failed to initialize BroadcastChannel:', error);
                    this.isSupported = false;
                }
            }
            
            /**
             * Handle incoming messages from other tabs
             */
            handleMessage(event) {
                try {
                    const { type, data, tabId, timestamp } = event.data;
                    
                    // Ignore messages from this tab
                    if (tabId === this.tabId) {
                        return;
                    }
                    
                    console.log(`📨 Received sync message from ${tabId}:`, type, data);
                    
                    // Update last sync timestamp
                    if (timestamp > this.lastSyncTimestamp) {
                        this.lastSyncTimestamp = timestamp;
                    }
                    
                    // Execute registered callbacks for this message type
                    if (this.syncCallbacks.has(type)) {
                        const callbacks = this.syncCallbacks.get(type);
                        callbacks.forEach(callback => {
                            try {
                                callback(data, tabId, timestamp);
                            } catch (error) {
                                console.error(`❌ Sync callback error for ${type}:`, error);
                            }
                        });
                    }
                    
                } catch (error) {
                    console.error('❌ Error handling sync message:', error);
                }
            }
            
            /**
             * Broadcast message to all other tabs
             */
            broadcast(message) {
                if (!this.isSupported || !this.channel) {
                    console.warn('⚠️ BroadcastChannel not available, sync disabled');
                    return false;
                }
                
                try {
                    const syncMessage = {
                        ...message,
                        tabId: this.tabId,
                        timestamp: Date.now()
                    };
                    
                    this.channel.postMessage(syncMessage);
                    console.log(`📤 Broadcasted ${message.type} to other tabs`);
                    return true;
                    
                } catch (error) {
                    console.error('❌ Failed to broadcast message:', error);
                    return false;
                }
            }
            
            /**
             * Register callback for specific sync message types
             */
            onSync(messageType, callback) {
                if (!this.syncCallbacks.has(messageType)) {
                    this.syncCallbacks.set(messageType, []);
                }
                this.syncCallbacks.get(messageType).push(callback);
                
                console.log(`🔔 Registered sync callback for: ${messageType}`);
            }
            
            /**
             * Unregister callback for specific sync message types
             */
            offSync(messageType, callback) {
                if (this.syncCallbacks.has(messageType)) {
                    const callbacks = this.syncCallbacks.get(messageType);
                    const index = callbacks.indexOf(callback);
                    if (index > -1) {
                        callbacks.splice(index, 1);
                        console.log(`🔕 Unregistered sync callback for: ${messageType}`);
                    }
                }
            }
            
            /**
             * Sync task creation across tabs
             */
            syncTaskCreate(task) {
                return this.broadcast({
                    type: 'TASK_CREATED',
                    data: task
                });
            }
            
            /**
             * Sync task update across tabs
             */
            syncTaskUpdate(task) {
                return this.broadcast({
                    type: 'TASK_UPDATED',
                    data: task
                });
            }
            
            /**
             * Sync task deletion across tabs
             */
            syncTaskDelete(taskId) {
                return this.broadcast({
                    type: 'TASK_DELETED',
                    data: { id: taskId }
                });
            }
            
            /**
             * Sync task completion across tabs
             */
            syncTaskComplete(taskId, completed) {
                return this.broadcast({
                    type: 'TASK_COMPLETED',
                    data: { id: taskId, completed }
                });
            }
            
            /**
             * Get sync status information
             */
            getSyncStatus() {
                return {
                    isSupported: this.isSupported,
                    tabId: this.tabId,
                    channelName: this.channelName,
                    lastSyncTimestamp: this.lastSyncTimestamp,
                    registeredCallbacks: Array.from(this.syncCallbacks.keys())
                };
            }
            
            /**
             * Cleanup resources when tab is closing
             */
            destroy() {
                if (this.channel) {
                    // Announce tab disconnection
                    this.broadcast({
                        type: 'TAB_DISCONNECTED',
                        tabId: this.tabId
                    });
                    
                    this.channel.close();
                    this.channel = null;
                }
                
                this.syncCallbacks.clear();
                console.log(`🔄 CrossTabSyncManager destroyed for tab: ${this.tabId}`);
            }
        }

        /**
         * 🏷️ CATEGORY MANAGER CLASS
         * 
         * Manages category lifecycle, validation, and business logic:
         * - 📂 Category CRUD operations with validation
         * - 🎨 Color and icon management
         * - 📊 Task count tracking and statistics
         * - 🔄 Integration with task operations and sync
         */
        class CategoryManager {
            constructor(database) {
                this.database = database;
                this.categories = new Map();
                this.defaultCategories = [
                    { name: 'Personal', color: '#3b82f6', icon: '🏠', description: 'Personal tasks and reminders' },
                    { name: 'Work', color: '#10b981', icon: '💼', description: 'Work-related tasks and projects' },
                    { name: 'Shopping', color: '#f59e0b', icon: '🛒', description: 'Shopping lists and purchases' },
                    { name: 'Health', color: '#ef4444', icon: '🏃', description: 'Health and fitness goals' }
                ];
            }

            /**
             * Initialize categories - create defaults if none exist
             */
            async init() {
                try {
                    console.log('🏷️ Initializing CategoryManager...');
                    
                    // Load existing categories
                    await this.loadCategories();
                    
                    // Create default categories if none exist
                    if (this.categories.size === 0) {
                        console.log('📂 Creating default categories...');
                        for (const categoryData of this.defaultCategories) {
                            await this.createCategory(categoryData);
                        }
                    }
                    
                    console.log(`📂 CategoryManager initialized with ${this.categories.size} categories`);
                } catch (error) {
                    console.error('❌ Error initializing CategoryManager:', error);
                    throw error;
                }
            }

            /**
             * Load all categories from database
             */
            async loadCategories() {
                try {
                    const categories = await this.database.getAllCategories();
                    this.categories.clear();
                    
                    for (const category of categories) {
                        // Update task count
                        const tasks = await this.database.getTasksByCategory(category.id);
                        category.taskCount = tasks.length;
                        this.categories.set(category.id, category);
                    }
                    
                    console.log(`📂 Loaded ${categories.length} categories`);
                } catch (error) {
                    console.error('❌ Error loading categories:', error);
                    throw error;
                }
            }

            /**
             * Create a new category
             */
            async createCategory(categoryData) {
                try {
                    // Check for duplicate names
                    const existingName = Array.from(this.categories.values())
                        .find(cat => cat.name.toLowerCase() === categoryData.name.toLowerCase());
                    
                    if (existingName) {
                        throw new Error('A category with this name already exists');
                    }

                    const category = await this.database.createCategory(categoryData);
                    this.categories.set(category.id, category);
                    
                    console.log('📂 Category created:', category.name);
                    return category;
                } catch (error) {
                    console.error('❌ Error creating category:', error);
                    throw error;
                }
            }

            /**
             * Update an existing category
             */
            async updateCategory(id, updates) {
                try {
                    // Check for duplicate names (excluding current category)
                    if (updates.name) {
                        const existingName = Array.from(this.categories.values())
                            .find(cat => cat.id !== id && cat.name.toLowerCase() === updates.name.toLowerCase());
                        
                        if (existingName) {
                            throw new Error('A category with this name already exists');
                        }
                    }

                    const updatedCategory = await this.database.updateCategory(id, updates);
                    this.categories.set(id, updatedCategory);
                    
                    console.log('📂 Category updated:', updatedCategory.name);
                    return updatedCategory;
                } catch (error) {
                    console.error('❌ Error updating category:', error);
                    throw error;
                }
            }

            /**
             * Delete a category
             */
            async deleteCategory(id) {
                try {
                    const category = this.categories.get(id);
                    if (!category) {
                        throw new Error('Category not found');
                    }

                    // Check if it's a default category
                    const isDefault = this.defaultCategories.some(def => def.name === category.name);
                    if (isDefault && this.categories.size <= this.defaultCategories.length) {
                        throw new Error('Cannot delete default category when it\'s one of the last categories');
                    }

                    await this.database.deleteCategory(id);
                    this.categories.delete(id);
                    
                    console.log('🗑️ Category deleted:', category.name);
                    return true;
                } catch (error) {
                    console.error('❌ Error deleting category:', error);
                    throw error;
                }
            }

            /**
             * Get category by ID
             */
            getCategory(id) {
                return this.categories.get(id);
            }

            /**
             * Get all categories as array
             */
            getAllCategories() {
                return Array.from(this.categories.values())
                    .sort((a, b) => a.name.localeCompare(b.name));
            }

            /**
             * Get categories with task statistics
             */
            async getCategoriesWithStats() {
                try {
                    const categories = this.getAllCategories();
                    const statsPromises = categories.map(async (category) => {
                        const tasks = await this.database.getTasksByCategory(category.id);
                        const completedTasks = tasks.filter(task => task.status === 'completed');
                        
                        return {
                            ...category,
                            taskCount: tasks.length,
                            completedCount: completedTasks.length,
                            pendingCount: tasks.length - completedTasks.length,
                            completionRate: tasks.length > 0 ? (completedTasks.length / tasks.length * 100).toFixed(1) : '0'
                        };
                    });
                    
                    return await Promise.all(statsPromises);
                } catch (error) {
                    console.error('❌ Error getting category stats:', error);
                    return this.getAllCategories();
                }
            }

            /**
             * Update task counts for all categories
             */
            async updateAllTaskCounts() {
                try {
                    for (const [categoryId, category] of this.categories) {
                        const tasks = await this.database.getTasksByCategory(categoryId);
                        category.taskCount = tasks.length;
                        await this.database.updateCategory(categoryId, { taskCount: tasks.length });
                    }
                } catch (error) {
                    console.error('❌ Error updating task counts:', error);
                }
            }

            /**
             * Get color palette for categories
             */
            getColorPalette() {
                return [
                    { value: '#3b82f6', name: 'Blue', sample: '🔵' },
                    { value: '#10b981', name: 'Emerald', sample: '🟢' },
                    { value: '#f59e0b', name: 'Amber', sample: '🟡' },
                    { value: '#ef4444', name: 'Red', sample: '🔴' },
                    { value: '#8b5cf6', name: 'Violet', sample: '🟣' },
                    { value: '#06b6d4', name: 'Cyan', sample: '🔵' },
                    { value: '#84cc16', name: 'Lime', sample: '🟢' },
                    { value: '#f97316', name: 'Orange', sample: '🟠' },
                    { value: '#ec4899', name: 'Pink', sample: '🩷' },
                    { value: '#6b7280', name: 'Gray', sample: '⚫' }
                ];
            }

            /**
             * Get icon palette for categories
             */
            getIconPalette() {
                return [
                    { value: '📋', name: 'Clipboard' },
                    { value: '💼', name: 'Briefcase' },
                    { value: '🏠', name: 'Home' },
                    { value: '🎯', name: 'Target' },
                    { value: '⚡', name: 'Lightning' },
                    { value: '🔥', name: 'Fire' },
                    { value: '📚', name: 'Books' },
                    { value: '🎨', name: 'Art' },
                    { value: '💻', name: 'Computer' },
                    { value: '🚗', name: 'Car' },
                    { value: '✈️', name: 'Airplane' },
                    { value: '🏃', name: 'Running' },
                    { value: '🍎', name: 'Apple' },
                    { value: '💡', name: 'Lightbulb' },
                    { value: '📈', name: 'Chart' },
                    { value: '🔧', name: 'Tool' }
                ];
            }

            /**
             * Validate category assignment to task
             */
            async validateCategoryAssignment(categoryId) {
                if (!categoryId) return true; // Null/undefined is valid (no category)
                
                const category = this.categories.get(categoryId);
                if (!category) {
                    throw new Error('Invalid category ID');
                }
                
                return true;
            }

            /**
             * Get categories for dropdown/selector
             */
            getCategoriesForSelector() {
                const categories = this.getAllCategories();
                return [
                    { id: null, name: 'No Category', color: '#6b7280', icon: '📄' },
                    ...categories
                ];
            }
        }
        
        class TaskManager {
            constructor() {
                this.database = new TaskDatabase();
                this.syncManager = new CrossTabSyncManager();
                this.backgroundSyncManager = null; // Will be initialized after database
                this.categoryManager = null; // Will be initialized with database
                this.tasks = [];
                this.isOnline = navigator.onLine;
                this.isLoading = false;
                
                // DOM elements
                this.elements = {
                    taskForm: null,
                    taskList: null,
                    emptyState: null,
                    statusDot: null,
                    statusText: null
                };
                
                console.log('🚀 TaskManager initialized');
            }
            
            /**
             * Initialize the application
             */
            async init() {
                try {
                    console.log('🔧 Initializing Task Manager...');
                    
                    // Initialize database
                    await this.database.init();
                    
                    // Initialize Category Manager
                    this.categoryManager = new CategoryManager(this.database);
                    await this.categoryManager.init();
                    console.log('✅ Category Manager initialized');
                    
                    // Initialize Background Sync Manager
                    this.backgroundSyncManager = new BackgroundSyncManager(this.database);
                    await this.backgroundSyncManager.init();
                    console.log('✅ Background Sync Manager initialized');
                    
                    // Cache DOM elements
                    this.cacheElements();
                    
                    // Bind event listeners
                    this.bindEvents();
                    
                    // Load initial data
                    await this.loadTasks();
                    
                    // Setup online/offline detection
                    this.setupNetworkDetection();
                    
                    // Setup cross-tab synchronization
                    this.setupCrossTabSync();
                    
                    // Setup background sync integration
                    this.setupBackgroundSyncIntegration();
                    
                    // Initial render
                    this.render();
                    
                    // Initialize category selector
                    await this.initializeCategorySelector();
                    
                    // Initialize filters
                    this.initializeFilters();
                    
                    console.log('✅ Task Manager ready!');
                    
                } catch (error) {
                    console.error('❌ Failed to initialize Task Manager:', error);
                    this.showError('Failed to initialize the application. Please refresh the page.');
                }
            }
            
            /**
             * Cache frequently used DOM elements
             */
            cacheElements() {
                this.elements = {
                    taskForm: document.getElementById('task-form'),
                    taskList: document.getElementById('task-list'),
                    emptyState: document.getElementById('empty-state'),
                    statusDot: document.getElementById('status-dot'),
                    statusText: document.getElementById('status-text'),
                    syncDot: document.getElementById('sync-dot'),
                    syncText: document.getElementById('sync-text'),
                    
                    // Form inputs
                    titleInput: document.getElementById('task-title'),
                    descriptionInput: document.getElementById('task-description'),
                    categoryInput: document.getElementById('task-category'),
                    priorityInput: document.getElementById('task-priority'),
                    dueDateInput: document.getElementById('task-due-date')
                };
                
                // Verify all elements exist
                for (const [key, element] of Object.entries(this.elements)) {
                    if (!element) {
                        console.warn(`⚠️ Element not found: ${key}`);
                    }
                }
            }
            
            /**
             * Bind event listeners
             */
            bindEvents() {
                // Form submission
                this.elements.taskForm?.addEventListener('submit', (e) => {
                    e.preventDefault();
                    this.handleCreateTask();
                });
                
                // Online/offline events
                window.addEventListener('online', () => this.handleNetworkChange(true));
                window.addEventListener('offline', () => this.handleNetworkChange(false));
                
                // Keyboard shortcuts
                document.addEventListener('keydown', (e) => {
                    // Ctrl/Cmd + Enter to submit form
                    if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
                        if (document.activeElement && 
                            this.elements.taskForm.contains(document.activeElement)) {
                            this.handleCreateTask();
                        }
                    }
                });
            }
            
            /**
             * 🔍 MAJOR FUNCTION POINT #5: TASK OPERATIONS WITH OPTIMISTIC UPDATES
             * 
             * This method demonstrates optimistic UI updates, a key pattern in modern web apps:
             * 
             * 1. 🎯 Immediately update the UI (optimistic)
             * 2. 💾 Persist data to IndexedDB 
             * 3. ✅ Confirm success or rollback on failure
             * 4. 🔄 Broadcast changes to other tabs (future feature)
             * 
             * Benefits:
             * - ⚡ Instant feedback for users
             * - 🏃 No waiting for database operations
             * - 🛡️ Graceful error handling with rollback
             * - 📱 Feels like a native app
             */
            
            /**
             * Handle task creation from form
             */
            async handleCreateTask() {
                if (this.isLoading) return;
                
                try {
                    // Get form data
                    const formData = this.getFormData();
                    if (!formData.title.trim()) {
                        this.showError('Please enter a task title');
                        return;
                    }
                    
                    this.setLoading(true);
                    
                    // Create optimistic task for immediate UI feedback
                    const optimisticTask = {
                        ...formData,
                        id: 'temp-' + Date.now(),
                        status: 'pending',
                        createdAt: new Date().toISOString(),
                        modifiedAt: new Date().toISOString(),
                        completedAt: null,
                        isOptimistic: true // Flag for UI styling
                    };
                    
                    // 1. Immediately add to UI (optimistic update)
                    this.tasks.unshift(optimisticTask);
                    this.render();
                    
                    try {
                        // 2. Persist to database
                        const savedTask = await this.database.createTask(formData);
                        
                        // 3. Replace optimistic task with real data
                        const index = this.tasks.findIndex(t => t.id === optimisticTask.id);
                        if (index !== -1) {
                            this.tasks[index] = savedTask;
                        }
                        
                        // Clear form and re-render
                        this.clearForm();
                        this.render();
                        
                        // Broadcast task creation to other tabs
                        this.syncManager.syncTaskCreate(savedTask);
                        
                        console.log('✅ Task created successfully');
                        
                    } catch (error) {
                        // 4. Rollback optimistic update on failure
                        this.tasks = this.tasks.filter(t => t.id !== optimisticTask.id);
                        this.render();
                        throw error;
                    }
                    
                } catch (error) {
                    console.error('❌ Failed to create task:', error);
                    this.showError('Failed to create task: ' + error.message);
                } finally {
                    this.setLoading(false);
                }
            }
            
            /**
             * Toggle task completion status
             */
            async toggleTaskComplete(taskId) {
                try {
                    const task = this.tasks.find(t => t.id === taskId);
                    if (!task) return;
                    
                    const newStatus = task.status === 'completed' ? 'pending' : 'completed';
                    
                    // Optimistic update
                    task.status = newStatus;
                    task.modifiedAt = new Date().toISOString();
                    if (newStatus === 'completed') {
                        task.completedAt = new Date().toISOString();
                    } else {
                        task.completedAt = null;
                    }
                    
                    this.render();
                    
                    // Persist to database
                    await this.database.updateTask(taskId, { status: newStatus });
                    
                    // Broadcast task completion to other tabs
                    this.syncManager.syncTaskComplete(taskId, newStatus === 'completed');
                    
                    console.log(`✅ Task ${newStatus}:`, task.title);
                    
                } catch (error) {
                    console.error('❌ Failed to toggle task:', error);
                    // Reload tasks to restore correct state
                    await this.loadTasks();
                    this.showError('Failed to update task');
                }
            }
            
            /**
             * Delete a task
             */
            async deleteTask(taskId) {
                if (!confirm('Are you sure you want to delete this task?')) {
                    return;
                }
                
                try {
                    // Optimistic update
                    const taskIndex = this.tasks.findIndex(t => t.id === taskId);
                    const deletedTask = this.tasks[taskIndex];
                    
                    if (taskIndex !== -1) {
                        this.tasks.splice(taskIndex, 1);
                        this.render();
                    }
                    
                    // Persist to database
                    await this.database.deleteTask(taskId);
                    
                    // Broadcast task deletion to other tabs
                    this.syncManager.syncTaskDelete(taskId);
                    
                    console.log('✅ Task deleted:', deletedTask?.title);
                    
                } catch (error) {
                    console.error('❌ Failed to delete task:', error);
                    // Reload tasks to restore correct state
                    await this.loadTasks();
                    this.showError('Failed to delete task');
                }
            }
            
            /**
             * Load all tasks from database
             */
            async loadTasks() {
                try {
                    this.setLoading(true);
                    this.tasks = await this.database.getAllTasks();
                    console.log(`📋 Loaded ${this.tasks.length} tasks`);
                } catch (error) {
                    console.error('❌ Failed to load tasks:', error);
                    this.showError('Failed to load tasks');
                    this.tasks = [];
                } finally {
                    this.setLoading(false);
                }
            }
        }
    </script>

    <script>
        /* ============================================
           🎨 UI RENDERING & INTERACTION SYSTEM
           ============================================ */
        
        // Continue TaskManager class with rendering methods
        TaskManager.prototype.render = function() {
            this.renderTasks();
            this.updateEmptyState();
            this.updateNetworkStatus();
        };
        
        /**
         * 🔍 MAJOR FUNCTION POINT #4: DYNAMIC UI RENDERING SYSTEM
         * 
         * This rendering system creates a reactive UI that automatically updates when data changes:
         * 
         * - 🎯 **Virtual DOM-like rendering** without external dependencies
         * - ⚡ **Efficient updates** that only change what's necessary
         * - 🎨 **Component-based rendering** with reusable task items
         * - 📱 **Responsive design** that adapts to different screen sizes
         * - 🔄 **Real-time updates** reflecting data changes immediately
         * 
         * Key Benefits:
         * - No framework overhead, pure JavaScript
         * - Predictable rendering cycle
         * - Easy to debug and maintain
         * - Optimized for performance
         */
        
        /**
         * Render the complete task list
         */
        TaskManager.prototype.renderTasks = function() {
            if (!this.elements.taskList) return;
            
            // Clear existing content
            this.elements.taskList.innerHTML = '';
            
            if (this.tasks.length === 0) {
                return; // Empty state will be shown separately
            }
            
            // Create document fragment for efficient DOM manipulation
            const fragment = document.createDocumentFragment();
            
            // Render each task
            this.tasks.forEach(task => {
                const taskElement = this.createTaskElement(task);
                fragment.appendChild(taskElement);
            });
            
            // Add all tasks to DOM at once
            this.elements.taskList.appendChild(fragment);
            
            console.log(`🎨 Rendered ${this.tasks.length} tasks`);
        };
        
        /**
         * Create a single task element
         */
        TaskManager.prototype.createTaskElement = function(task) {
            const taskDiv = document.createElement('div');
            taskDiv.className = `task-item fade-in ${task.status === 'completed' ? 'completed' : ''}`;
            taskDiv.dataset.taskId = task.id;
            
            // Add loading state for optimistic updates
            if (task.isOptimistic) {
                taskDiv.classList.add('loading');
            }
            
            taskDiv.innerHTML = `
                <div class="task-header">
                    <h3 class="task-title ${task.status === 'completed' ? 'completed' : ''}">
                        ${this.escapeHtml(task.title)}
                    </h3>
                    <div class="task-actions">
                        <button 
                            class="btn btn-sm btn-secondary" 
                            onclick="taskManager.toggleTaskComplete('${task.id}')"
                            title="${task.status === 'completed' ? 'Mark as pending' : 'Mark as completed'}"
                        >
                            ${task.status === 'completed' ? '↩️' : '✅'}
                        </button>
                        <button 
                            class="btn btn-sm btn-secondary" 
                            onclick="taskManager.editTask('${task.id}')"
                            title="Edit task"
                        >
                            ✏️
                        </button>
                        <button 
                            class="btn btn-sm btn-secondary" 
                            onclick="taskManager.deleteTask('${task.id}')"
                            title="Delete task"
                        >
                            🗑️
                        </button>
                    </div>
                </div>
                
                ${task.description ? `
                    <div class="task-description">
                        ${this.escapeHtml(task.description)}
                    </div>
                ` : ''}
                
                <div class="task-meta">
                    <span class="priority-badge priority-${task.priority}">
                        ${task.priority}
                    </span>
                    
                    ${this.getCategoryDisplayForTask(task)}
                    
                    ${task.dueDate ? `
                        <span title="Due date">
                            📅 ${this.formatDateTime(task.dueDate)}
                        </span>
                    ` : ''}
                    
                    <span title="Created">
                        🕐 ${this.formatRelativeTime(task.createdAt)}
                    </span>
                    
                    ${task.completedAt ? `
                        <span title="Completed">
                            ✅ ${this.formatRelativeTime(task.completedAt)}
                        </span>
                    ` : ''}
                </div>
            `;
            
            return taskDiv;
        };
        
        /**
         * Update empty state visibility
         */
        TaskManager.prototype.updateEmptyState = function() {
            if (!this.elements.emptyState) return;
            
            const hasActiveTasks = this.tasks.some(task => task.status !== 'completed');
            const shouldShowEmpty = this.tasks.length === 0 || !hasActiveTasks;
            
            if (shouldShowEmpty && this.tasks.length === 0) {
                this.elements.emptyState.style.display = 'block';
                this.elements.emptyState.innerHTML = `
                    <div style="padding: var(--space-2xl);">
                        <div style="font-size: 3rem; margin-bottom: var(--space-md);">📝</div>
                        <h3 style="color: var(--color-text); margin-bottom: var(--space-sm);">No tasks yet</h3>
                        <p style="color: var(--color-text-muted); font-size: var(--text-base);">
                            Add your first task above to get started!
                        </p>
                    </div>
                `;
            } else if (shouldShowEmpty) {
                this.elements.emptyState.style.display = 'block';
                this.elements.emptyState.innerHTML = `
                    <div style="padding: var(--space-2xl);">
                        <div style="font-size: 3rem; margin-bottom: var(--space-md);">🎉</div>
                        <h3 style="color: var(--color-text); margin-bottom: var(--space-sm);">All tasks completed!</h3>
                        <p style="color: var(--color-text-muted); font-size: var(--text-base);">
                            Great job! You've completed all your tasks.
                        </p>
                    </div>
                `;
            } else {
                this.elements.emptyState.style.display = 'none';
            }
        };
        
        /**
         * Update network status indicator
         */
        TaskManager.prototype.updateNetworkStatus = function() {
            if (!this.elements.statusDot || !this.elements.statusText) return;
            
            // Check Service Worker status
            const hasServiceWorker = 'serviceWorker' in navigator && navigator.serviceWorker.controller;
            
            if (this.isOnline) {
                this.elements.statusDot.classList.remove('offline');
                if (hasServiceWorker) {
                    this.elements.statusText.textContent = 'Online + SW';
                    this.elements.statusText.title = 'Online with Service Worker active';
                } else {
                    this.elements.statusText.textContent = 'Online';
                    this.elements.statusText.title = 'Online (Service Worker not available)';
                }
            } else {
                this.elements.statusDot.classList.add('offline');
                if (hasServiceWorker) {
                    this.elements.statusText.textContent = 'Offline + SW';
                    this.elements.statusText.title = 'Offline with Service Worker active';
                } else {
                    this.elements.statusText.textContent = 'Offline';
                    this.elements.statusText.title = 'Offline (Service Worker not available)';
                }
            }
        };
        
        /**
         * 🔍 MAJOR FUNCTION POINT #5: ADVANCED TASK OPERATIONS
         * 
         * These methods handle complex task operations including:
         * - 📝 **Inline editing** with form validation
         * - 🔄 **Status management** with optimistic updates
         * - 🎯 **Bulk operations** for productivity
         * - 📱 **Mobile-friendly interactions** with touch support
         * 
         * Features:
         * - Modal-free editing experience
         * - Keyboard shortcuts for power users
         * - Undo/redo capabilities (future enhancement)
         * - Conflict resolution for concurrent edits
         */
        
        /**
         * Edit task (inline editing)
         */
        TaskManager.prototype.editTask = function(taskId) {
            const task = this.tasks.find(t => t.id === taskId);
            if (!task) return;
            
            // Create edit form
            const editForm = this.createEditForm(task);
            
            // Replace task element with edit form
            const taskElement = document.querySelector(`[data-task-id="${taskId}"]`);
            if (taskElement) {
                const editContainer = document.createElement('div');
                editContainer.className = 'task-item fade-in';
                editContainer.appendChild(editForm);
                
                taskElement.parentNode.replaceChild(editContainer, taskElement);
                
                // Focus title input
                const titleInput = editForm.querySelector('[name="title"]');
                if (titleInput) {
                    titleInput.focus();
                    titleInput.select();
                }
            }
        };
        
        /**
         * Create inline edit form
         */
        TaskManager.prototype.createEditForm = function(task) {
            const form = document.createElement('form');
            form.className = 'task-edit-form';
            
            // Get categories for selector
            const categories = this.categoryManager.getCategoriesForSelector();
            const categoryOptions = categories.map(category => 
                `<option value="${category.id || ''}" ${task.categoryId === category.id ? 'selected' : ''}>${category.name}</option>`
            ).join('');
            
            form.innerHTML = `
                <div class="form-group">
                    <input 
                        type="text" 
                        name="title" 
                        class="form-input" 
                        value="${this.escapeHtml(task.title)}"
                        required
                        maxlength="200"
                    >
                </div>
                
                <div class="form-group">
                    <textarea 
                        name="description" 
                        class="form-input form-textarea" 
                        placeholder="Description..."
                        maxlength="1000"
                        style="min-height: 60px;"
                    >${this.escapeHtml(task.description || '')}</textarea>
                </div>
                
                <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: var(--space-sm); margin-bottom: var(--space-md);">
                    <select name="categoryId" class="form-input form-select">
                        ${categoryOptions}
                    </select>
                    
                    <select name="priority" class="form-input form-select">
                        <option value="low" ${task.priority === 'low' ? 'selected' : ''}>Low</option>
                        <option value="medium" ${task.priority === 'medium' ? 'selected' : ''}>Medium</option>
                        <option value="high" ${task.priority === 'high' ? 'selected' : ''}>High</option>
                        <option value="urgent" ${task.priority === 'urgent' ? 'selected' : ''}>Urgent</option>
                    </select>
                    
                    <input 
                        type="datetime-local" 
                        name="dueDate" 
                        class="form-input"
                        value="${task.dueDate ? new Date(task.dueDate).toISOString().slice(0, 16) : ''}"
                    >
                </div>
                
                <div style="display: flex; gap: var(--space-sm);">
                    <button type="submit" class="btn btn-primary btn-sm">Save</button>
                    <button type="button" class="btn btn-secondary btn-sm" onclick="taskManager.cancelEdit('${task.id}')">Cancel</button>
                </div>
            `;
            
            // Handle form submission
            form.addEventListener('submit', (e) => {
                e.preventDefault();
                this.saveTaskEdit(task.id, new FormData(form));
            });
            
            // Handle Escape key
            form.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    this.cancelEdit(task.id);
                }
            });
            
            return form;
        };
        
        /**
         * Save task edit
         */
        TaskManager.prototype.saveTaskEdit = async function(taskId, formData) {
            try {
                const updates = {
                    title: formData.get('title'),
                    description: formData.get('description'),
                    categoryId: formData.get('categoryId') || null,
                    priority: formData.get('priority'),
                    dueDate: formData.get('dueDate') || null
                };
                
                // Store original category for count updates
                const task = this.tasks.find(t => t.id === taskId);
                const originalCategoryId = task?.categoryId;
                
                // Optimistic update
                if (task) {
                    Object.assign(task, updates);
                    task.modifiedAt = new Date().toISOString();
                }
                
                this.render();
                
                // Persist to database
                await this.database.updateTask(taskId, updates);
                
                // Update category task counts if category changed
                if (originalCategoryId !== updates.categoryId) {
                    if (originalCategoryId) {
                        await this.categoryManager.updateCategoryTaskCount(originalCategoryId);
                    }
                    if (updates.categoryId) {
                        await this.categoryManager.updateCategoryTaskCount(updates.categoryId);
                    }
                }
                
                console.log('✅ Task updated:', updates.title);
                
            } catch (error) {
                console.error('❌ Failed to update task:', error);
                this.showError('Failed to update task: ' + error.message);
                await this.loadTasks();
                this.render();
            }
        };
        
        /**
         * Cancel task edit
         */
        TaskManager.prototype.cancelEdit = function(taskId) {
            this.render(); // Re-render to restore original task display
        };
        
        /**
         * 🔍 MAJOR FUNCTION POINT #6: UTILITY & HELPER FUNCTIONS
         * 
         * These utility functions provide essential functionality for:
         * - 🛡️ **Security** (HTML escaping, input sanitization)
         * - 📅 **Date formatting** (relative time, localization)
         * - 🎯 **Form handling** (data extraction, validation)
         * - 🎨 **UI state management** (loading states, error handling)
         * 
         * These are the building blocks that make the app robust and user-friendly.
         */
        
        /**
         * Get form data as object
         */
        TaskManager.prototype.getFormData = function() {
            return {
                title: this.elements.titleInput?.value?.trim() || '',
                description: this.elements.descriptionInput?.value?.trim() || '',
                categoryId: this.elements.categoryInput?.value || null,
                priority: this.elements.priorityInput?.value || 'medium',
                dueDate: this.elements.dueDateInput?.value || null
            };
        };
        
        /**
         * Clear the task form
         */
        TaskManager.prototype.clearForm = function() {
            if (this.elements.taskForm) {
                this.elements.taskForm.reset();
            }
        };
        
        /**
         * Set loading state
         */
        TaskManager.prototype.setLoading = function(loading) {
            this.isLoading = loading;
            
            if (this.elements.taskForm) {
                if (loading) {
                    this.elements.taskForm.classList.add('loading');
                } else {
                    this.elements.taskForm.classList.remove('loading');
                }
            }
        };
        
            /**
             * Handle network status change with Service Worker integration
             */
            TaskManager.prototype.handleNetworkChange = function(isOnline) {
                this.isOnline = isOnline;
                this.updateNetworkStatus();
                
                console.log(`📡 Network status: ${isOnline ? 'Online' : 'Offline'}`);
                
                if (isOnline) {
                    console.log('🔄 Connection restored - requesting background sync');
                    // Trigger background sync when coming back online
                    this.requestSync();
                } else {
                    console.log('📴 Working offline - operations will be queued');
                }
            };
            
            /**
             * Request immediate sync with Service Worker
             */
            TaskManager.prototype.requestSync = async function() {
                try {
                    if ('serviceWorker' in navigator && navigator.serviceWorker.ready) {
                        const registration = await navigator.serviceWorker.ready;
                        
                        if (registration.active) {
                            registration.active.postMessage({
                                type: 'REQUEST_SYNC'
                            });
                            console.log('🔄 Sync requested via Service Worker');
                        } else {
                            console.log('⚠️ Service Worker not active - sync skipped');
                        }
                    } else {
                        console.log('⚠️ Service Worker not available - sync skipped');
                    }
                } catch (error) {
                    console.error('❌ Failed to request sync:', error);
                }
            };
            
            /**
             * Enhanced task creation with Service Worker integration
             */
            TaskManager.prototype.handleCreateTask = async function() {
                if (this.isLoading) return;
                
                try {
                    // Get form data
                    const formData = this.getFormData();
                    if (!formData.title.trim()) {
                        this.showError('Please enter a task title');
                        return;
                    }
                    
                    this.setLoading(true);
                    
                    // Create optimistic task for immediate UI feedback
                    const optimisticTask = {
                        ...formData,
                        id: 'temp-' + Date.now(),
                        status: 'pending',
                        createdAt: new Date().toISOString(),
                        modifiedAt: new Date().toISOString(),
                        completedAt: null,
                        isOptimistic: true // Flag for UI styling
                    };
                    
                    // 1. Immediately add to UI (optimistic update)
                    this.tasks.unshift(optimisticTask);
                    this.render();
                    
                    try {
                        // 2. Persist to database
                        const savedTask = await this.database.createTask(formData);
                        
                        // 3. Replace optimistic task with real data
                        const index = this.tasks.findIndex(t => t.id === optimisticTask.id);
                        if (index !== -1) {
                            this.tasks[index] = savedTask;
                        }
                        
                        // 4. Cache task data for offline access
                        await safeCacheTaskData(savedTask);
                        
                        // 5. Queue for background sync (online or offline)
                        await this.queueForBackgroundSync({
                            type: 'CREATE_TASK',
                            data: { taskData: savedTask },
                            timestamp: Date.now()
                        });
                        
                        // 6. Update category task count if task has category
                        if (savedTask.categoryId) {
                            await this.categoryManager.updateCategoryTaskCount(savedTask.categoryId);
                        }
                        
                        // Broadcast to other tabs
                        this.syncManager.broadcast({
                            type: 'TASK_CREATED',
                            data: savedTask
                        });
                        
                        // Clear form and re-render
                        this.clearForm();
                        this.render();
                        
                        console.log('✅ Task created successfully');
                        
                    } catch (error) {
                        // 4. Rollback optimistic update on failure
                        this.tasks = this.tasks.filter(t => t.id !== optimisticTask.id);
                        this.render();
                        throw error;
                    }
                    
                } catch (error) {
                    console.error('❌ Failed to create task:', error);
                    this.showError('Failed to create task: ' + error.message);
                } finally {
                    this.setLoading(false);
                }
            };
            
            /**
             * Enhanced task toggle with Service Worker integration
             */
            TaskManager.prototype.toggleTaskComplete = async function(taskId) {
                try {
                    const task = this.tasks.find(t => t.id === taskId);
                    if (!task) return;
                    
                    const newStatus = task.status === 'completed' ? 'pending' : 'completed';
                    const previousStatus = task.status;
                    
                    // Optimistic update
                    task.status = newStatus;
                    task.modifiedAt = new Date().toISOString();
                    if (newStatus === 'completed') {
                        task.completedAt = new Date().toISOString();
                    } else {
                        task.completedAt = null;
                    }
                    
                    this.render();
                    
                    try {
                        // Persist to database
                        await this.database.updateTask(taskId, { status: newStatus });
                        
                        // Cache updated task
                        await safeCacheTaskData(task);
                        
                        // Queue for background sync
                        await this.queueForBackgroundSync({
                            type: 'UPDATE_TASK',
                            data: { taskId: taskId, updates: { status: newStatus } },
                            timestamp: Date.now()
                        });
                        
                        // Broadcast to other tabs
                        this.syncManager.broadcast({
                            type: 'TASK_COMPLETED',
                            data: { id: taskId, completed: newStatus === 'completed' }
                        });
                        
                        console.log(`✅ Task ${newStatus}:`, task.title);
                        
                    } catch (error) {
                        // Rollback on failure
                        task.status = previousStatus;
                        task.modifiedAt = new Date().toISOString();
                        if (previousStatus === 'completed') {
                            task.completedAt = new Date().toISOString();
                        } else {
                            task.completedAt = null;
                        }
                        this.render();
                        throw error;
                    }
                    
                } catch (error) {
                    console.error('❌ Failed to toggle task:', error);
                    // Reload tasks to restore correct state
                    await this.loadTasks();
                    this.showError('Failed to update task');
                }
            };
            
            /**
             * Enhanced task deletion with Service Worker integration
             */
            TaskManager.prototype.deleteTask = async function(taskId) {
                if (!confirm('Are you sure you want to delete this task?')) {
                    return;
                }
                
                try {
                    // Store task for potential rollback
                    const taskIndex = this.tasks.findIndex(t => t.id === taskId);
                    const deletedTask = this.tasks[taskIndex];
                    
                    if (taskIndex === -1) return;
                    
                    // Optimistic update
                    this.tasks.splice(taskIndex, 1);
                    this.render();
                    
                    try {
                        // Persist to database
                        await this.database.deleteTask(taskId);
                        
                        // Update category task count if task had category
                        if (deletedTask.categoryId) {
                            await this.categoryManager.updateCategoryTaskCount(deletedTask.categoryId);
                        }
                        
                        // Queue for background sync
                        await this.queueForBackgroundSync({
                            type: 'DELETE_TASK',
                            data: { taskId: taskId },
                            timestamp: Date.now()
                        });
                        
                        // Broadcast to other tabs
                        this.syncManager.broadcast({
                            type: 'TASK_DELETED',
                            data: { id: taskId }
                        });
                        
                        console.log('✅ Task deleted:', deletedTask?.title);
                        
                    } catch (error) {
                        // Rollback on failure
                        this.tasks.splice(taskIndex, 0, deletedTask);
                        this.render();
                        throw error;
                    }
                    
                } catch (error) {
                    console.error('❌ Failed to delete task:', error);
                    // Reload tasks to restore correct state
                    await this.loadTasks();
                    this.showError('Failed to delete task');
                }
            };
            
            /**
             * Enhanced task edit saving with Service Worker integration
             */
            TaskManager.prototype.saveTaskEdit = async function(taskId, formData) {
                try {
                    const updates = {
                        title: formData.get('title'),
                        description: formData.get('description'),
                        priority: formData.get('priority'),
                        dueDate: formData.get('dueDate') || null
                    };
                    
                    // Store previous state for rollback
                    const task = this.tasks.find(t => t.id === taskId);
                    const previousState = { ...task };
                    
                    // Optimistic update
                    if (task) {
                        Object.assign(task, updates);
                        task.modifiedAt = new Date().toISOString();
                    }
                    
                    this.render();
                    
                    try {
                        // Persist to database
                        await this.database.updateTask(taskId, updates);
                        
                        // Cache updated task
                        await safeCacheTaskData(task);
                        
                        // Queue for background sync
                        await this.queueForBackgroundSync({
                            type: 'UPDATE_TASK',
                            data: { taskId: taskId, updates: updates },
                            timestamp: Date.now()
                        });
                        
                        // Broadcast to other tabs
                        this.syncManager.broadcast({
                            type: 'TASK_UPDATED',
                            data: task
                        });
                        
                        console.log('✅ Task updated:', updates.title);
                        
                    } catch (error) {
                        // Rollback on failure
                        if (task) {
                            Object.assign(task, previousState);
                        }
                        this.render();
                        throw error;
                    }
                    
                } catch (error) {
                    console.error('❌ Failed to update task:', error);
                    this.showError('Failed to update task: ' + error.message);
                    await this.loadTasks();
                    this.render();
                }
            };        /**
         * Setup network detection
         */
        TaskManager.prototype.setupNetworkDetection = function() {
            this.isOnline = navigator.onLine;
            this.updateNetworkStatus();
        };
        
        /**
         * Setup cross-tab synchronization
         */
        TaskManager.prototype.setupCrossTabSync = function() {
            // Register sync callbacks for different task operations
            this.syncManager.onSync('TASK_CREATED', (data, tabId) => {
                console.log(`🔄 Task created in tab ${tabId}:`, data);
                this.handleRemoteTaskCreate(data);
            });
            
            this.syncManager.onSync('TASK_UPDATED', (data, tabId) => {
                console.log(`🔄 Task updated in tab ${tabId}:`, data);
                this.handleRemoteTaskUpdate(data);
            });
            
            this.syncManager.onSync('TASK_DELETED', (data, tabId) => {
                console.log(`🔄 Task deleted in tab ${tabId}:`, data);
                this.handleRemoteTaskDelete(data);
            });
            
            this.syncManager.onSync('TASK_COMPLETED', (data, tabId) => {
                console.log(`🔄 Task completed in tab ${tabId}:`, data);
                this.handleRemoteTaskComplete(data);
            });
            
            this.syncManager.onSync('TAB_CONNECTED', (data, tabId) => {
                console.log(`🔗 Tab connected: ${tabId}`);
                this.updateSyncStatus('multi-tab');
                this.showSyncStatus('Tab connected', 'info');
            });
            
            this.syncManager.onSync('TAB_DISCONNECTED', (data, tabId) => {
                console.log(`🔌 Tab disconnected: ${tabId}`);
                this.updateSyncStatus('ready');
                this.showSyncStatus('Tab disconnected', 'info');
            });
            
            // Set initial sync status
            if (this.syncManager.isSupported) {
                this.updateSyncStatus('ready');
            } else {
                this.updateSyncStatus('disabled', 'Not Supported');
            }
            
            console.log('✅ Cross-tab sync callbacks registered');
        };
        
        /**
         * Setup background sync integration for offline support
         */
        TaskManager.prototype.setupBackgroundSyncIntegration = function() {
            if (!this.backgroundSyncManager) {
                console.warn('⚠️ Background sync manager not available');
                return;
            }
            
            console.log('🔄 Setting up background sync integration...');
            
            // Listen for service worker messages
            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.addEventListener('message', (event) => {
                    const { type, data } = event.data;
                    
                    switch (type) {
                        case 'BACKGROUND_SYNC_COMPLETE':
                            this.handleBackgroundSyncComplete(data);
                            break;
                        case 'OPERATION_SYNCED':
                            this.handleOperationSynced(data);
                            break;
                        case 'BACKGROUND_SYNC_ERROR':
                            this.handleBackgroundSyncError(data);
                            break;
                    }
                });
            }
            
            // Update sync status indicator
            this.updateSyncStatus('ready');
            this.showSyncStatus('Background sync ready', 'success');
            
            console.log('✅ Background sync integration ready');
        };
        
        /**
         * Handle background sync completion notification
         */
        TaskManager.prototype.handleBackgroundSyncComplete = function(data) {
            const { total, successful, failed, timestamp } = data;
            
            console.log(`✅ Background sync completed: ${successful}/${total} operations successful`);
            
            // Update sync status
            if (failed > 0) {
                this.updateSyncStatus('error');
                this.showSyncStatus(`Sync completed with ${failed} errors`, 'error');
            } else {
                this.updateSyncStatus('synced');
                this.showSyncStatus(`${successful} operations synced successfully`, 'success');
            }
            
            // Refresh tasks if any operations were processed
            if (successful > 0) {
                this.loadTasks().then(() => this.render());
            }
        };
        
        /**
         * Handle individual operation sync notification
         */
        TaskManager.prototype.handleOperationSynced = function(data) {
            const { operationId, success, error } = data;
            
            if (success) {
                console.log(`✅ Operation ${operationId} synced successfully`);
            } else {
                console.error(`❌ Operation ${operationId} failed to sync:`, error);
                this.showSyncStatus(`Sync failed: ${error}`, 'error');
            }
        };
        
        /**
         * Handle background sync system error
         */
        TaskManager.prototype.handleBackgroundSyncError = function(data) {
            const { error, timestamp } = data;
            
            console.error('❌ Background sync system error:', error);
            this.updateSyncStatus('error');
            this.showSyncStatus('Background sync error occurred', 'error');
        };
        
        /**
         * Queue operation for background sync
         */
        TaskManager.prototype.queueForBackgroundSync = async function(operation) {
            if (!this.backgroundSyncManager) {
                console.warn('⚠️ Background sync not available');
                return false;
            }
            
            try {
                const operationId = await this.backgroundSyncManager.queueOperation(operation);
                console.log(`📤 Queued operation for background sync: ${operationId}`);
                
                // Update sync status to show pending
                this.updateSyncStatus('syncing');
                
                return operationId;
            } catch (error) {
                console.error('❌ Failed to queue operation for background sync:', error);
                return false;
            }
        };
        
        /**
         * Get background sync statistics
         */
        TaskManager.prototype.getBackgroundSyncStats = function() {
            if (!this.backgroundSyncManager) {
                return null;
            }
            
            return this.backgroundSyncManager.getStats();
        };
        
        /**
         * Handle task creation from another tab
         */
        TaskManager.prototype.handleRemoteTaskCreate = function(task) {
            // Check if task already exists (conflict resolution)
            const existingIndex = this.tasks.findIndex(t => t.id === task.id);
            if (existingIndex === -1) {
                // Add new task to local array
                this.tasks.unshift(task);
                this.render();
                this.showSyncStatus('New task synced from another tab', 'success');
            }
        };
        
        /**
         * Handle task update from another tab
         */
        TaskManager.prototype.handleRemoteTaskUpdate = function(task) {
            const index = this.tasks.findIndex(t => t.id === task.id);
            if (index !== -1) {
                // Conflict resolution: use timestamp to determine latest version
                const localTask = this.tasks[index];
                if (!localTask.lastModified || task.lastModified > localTask.lastModified) {
                    this.tasks[index] = task;
                    this.render();
                    this.showSyncStatus('Task updated from another tab', 'success');
                }
            } else {
                // Task doesn't exist locally, add it
                this.tasks.unshift(task);
                this.render();
                this.showSyncStatus('New task synced from another tab', 'success');
            }
        };
        
        /**
         * Handle task deletion from another tab
         */
        TaskManager.prototype.handleRemoteTaskDelete = function(data) {
            const index = this.tasks.findIndex(t => t.id === data.id);
            if (index !== -1) {
                this.tasks.splice(index, 1);
                this.render();
                this.showSyncStatus('Task deleted from another tab', 'success');
            }
        };
        
        /**
         * Handle task completion from another tab
         */
        TaskManager.prototype.handleRemoteTaskComplete = function(data) {
            const index = this.tasks.findIndex(t => t.id === data.id);
            if (index !== -1) {
                this.tasks[index].status = data.completed ? 'completed' : 'pending';
                this.tasks[index].completedAt = data.completed ? new Date().toISOString() : null;
                this.tasks[index].lastModified = Date.now();
                this.render();
                this.showSyncStatus(`Task ${data.completed ? 'completed' : 'reopened'} from another tab`, 'success');
            }
        };
        
        /**
         * Show sync status message
         */
        TaskManager.prototype.showSyncStatus = function(message, type = 'info') {
            // Create subtle notification for sync events
            const notification = document.createElement('div');
            notification.className = `sync-notification ${type}`;
            notification.style.cssText = `
                position: fixed;
                bottom: 20px;
                right: 20px;
                background: ${type === 'success' ? 'var(--color-success)' : 
                           type === 'error' ? 'var(--color-danger)' : 'var(--color-primary)'};
                color: white;
                padding: var(--space-sm) var(--space-md);
                border-radius: var(--radius-md);
                box-shadow: var(--shadow-md);
                z-index: 1000;
                font-size: 0.875rem;
                opacity: 0;
                transform: translateY(20px);
                transition: all 0.3s ease-out;
                max-width: 250px;
            `;
            
            notification.textContent = message;
            document.body.appendChild(notification);
            
            // Animate in
            requestAnimationFrame(() => {
                notification.style.opacity = '1';
                notification.style.transform = 'translateY(0)';
            });
            
            // Auto remove after 3 seconds
            setTimeout(() => {
                notification.style.opacity = '0';
                notification.style.transform = 'translateY(20px)';
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 300);
            }, 3000);
        };
        
        /**
         * Update sync status indicator in header
         */
        TaskManager.prototype.updateSyncStatus = function(status, text) {
            if (!this.elements.syncDot || !this.elements.syncText) return;
            
            // Remove all status classes
            this.elements.syncDot.className = 'sync-dot';
            
            // Add appropriate status class
            switch (status) {
                case 'ready':
                    this.elements.syncText.textContent = text || 'Sync Ready';
                    break;
                case 'syncing':
                    this.elements.syncDot.classList.add('syncing');
                    this.elements.syncText.textContent = text || 'Syncing...';
                    break;
                case 'multi-tab':
                    this.elements.syncDot.classList.add('multi-tab');
                    this.elements.syncText.textContent = text || 'Multi-Tab Active';
                    break;
                case 'error':
                    this.elements.syncDot.classList.add('error');
                    this.elements.syncText.textContent = text || 'Sync Error';
                    break;
                case 'disabled':
                    this.elements.syncText.textContent = text || 'Sync Disabled';
                    this.elements.syncDot.style.opacity = '0.5';
                    break;
                default:
                    this.elements.syncText.textContent = text || 'Sync Ready';
            }
        };
        
        /**
         * Show error message to user
         */
        TaskManager.prototype.showError = function(message) {
            // Create toast notification
            const toast = document.createElement('div');
            toast.className = 'toast error';
            toast.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: var(--color-danger);
                color: white;
                padding: var(--space-md);
                border-radius: var(--radius-md);
                box-shadow: var(--shadow-lg);
                z-index: 1000;
                max-width: 300px;
                animation: slideIn 0.3s ease-out;
            `;
            
            toast.textContent = message;
            document.body.appendChild(toast);
            
            // Auto remove after 5 seconds
            setTimeout(() => {
                if (toast.parentNode) {
                    toast.style.animation = 'slideOut 0.3s ease-in';
                    setTimeout(() => {
                        if (toast.parentNode) {
                            toast.parentNode.removeChild(toast);
                        }
                    }, 300);
                }
            }, 5000);
            
            // Add animation styles if not present
            if (!document.getElementById('toast-styles')) {
                const style = document.createElement('style');
                style.id = 'toast-styles';
                style.textContent = `
                    @keyframes slideIn {
                        from { transform: translateX(100%); opacity: 0; }
                        to { transform: translateX(0); opacity: 1; }
                    }
                    @keyframes slideOut {
                        from { transform: translateX(0); opacity: 1; }
                        to { transform: translateX(100%); opacity: 0; }
                    }
                `;
                document.head.appendChild(style);
            }
        };
        
        /**
         * Escape HTML to prevent XSS
         */
        TaskManager.prototype.escapeHtml = function(text) {
            const div = document.createElement('div');
            div.textContent = text || '';
            return div.innerHTML;
        };
        
        /**
         * Helper functions for Service Worker features
         * These functions safely handle cases where Service Worker is not available
         */
        
        /**
         * Safely cache task data if Service Worker is available
         */
        async function safeCacheTaskData(taskData) {
            try {
                if (typeof cacheTaskData === 'function') {
                    await cacheTaskData(taskData);
                    console.log('💾 Task data cached');
                } else {
                    console.log('⚠️ Cache function not available - skipping cache');
                }
            } catch (error) {
                console.warn('⚠️ Failed to cache task data:', error.message);
            }
        }
        
        /**
         * Safely request background sync if Service Worker is available
         */
        async function safeRequestBackgroundSync(operation) {
            try {
                if (typeof requestBackgroundSync === 'function') {
                    await requestBackgroundSync(operation);
                    console.log('🔄 Background sync requested');
                } else {
                    console.log('⚠️ Background sync not available - operation will sync when online');
                }
            } catch (error) {
                console.warn('⚠️ Failed to request background sync:', error.message);
            }
        }
        
        /**
         * Format date/time for display
         */
        TaskManager.prototype.formatDateTime = function(dateString) {
            try {
                const date = new Date(dateString);
                const now = new Date();
                const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
                const taskDate = new Date(date.getFullYear(), date.getMonth(), date.getDate());
                
                const time = date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                
                if (taskDate.getTime() === today.getTime()) {
                    return `Today ${time}`;
                } else if (taskDate.getTime() === today.getTime() + 86400000) {
                    return `Tomorrow ${time}`;
                } else if (taskDate.getTime() === today.getTime() - 86400000) {
                    return `Yesterday ${time}`;
                } else {
                    return date.toLocaleDateString() + ' ' + time;
                }
            } catch (error) {
                return 'Invalid date';
            }
        };
        
        /**
         * Format relative time (e.g., "2 hours ago")
         */
        TaskManager.prototype.formatRelativeTime = function(dateString) {
            try {
                const date = new Date(dateString);
                const now = new Date();
                const diffMs = now - date;
                const diffMins = Math.floor(diffMs / 60000);
                const diffHours = Math.floor(diffMins / 60);
                const diffDays = Math.floor(diffHours / 24);
                
                if (diffMins < 1) return 'Just now';
                if (diffMins < 60) return `${diffMins} min ago`;
                if (diffHours < 24) return `${diffHours}h ago`;
                if (diffDays < 7) return `${diffDays}d ago`;
                
                return date.toLocaleDateString();
            } catch (error) {
                return 'Unknown';
            }
        };
        
        /* ============================================
           � BACKGROUND SYNC ARCHITECTURE (Phase 2)
           ============================================ */
        
        /**
         * 🔍 MAJOR FUNCTION POINT #6: BACKGROUND SYNC MANAGER
         * 
         * This is a comprehensive Background Sync implementation that provides:
         * - 🚀 **Queue-based sync operations** for reliable offline support
         * - 🔄 **Automatic retry with exponential backoff** for failed operations
         * - 🎯 **Conflict resolution** for concurrent edits across devices
         * - 📡 **Real-time sync** with WebSocket fallback mechanisms
         * - 🛡️ **Data integrity** with versioning and checksums
         * 
         * Architecture Components:
         * - BackgroundSyncManager: Core orchestration and queue management
         * - SyncQueue: Persistent operation storage with IndexedDB
         * - ConflictResolver: Multi-device conflict detection and resolution
         * - RealtimeSyncLayer: WebSocket integration with fallback strategies
         */

        /* ============================================
           📂 CATEGORY MANAGEMENT METHODS
           ============================================ */

        /**
         * Initialize category selector in task form
         */
        TaskManager.prototype.initializeCategorySelector = async function() {
            try {
                const categorySelect = document.getElementById('task-category');
                if (!categorySelect) return;
                
                const categories = this.categoryManager.getCategoriesForSelector();
                categorySelect.innerHTML = '';
                
                categories.forEach(category => {
                    const option = document.createElement('option');
                    option.value = category.id || '';
                    option.textContent = category.name;
                    categorySelect.appendChild(option);
                });
                
                // Also update filter options
                this.populateCategoryFilter();
            } catch (error) {
                console.error('❌ Error initializing category selector:', error);
            }
        };

        /**
         * Open category management modal
         */
        TaskManager.prototype.openCategoryManager = function() {
            const modal = document.getElementById('category-modal');
            if (!modal) return;
            
            modal.style.display = 'flex';
            this.initializeCategoryModal();
        };

        /**
         * Close category management modal
         */
        TaskManager.prototype.closeCategoryManager = function() {
            const modal = document.getElementById('category-modal');
            if (!modal) return;
            
            modal.style.display = 'none';
            this.clearCategoryForm();
        };

        /**
         * Initialize category modal components
         */
        TaskManager.prototype.initializeCategoryModal = function() {
            this.setupColorPicker();
            this.setupIconPicker();
            this.setupCategoryForm();
            this.renderCategoryList();
        };

        /**
         * Setup color picker
         */
        TaskManager.prototype.setupColorPicker = function() {
            const colorPicker = document.getElementById('category-color-picker');
            const colorInput = document.getElementById('category-color');
            if (!colorPicker || !colorInput) return;
            
            const colors = this.categoryManager.getColorPalette();
            colorPicker.innerHTML = '';
            
            colors.forEach(color => {
                const colorOption = document.createElement('div');
                colorOption.className = 'color-option';
                colorOption.style.backgroundColor = color.value;
                colorOption.title = color.name;
                colorOption.addEventListener('click', () => {
                    // Remove previous selection
                    colorPicker.querySelectorAll('.color-option').forEach(opt => {
                        opt.classList.remove('selected');
                    });
                    // Select current
                    colorOption.classList.add('selected');
                    colorInput.value = color.value;
                });
                colorPicker.appendChild(colorOption);
            });
            
            // Select first color by default
            const firstColor = colorPicker.querySelector('.color-option');
            if (firstColor) {
                firstColor.classList.add('selected');
                colorInput.value = colors[0].value;
            }
        };

        /**
         * Setup icon picker
         */
        TaskManager.prototype.setupIconPicker = function() {
            const iconPicker = document.getElementById('category-icon-picker');
            const iconInput = document.getElementById('category-icon');
            if (!iconPicker || !iconInput) return;
            
            const icons = this.categoryManager.getIconPalette();
            iconPicker.innerHTML = '';
            
            icons.forEach(icon => {
                const iconOption = document.createElement('div');
                iconOption.className = 'icon-option';
                iconOption.textContent = icon.value;
                iconOption.title = icon.name;
                iconOption.addEventListener('click', () => {
                    // Remove previous selection
                    iconPicker.querySelectorAll('.icon-option').forEach(opt => {
                        opt.classList.remove('selected');
                    });
                    // Select current
                    iconOption.classList.add('selected');
                    iconInput.value = icon.value;
                });
                iconPicker.appendChild(iconOption);
            });
            
            // Select first icon by default
            const firstIcon = iconPicker.querySelector('.icon-option');
            if (firstIcon) {
                firstIcon.classList.add('selected');
                iconInput.value = icons[0].value;
            }
        };

        /**
         * Setup category form event handling
         */
        TaskManager.prototype.setupCategoryForm = function() {
            const form = document.getElementById('category-form');
            if (!form) return;
            
            // Remove existing listeners
            const newForm = form.cloneNode(true);
            form.parentNode.replaceChild(newForm, form);
            
            // Add fresh listener
            newForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                await this.handleCreateCategory();
            });
        };

        /**
         * Handle category creation
         */
        TaskManager.prototype.handleCreateCategory = async function() {
            try {
                const formData = this.getCategoryFormData();
                
                if (!formData.name.trim()) {
                    this.showError('Please enter a category name');
                    return;
                }
                
                await this.categoryManager.createCategory(formData);
                
                this.clearCategoryForm();
                this.renderCategoryList();
                this.initializeCategorySelector();
                
                this.showSuccess('Category created successfully!');
            } catch (error) {
                console.error('❌ Error creating category:', error);
                this.showError(error.message || 'Failed to create category');
            }
        };

        /**
         * Get category form data
         */
        TaskManager.prototype.getCategoryFormData = function() {
            return {
                name: document.getElementById('category-name')?.value || '',
                description: document.getElementById('category-description')?.value || '',
                color: document.getElementById('category-color')?.value || '#3b82f6',
                icon: document.getElementById('category-icon')?.value || '📋'
            };
        };

        /**
         * Clear category form
         */
        TaskManager.prototype.clearCategoryForm = function() {
            const form = document.getElementById('category-form');
            if (!form) return;
            
            form.reset();
            
            // Reset color picker
            const colorPicker = document.getElementById('category-color-picker');
            if (colorPicker) {
                colorPicker.querySelectorAll('.color-option').forEach(opt => {
                    opt.classList.remove('selected');
                });
                const firstColor = colorPicker.querySelector('.color-option');
                if (firstColor) {
                    firstColor.classList.add('selected');
                    document.getElementById('category-color').value = this.categoryManager.getColorPalette()[0].value;
                }
            }
            
            // Reset icon picker
            const iconPicker = document.getElementById('category-icon-picker');
            if (iconPicker) {
                iconPicker.querySelectorAll('.icon-option').forEach(opt => {
                    opt.classList.remove('selected');
                });
                const firstIcon = iconPicker.querySelector('.icon-option');
                if (firstIcon) {
                    firstIcon.classList.add('selected');
                    document.getElementById('category-icon').value = this.categoryManager.getIconPalette()[0].value;
                }
            }
        };

        /**
         * Render category list
         */
        TaskManager.prototype.renderCategoryList = async function() {
            try {
                const categoryList = document.getElementById('category-list');
                if (!categoryList) return;
                
                const categories = await this.categoryManager.getCategoriesWithStats();
                categoryList.innerHTML = '';
                
                if (categories.length === 0) {
                    categoryList.innerHTML = '<p style="text-align: center; color: var(--color-text-muted);">No categories created yet.</p>';
                    return;
                }
                
                categories.forEach(category => {
                    const categoryElement = this.createCategoryElement(category);
                    categoryList.appendChild(categoryElement);
                });
            } catch (error) {
                console.error('❌ Error rendering category list:', error);
            }
        };

        /**
         * Create category list element
         */
        TaskManager.prototype.createCategoryElement = function(category) {
            const categoryDiv = document.createElement('div');
            categoryDiv.className = 'category-item';
            
            categoryDiv.innerHTML = `
                <div class="category-info">
                    <span class="category-icon">${category.icon}</span>
                    <div class="category-color" style="background-color: ${category.color}"></div>
                    <div class="category-details">
                        <h4 class="category-name">${this.escapeHtml(category.name)}</h4>
                        ${category.description ? `<p class="category-description">${this.escapeHtml(category.description)}</p>` : ''}
                    </div>
                    <div class="category-stats">
                        ${category.taskCount} tasks
                        ${category.taskCount > 0 ? `(${category.completionRate}% complete)` : ''}
                    </div>
                </div>
                <div class="category-actions">
                    <button type="button" class="btn-icon btn-edit" onclick="taskManager.editCategory('${category.id}')" title="Edit Category">
                        ✏️
                    </button>
                    <button type="button" class="btn-icon btn-delete" onclick="taskManager.deleteCategory('${category.id}')" title="Delete Category">
                        🗑️
                    </button>
                </div>
            `;
            
            return categoryDiv;
        };

        /**
         * Edit category
         */
        TaskManager.prototype.editCategory = function(categoryId) {
            const category = this.categoryManager.getCategory(categoryId);
            if (!category) return;
            
            // Fill form with existing data
            document.getElementById('category-name').value = category.name;
            document.getElementById('category-description').value = category.description || '';
            
            // Update color picker
            const colorPicker = document.getElementById('category-color-picker');
            if (colorPicker) {
                colorPicker.querySelectorAll('.color-option').forEach(opt => {
                    opt.classList.remove('selected');
                    if (opt.style.backgroundColor === category.color) {
                        opt.classList.add('selected');
                    }
                });
                document.getElementById('category-color').value = category.color;
            }
            
            // Update icon picker
            const iconPicker = document.getElementById('category-icon-picker');
            if (iconPicker) {
                iconPicker.querySelectorAll('.icon-option').forEach(opt => {
                    opt.classList.remove('selected');
                    if (opt.textContent === category.icon) {
                        opt.classList.add('selected');
                    }
                });
                document.getElementById('category-icon').value = category.icon;
            }
            
            // Change form to edit mode
            const form = document.getElementById('category-form');
            const submitBtn = form.querySelector('button[type="submit"]');
            submitBtn.textContent = 'Update Category';
            form.dataset.editId = categoryId;
        };

        /**
         * Delete category
         */
        TaskManager.prototype.deleteCategory = async function(categoryId) {
            try {
                const category = this.categoryManager.getCategory(categoryId);
                if (!category) return;
                
                if (!confirm(`Are you sure you want to delete the category "${category.name}"?`)) {
                    return;
                }
                
                await this.categoryManager.deleteCategory(categoryId);
                
                this.renderCategoryList();
                this.initializeCategorySelector();
                
                this.showSuccess('Category deleted successfully!');
            } catch (error) {
                console.error('❌ Error deleting category:', error);
                this.showError(error.message || 'Failed to delete category');
            }
        };

        /**
         * Escape HTML to prevent XSS
         */
        TaskManager.prototype.escapeHtml = function(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        };

        /**
         * Get category display for task
         */
        TaskManager.prototype.getCategoryDisplayForTask = function(task) {
            if (!task.categoryId) return '';
            
            const category = this.categoryManager.getCategory(task.categoryId);
            if (!category) return '';
            
            return `
                <span class="task-category-tag" style="background-color: ${category.color};" title="Category: ${category.name}">
                    ${category.icon} ${this.escapeHtml(category.name)}
                </span>
            `;
        };

        /* ============================================
           📊 FILTERING AND SEARCH FUNCTIONALITY
           ============================================ */

        /**
         * Initialize filters
         */
        TaskManager.prototype.initializeFilters = function() {
            this.currentFilters = {
                category: '',
                status: '',
                priority: ''
            };
            
            this.setupFilterEventListeners();
            this.populateFilterOptions();
        };

        /**
         * Setup filter event listeners
         */
        TaskManager.prototype.setupFilterEventListeners = function() {
            const categoryFilter = document.getElementById('filter-category');
            const statusFilter = document.getElementById('filter-status');
            const priorityFilter = document.getElementById('filter-priority');
            
            if (categoryFilter) {
                categoryFilter.addEventListener('change', (e) => {
                    this.currentFilters.category = e.target.value;
                    this.applyFilters();
                });
            }
            
            if (statusFilter) {
                statusFilter.addEventListener('change', (e) => {
                    this.currentFilters.status = e.target.value;
                    this.applyFilters();
                });
            }
            
            if (priorityFilter) {
                priorityFilter.addEventListener('change', (e) => {
                    this.currentFilters.priority = e.target.value;
                    this.applyFilters();
                });
            }
        };

        /**
         * Populate filter options
         */
        TaskManager.prototype.populateFilterOptions = function() {
            this.populateCategoryFilter();
        };

        /**
         * Populate category filter options
         */
        TaskManager.prototype.populateCategoryFilter = function() {
            const categoryFilter = document.getElementById('filter-category');
            if (!categoryFilter) return;
            
            const categories = this.categoryManager.getAllCategories();
            
            // Keep "All Categories" option and add categories
            categoryFilter.innerHTML = '<option value="">All Categories</option>';
            
            categories.forEach(category => {
                const option = document.createElement('option');
                option.value = category.id;
                option.textContent = `${category.icon} ${category.name}`;
                categoryFilter.appendChild(option);
            });
        };

        /**
         * Apply current filters to task list
         */
        TaskManager.prototype.applyFilters = function() {
            const filteredTasks = this.getFilteredTasks();
            this.renderFilteredTasks(filteredTasks);
            this.updateFilteredEmptyState(filteredTasks.length);
        };

        /**
         * Get filtered tasks based on current filters
         */
        TaskManager.prototype.getFilteredTasks = function() {
            let filteredTasks = [...this.tasks];
            
            // Apply category filter
            if (this.currentFilters.category) {
                filteredTasks = filteredTasks.filter(task => 
                    task.categoryId === this.currentFilters.category
                );
            }
            
            // Apply status filter
            if (this.currentFilters.status) {
                filteredTasks = filteredTasks.filter(task => 
                    task.status === this.currentFilters.status
                );
            }
            
            // Apply priority filter
            if (this.currentFilters.priority) {
                filteredTasks = filteredTasks.filter(task => 
                    task.priority === this.currentFilters.priority
                );
            }
            
            return filteredTasks;
        };

        /**
         * Render filtered tasks
         */
        TaskManager.prototype.renderFilteredTasks = function(filteredTasks) {
            if (!this.elements.taskList) return;
            
            // Clear existing content
            this.elements.taskList.innerHTML = '';
            
            if (filteredTasks.length === 0) {
                return; // Empty state will be shown separately
            }
            
            // Create document fragment for efficient DOM manipulation
            const fragment = document.createDocumentFragment();
            
            // Render each filtered task
            filteredTasks.forEach(task => {
                const taskElement = this.createTaskElement(task);
                fragment.appendChild(taskElement);
            });
            
            // Add to DOM
            this.elements.taskList.appendChild(fragment);
            
            console.log(`🎨 Rendered ${filteredTasks.length} filtered tasks`);
        };

        /**
         * Update empty state for filtered results
         */
        TaskManager.prototype.updateFilteredEmptyState = function(filteredCount) {
            if (!this.elements.emptyState) return;
            
            if (filteredCount === 0) {
                if (this.hasActiveFilters()) {
                    this.elements.emptyState.innerHTML = `
                        <p style="color: var(--color-text-muted); font-size: var(--text-lg);">
                            🔍 No tasks match the current filters.
                        </p>
                        <button class="btn btn-secondary" onclick="taskManager.clearFilters()">
                            Clear Filters
                        </button>
                    `;
                } else {
                    this.elements.emptyState.innerHTML = `
                        <p style="color: var(--color-text-muted); font-size: var(--text-lg);">
                            📝 No tasks yet. Add your first task above!
                        </p>
                    `;
                }
                this.elements.emptyState.style.display = 'block';
            } else {
                this.elements.emptyState.style.display = 'none';
            }
        };

        /**
         * Check if any filters are active
         */
        TaskManager.prototype.hasActiveFilters = function() {
            return this.currentFilters.category || 
                   this.currentFilters.status || 
                   this.currentFilters.priority;
        };

        /**
         * Clear all filters
         */
        TaskManager.prototype.clearFilters = function() {
            this.currentFilters = {
                category: '',
                status: '',
                priority: ''
            };
            
            // Reset filter UI
            const categoryFilter = document.getElementById('filter-category');
            const statusFilter = document.getElementById('filter-status');
            const priorityFilter = document.getElementById('filter-priority');
            
            if (categoryFilter) categoryFilter.value = '';
            if (statusFilter) statusFilter.value = '';
            if (priorityFilter) priorityFilter.value = '';
            
            // Re-render all tasks
            this.renderTasks();
            this.updateEmptyState();
        };

        /**
         * Show success message
         */
        TaskManager.prototype.showSuccess = function(message) {
            // You can implement a toast notification system here
            alert(message); // Temporary implementation
        };

        /**
         * Show error message
         */
        TaskManager.prototype.showError = function(message) {
            // You can implement a toast notification system here
            alert(message); // Temporary implementation
        };
        
        class BackgroundSyncManager {
            constructor(taskDatabase) {
                this.taskDatabase = taskDatabase;
                this.syncQueue = new SyncQueue();
                this.conflictResolver = new ConflictResolver();
                this.realtimeSync = new RealtimeSyncLayer(this);
                
                this.isOnline = navigator.onLine;
                this.isSyncing = false;
                this.syncRetryAttempts = new Map();
                this.maxRetryAttempts = 5;
                this.retryDelay = 1000; // Start with 1 second
                
                // Sync statistics for monitoring
                this.stats = {
                    totalOperations: 0,
                    successfulSyncs: 0,
                    failedSyncs: 0,
                    conflictsResolved: 0,
                    lastSyncTime: null
                };
                
                console.log('🔄 BackgroundSyncManager initialized');
                this.init();
            }
            
            /**
             * Initialize the background sync system
             */
            async init() {
                try {
                    // Initialize sync queue storage
                    await this.syncQueue.init();
                    
                    // Setup network event listeners
                    this.setupNetworkListeners();
                    
                    // Setup service worker integration
                    await this.setupServiceWorkerIntegration();
                    
                    // Initialize real-time sync if available
                    await this.realtimeSync.init();
                    
                    // Process any queued operations
                    if (this.isOnline) {
                        await this.processQueue();
                    }
                    
                    console.log('✅ Background sync system ready');
                    
                } catch (error) {
                    console.error('❌ Failed to initialize background sync:', error);
                }
            }
            
            /**
             * Queue a sync operation for background processing
             */
            async queueOperation(operation) {
                try {
                    // Add unique ID and timestamp
                    const syncOperation = {
                        id: this.generateOperationId(),
                        ...operation,
                        timestamp: Date.now(),
                        retryCount: 0,
                        status: 'pending'
                    };
                    
                    // Store in persistent queue
                    await this.syncQueue.add(syncOperation);
                    this.stats.totalOperations++;
                    
                    console.log(`📤 Queued ${operation.type} operation:`, syncOperation.id);
                    
                    // Try immediate sync if online
                    if (this.isOnline && !this.isSyncing) {
                        this.processQueue();
                    }
                    
                    // Register for background sync with service worker
                    await this.requestBackgroundSync(syncOperation);
                    
                    return syncOperation.id;
                    
                } catch (error) {
                    console.error('❌ Failed to queue sync operation:', error);
                    throw error;
                }
            }
            
            /**
             * Process the sync queue
             */
            async processQueue() {
                if (this.isSyncing || !this.isOnline) {
                    console.log('⏸️ Sync already in progress or offline');
                    return;
                }
                
                this.isSyncing = true;
                console.log('🔄 Processing sync queue...');
                
                try {
                    const pendingOperations = await this.syncQueue.getPending();
                    console.log(`📋 Found ${pendingOperations.length} pending operations`);
                    
                    for (const operation of pendingOperations) {
                        try {
                            await this.processSingleOperation(operation);
                        } catch (error) {
                            console.error(`❌ Failed to process operation ${operation.id}:`, error);
                            await this.handleOperationFailure(operation, error);
                        }
                    }
                    
                    this.stats.lastSyncTime = Date.now();
                    console.log('✅ Sync queue processing complete');
                    
                } catch (error) {
                    console.error('❌ Error processing sync queue:', error);
                } finally {
                    this.isSyncing = false;
                }
            }
            
            /**
             * Process a single sync operation
             */
            async processSingleOperation(operation) {
                console.log(`🔄 Processing ${operation.type} operation:`, operation.id);
                
                // Check for conflicts before processing
                const hasConflict = await this.conflictResolver.detectConflict(operation);
                if (hasConflict) {
                    const resolved = await this.conflictResolver.resolveConflict(operation);
                    if (!resolved) {
                        throw new Error('Conflict resolution failed');
                    }
                    this.stats.conflictsResolved++;
                }
                
                // Execute the operation based on type
                switch (operation.type) {
                    case 'CREATE_TASK':
                        await this.syncCreateTask(operation);
                        break;
                    case 'UPDATE_TASK':
                        await this.syncUpdateTask(operation);
                        break;
                    case 'DELETE_TASK':
                        await this.syncDeleteTask(operation);
                        break;
                    case 'BULK_SYNC':
                        await this.syncBulkOperations(operation);
                        break;
                    default:
                        throw new Error(`Unknown operation type: ${operation.type}`);
                }
                
                // Mark operation as completed
                await this.syncQueue.markCompleted(operation.id);
                this.stats.successfulSyncs++;
                
                console.log(`✅ Operation ${operation.id} completed successfully`);
            }
            
            /**
             * Sync a task creation operation
             */
            async syncCreateTask(operation) {
                const { taskData } = operation.data;
                
                // Simulate API call (replace with actual endpoint)
                const response = await this.makeAPIRequest('POST', '/api/tasks', taskData);
                
                if (response.success) {
                    // Update local task with server-assigned ID if different
                    if (response.data.id !== taskData.id) {
                        await this.taskDatabase.updateTask(taskData.id, { serverId: response.data.id });
                    }
                } else {
                    throw new Error(`Server error: ${response.error}`);
                }
            }
            
            /**
             * Sync a task update operation
             */
            async syncUpdateTask(operation) {
                const { taskId, updates } = operation.data;
                
                // Get current task state for conflict detection
                const currentTask = await this.taskDatabase.readTask(taskId);
                if (!currentTask) {
                    throw new Error(`Task ${taskId} no longer exists locally`);
                }
                
                // Simulate API call
                const response = await this.makeAPIRequest('PUT', `/api/tasks/${taskId}`, {
                    ...updates,
                    version: currentTask.version || 1
                });
                
                if (response.success) {
                    // Update local version number
                    await this.taskDatabase.updateTask(taskId, { 
                        version: response.data.version,
                        lastSyncTime: Date.now()
                    });
                } else if (response.error === 'CONFLICT') {
                    // Handle version conflict
                    throw new Error('Version conflict detected');
                } else {
                    throw new Error(`Server error: ${response.error}`);
                }
            }
            
            /**
             * Sync a task deletion operation
             */
            async syncDeleteTask(operation) {
                const { taskId } = operation.data;
                
                // Simulate API call
                const response = await this.makeAPIRequest('DELETE', `/api/tasks/${taskId}`);
                
                if (!response.success && response.error !== 'NOT_FOUND') {
                    throw new Error(`Server error: ${response.error}`);
                }
            }
            
            /**
             * Handle operation failure with retry logic
             */
            async handleOperationFailure(operation, error) {
                const retryCount = this.syncRetryAttempts.get(operation.id) || 0;
                
                if (retryCount < this.maxRetryAttempts) {
                    // Exponential backoff
                    const delay = this.retryDelay * Math.pow(2, retryCount);
                    
                    console.log(`🔄 Retrying operation ${operation.id} in ${delay}ms (attempt ${retryCount + 1})`);
                    
                    this.syncRetryAttempts.set(operation.id, retryCount + 1);
                    
                    // Update operation status
                    await this.syncQueue.updateStatus(operation.id, 'retrying');
                    
                    // Schedule retry
                    setTimeout(async () => {
                        try {
                            await this.processSingleOperation(operation);
                        } catch (retryError) {
                            await this.handleOperationFailure(operation, retryError);
                        }
                    }, delay);
                    
                } else {
                    // Max retries exceeded
                    console.error(`❌ Operation ${operation.id} failed after ${this.maxRetryAttempts} attempts`);
                    await this.syncQueue.markFailed(operation.id, error.message);
                    this.stats.failedSyncs++;
                    this.syncRetryAttempts.delete(operation.id);
                }
            }
            
            /**
             * Make API request with proper error handling
             */
            async makeAPIRequest(method, endpoint, data = null) {
                // Simulate API endpoint - replace with actual implementation
                console.log(`🌐 API ${method} ${endpoint}:`, data);
                
                // Simulate network delay
                await new Promise(resolve => setTimeout(resolve, 100 + Math.random() * 200));
                
                // Simulate various responses for testing
                const random = Math.random();
                if (random < 0.1) {
                    // 10% chance of server error
                    return { success: false, error: 'SERVER_ERROR' };
                } else if (random < 0.15) {
                    // 5% chance of conflict
                    return { success: false, error: 'CONFLICT' };
                } else {
                    // Success case
                    return { 
                        success: true, 
                        data: { 
                            id: data?.id || this.generateOperationId(),
                            version: (data?.version || 0) + 1,
                            timestamp: Date.now()
                        }
                    };
                }
            }
            
            /**
             * Setup network event listeners
             */
            setupNetworkListeners() {
                window.addEventListener('online', () => {
                    console.log('📶 Network connection restored');
                    this.isOnline = true;
                    this.processQueue();
                });
                
                window.addEventListener('offline', () => {
                    console.log('📵 Network connection lost');
                    this.isOnline = false;
                });
            }
            
            /**
             * Setup service worker integration for background sync
             */
            async setupServiceWorkerIntegration() {
                if (!('serviceWorker' in navigator)) {
                    console.log('⚠️ Service Worker not available');
                    return;
                }
                
                try {
                    const registration = await navigator.serviceWorker.ready;
                    
                    // Listen for messages from service worker
                    navigator.serviceWorker.addEventListener('message', (event) => {
                        const { type, data } = event.data;
                        
                        if (type === 'BACKGROUND_SYNC_COMPLETE') {
                            console.log('🔄 Background sync completed:', data);
                            this.handleBackgroundSyncComplete(data);
                        }
                    });
                    
                    console.log('✅ Service worker integration ready');
                    
                } catch (error) {
                    console.error('❌ Failed to setup service worker integration:', error);
                }
            }
            
            /**
             * Request background sync through service worker
             */
            async requestBackgroundSync(operation) {
                if (!('serviceWorker' in navigator) || !('sync' in window.ServiceWorkerRegistration.prototype)) {
                    console.log('⚠️ Background Sync API not available');
                    return false;
                }
                
                try {
                    const registration = await navigator.serviceWorker.ready;
                    
                    // Store operation data for service worker
                    if (registration.active) {
                        registration.active.postMessage({
                            type: 'QUEUE_SYNC_OPERATION',
                            data: operation
                        });
                    }
                    
                    // Register background sync
                    await registration.sync.register(`task-sync-${operation.id}`);
                    console.log(`🔄 Background sync registered for operation: ${operation.id}`);
                    
                    return true;
                    
                } catch (error) {
                    console.error('❌ Failed to register background sync:', error);
                    return false;
                }
            }
            
            /**
             * Handle background sync completion
             */
            handleBackgroundSyncComplete(data) {
                const { operationId, success, error } = data;
                
                if (success) {
                    console.log(`✅ Background sync completed successfully: ${operationId}`);
                    this.stats.successfulSyncs++;
                } else {
                    console.error(`❌ Background sync failed: ${operationId}`, error);
                    this.stats.failedSyncs++;
                }
            }
            
            /**
             * Generate unique operation ID
             */
            generateOperationId() {
                return `op-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
            }
            
            /**
             * Get sync statistics
             */
            getStats() {
                return { ...this.stats };
            }
        }
        
        /**
         * SyncQueue - Persistent queue for sync operations using IndexedDB
         */
        class SyncQueue {
            constructor() {
                this.dbName = 'SyncQueueDB';
                this.version = 1;
                this.db = null;
            }
            
            /**
             * Initialize the sync queue database
             */
            async init() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(this.dbName, this.version);
                    
                    request.onerror = () => reject(request.error);
                    request.onsuccess = () => {
                        this.db = request.result;
                        resolve(this.db);
                    };
                    
                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        
                        if (!db.objectStoreNames.contains('operations')) {
                            const store = db.createObjectStore('operations', { keyPath: 'id' });
                            store.createIndex('by-status', 'status', { unique: false });
                            store.createIndex('by-timestamp', 'timestamp', { unique: false });
                            store.createIndex('by-type', 'type', { unique: false });
                        }
                    };
                });
            }
            
            /**
             * Add operation to queue
             */
            async add(operation) {
                const tx = this.db.transaction(['operations'], 'readwrite');
                const store = tx.objectStore('operations');
                await store.put(operation);
            }
            
            /**
             * Get all pending operations
             */
            async getPending() {
                const tx = this.db.transaction(['operations'], 'readonly');
                const store = tx.objectStore('operations');
                const index = store.index('by-status');
                
                const pending = await index.getAll('pending');
                const retrying = await index.getAll('retrying');
                
                return [...pending, ...retrying].sort((a, b) => a.timestamp - b.timestamp);
            }
            
            /**
             * Mark operation as completed
             */
            async markCompleted(operationId) {
                const tx = this.db.transaction(['operations'], 'readwrite');
                const store = tx.objectStore('operations');
                
                const operation = await store.get(operationId);
                if (operation) {
                    operation.status = 'completed';
                    operation.completedAt = Date.now();
                    await store.put(operation);
                }
            }
            
            /**
             * Mark operation as failed
             */
            async markFailed(operationId, errorMessage) {
                const tx = this.db.transaction(['operations'], 'readwrite');
                const store = tx.objectStore('operations');
                
                const operation = await store.get(operationId);
                if (operation) {
                    operation.status = 'failed';
                    operation.error = errorMessage;
                    operation.failedAt = Date.now();
                    await store.put(operation);
                }
            }
            
            /**
             * Update operation status
             */
            async updateStatus(operationId, status) {
                const tx = this.db.transaction(['operations'], 'readwrite');
                const store = tx.objectStore('operations');
                
                const operation = await store.get(operationId);
                if (operation) {
                    operation.status = status;
                    await store.put(operation);
                }
            }
        }
        
        /**
         * ConflictResolver - Handle conflicts in multi-device synchronization
         */
        class ConflictResolver {
            constructor() {
                this.conflictStrategies = {
                    'last-write-wins': this.lastWriteWins,
                    'manual-merge': this.manualMerge,
                    'field-level-merge': this.fieldLevelMerge
                };
                this.defaultStrategy = 'last-write-wins';
            }
            
            /**
             * Detect if an operation has conflicts
             */
            async detectConflict(operation) {
                // Simulate conflict detection logic
                // In a real implementation, this would check version numbers,
                // timestamps, and checksums against server state
                
                const random = Math.random();
                return random < 0.05; // 5% chance of conflict for testing
            }
            
            /**
             * Resolve conflict using configured strategy
             */
            async resolveConflict(operation) {
                console.log(`🔧 Resolving conflict for operation: ${operation.id}`);
                
                const strategy = this.conflictStrategies[this.defaultStrategy];
                return await strategy.call(this, operation);
            }
            
            /**
             * Last-write-wins conflict resolution
             */
            async lastWriteWins(operation) {
                console.log('⚡ Using last-write-wins strategy');
                
                // Update operation with conflict resolution metadata
                operation.conflictResolution = {
                    strategy: 'last-write-wins',
                    timestamp: Date.now()
                };
                
                return true; // Always succeeds
            }
            
            /**
             * Manual merge conflict resolution (simplified)
             */
            async manualMerge(operation) {
                console.log('🤝 Using manual merge strategy');
                
                // In a real implementation, this would prompt the user
                // or use intelligent merging rules
                operation.conflictResolution = {
                    strategy: 'manual-merge',
                    timestamp: Date.now(),
                    merged: true
                };
                
                return true;
            }
            
            /**
             * Field-level merge conflict resolution
             */
            async fieldLevelMerge(operation) {
                console.log('🔀 Using field-level merge strategy');
                
                operation.conflictResolution = {
                    strategy: 'field-level-merge',
                    timestamp: Date.now()
                };
                
                return true;
            }
        }
        
        /**
         * RealtimeSyncLayer - WebSocket-based real-time synchronization
         */
        class RealtimeSyncLayer {
            constructor(syncManager) {
                this.syncManager = syncManager;
                this.ws = null;
                this.isConnected = false;
                this.reconnectAttempts = 0;
                this.maxReconnectAttempts = 5;
                this.reconnectDelay = 1000;
                this.heartbeatInterval = null;
            }
            
            /**
             * Initialize real-time sync connection
             */
            async init() {
                if (!this.isWebSocketSupported()) {
                    console.log('⚠️ WebSocket not supported - real-time sync disabled');
                    return;
                }
                
                // Check if we should attempt real-time sync
                if (!this.shouldAttemptConnection()) {
                    console.log('ℹ️ Real-time sync disabled (demo mode) - using offline-only sync');
                    return;
                }
                
                await this.connect();
            }
            
            /**
             * Check WebSocket support
             */
            isWebSocketSupported() {
                return typeof WebSocket !== 'undefined';
            }
            
            /**
             * Check if we should attempt WebSocket connection
             */
            shouldAttemptConnection() {
                // In debug mode, check for explicit real-time sync enablement
                const urlParams = new URLSearchParams(window.location.search);
                
                // Only connect if explicitly enabled or if we have a real server URL
                const enableRealtime = urlParams.has('realtime') || 
                                     urlParams.has('ws') ||
                                     this.hasRealServerUrl();
                
                return enableRealtime;
            }
            
            /**
             * Check if we have a real server URL configured
             */
            hasRealServerUrl() {
                // Check for environment variables or configuration
                // This would be set to true if you have an actual WebSocket server
                return window.REALTIME_SYNC_URL && 
                       window.REALTIME_SYNC_URL !== 'wss://api.example.com/task-sync';
            }
            
            /**
             * Connect to WebSocket server
             */
            async connect() {
                try {
                    // Use configured URL or mock URL for demonstration
                    const wsUrl = window.REALTIME_SYNC_URL || 'wss://api.example.com/task-sync';
                    
                    console.log('🔌 Connecting to real-time sync server...');
                    console.log('ℹ️ Note: This is a demo URL. Set window.REALTIME_SYNC_URL or use ?realtime=true to test');
                    
                    this.ws = new WebSocket(wsUrl);
                    
                    this.ws.onopen = () => this.handleConnection();
                    this.ws.onmessage = (event) => this.handleMessage(event);
                    this.ws.onclose = () => this.handleDisconnection();
                    this.ws.onerror = (error) => this.handleError(error);
                    
                } catch (error) {
                    const isDemoUrl = (window.REALTIME_SYNC_URL || 'wss://api.example.com/task-sync').includes('api.example.com');
                    
                    if (!isDemoUrl) {
                        console.error('❌ Failed to connect to sync server:', error);
                        this.scheduleReconnect();
                    } else {
                        console.log('ℹ️ Demo WebSocket server unavailable - continuing offline-only mode');
                    }
                }
            }
            
            /**
             * Handle WebSocket connection
             */
            handleConnection() {
                console.log('✅ Real-time sync connected');
                this.isConnected = true;
                this.reconnectAttempts = 0;
                
                // Start heartbeat
                this.startHeartbeat();
                
                // Send authentication if needed
                this.authenticate();
            }
            
            /**
             * Handle incoming WebSocket messages
             */
            handleMessage(event) {
                try {
                    const message = JSON.parse(event.data);
                    console.log('📨 Received real-time sync message:', message);
                    
                    switch (message.type) {
                        case 'TASK_UPDATED':
                            this.handleRemoteTaskUpdate(message.data);
                            break;
                        case 'TASK_CREATED':
                            this.handleRemoteTaskCreate(message.data);
                            break;
                        case 'TASK_DELETED':
                            this.handleRemoteTaskDelete(message.data);
                            break;
                        case 'SYNC_REQUEST':
                            this.handleSyncRequest(message.data);
                            break;
                        case 'HEARTBEAT':
                            this.handleHeartbeat();
                            break;
                    }
                    
                } catch (error) {
                    console.error('❌ Error processing sync message:', error);
                }
            }
            
            /**
             * Handle remote task updates
             */
            async handleRemoteTaskUpdate(data) {
                console.log('🔄 Processing remote task update:', data);
                
                // Check if we need to update local task
                const localTask = await this.syncManager.taskDatabase.readTask(data.taskId);
                
                if (!localTask || localTask.version < data.version) {
                    // Update local task with remote changes
                    await this.syncManager.taskDatabase.updateTask(data.taskId, {
                        ...data.updates,
                        version: data.version,
                        lastSyncTime: Date.now()
                    });
                    
                    // Notify UI of change
                    if (window.taskManager) {
                        window.taskManager.render();
                    }
                }
            }
            
            /**
             * Send message through WebSocket
             */
            send(message) {
                if (this.isConnected && this.ws.readyState === WebSocket.OPEN) {
                    this.ws.send(JSON.stringify(message));
                    return true;
                } else {
                    console.warn('⚠️ Cannot send message - WebSocket not connected');
                    return false;
                }
            }
            
            /**
             * Start heartbeat mechanism
             */
            startHeartbeat() {
                this.heartbeatInterval = setInterval(() => {
                    if (this.isConnected) {
                        this.send({ type: 'HEARTBEAT', timestamp: Date.now() });
                    }
                }, 30000); // 30 seconds
            }
            
            /**
             * Handle authentication
             */
            authenticate() {
                // Send authentication message if needed
                this.send({
                    type: 'AUTH',
                    clientId: this.generateClientId(),
                    timestamp: Date.now()
                });
            }
            
            /**
             * Generate unique client ID
             */
            generateClientId() {
                return `client-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
            }
            
            /**
             * Handle disconnection and attempt reconnect
             */
            handleDisconnection() {
                console.log('🔌 Real-time sync disconnected');
                this.isConnected = false;
                
                if (this.heartbeatInterval) {
                    clearInterval(this.heartbeatInterval);
                    this.heartbeatInterval = null;
                }
                
                // Only attempt reconnect if we have a real server or explicit enablement
                if (this.shouldAttemptConnection()) {
                    this.scheduleReconnect();
                } else {
                    console.log('ℹ️ Real-time sync disabled - continuing with offline-only mode');
                }
            }
            
            /**
             * Schedule reconnection attempt
             */
            scheduleReconnect() {
                if (this.reconnectAttempts < this.maxReconnectAttempts) {
                    const delay = this.reconnectDelay * Math.pow(2, this.reconnectAttempts);
                    
                    // Check if this is a demo URL
                    const wsUrl = window.REALTIME_SYNC_URL || 'wss://api.example.com/task-sync';
                    const isDemoUrl = wsUrl.includes('api.example.com');
                    
                    if (isDemoUrl) {
                        console.log(`ℹ️ Demo WebSocket server unavailable (expected). Real-time sync disabled.`);
                        console.log('� To test real-time sync: Set window.REALTIME_SYNC_URL to your server or use ?realtime=true');
                        return; // Don't retry for demo URLs
                    }
                    
                    console.log(`�🔄 Reconnecting in ${delay}ms (attempt ${this.reconnectAttempts + 1})`);
                    
                    setTimeout(() => {
                        this.reconnectAttempts++;
                        this.connect();
                    }, delay);
                } else {
                    console.log('ℹ️ Max reconnection attempts reached - real-time sync disabled');
                    console.log('💡 Background sync will continue to work offline');
                }
            }
            
            /**
             * Handle WebSocket errors
             */
            handleError(error) {
                // Don't spam console for expected demo connection failures
                const wsUrl = window.REALTIME_SYNC_URL || 'wss://api.example.com/task-sync';
                const isDemoUrl = wsUrl.includes('api.example.com');
                
                if (!isDemoUrl) {
                    console.error('❌ WebSocket error:', error);
                } else {
                    console.log('ℹ️ Demo WebSocket connection failed (expected) - using offline-only sync');
                }
            }
            
            /**
             * Cleanup resources
             */
            destroy() {
                if (this.heartbeatInterval) {
                    clearInterval(this.heartbeatInterval);
                }
                
                if (this.ws) {
                    this.ws.close();
                }
                
                this.isConnected = false;
            }
        }
        
        /* ============================================
           �🚀 APPLICATION INITIALIZATION
           ============================================ */
        
        /**
         * 🔍 MAJOR FUNCTION POINT #7: APPLICATION BOOTSTRAP
         * 
         * This is where everything comes together:
         * - 🏗️ **Initialize the TaskManager** with all components
         * - 📱 **Setup PWA features** for app-like experience
         * - 🎯 **Register Service Worker** for offline functionality
         * - 🔧 **Error handling** for graceful degradation
         * 
         * The bootstrap process ensures the app works reliably across
         * different browsers and network conditions.
         */
        
        // Global task manager instance
        let taskManager;
        
        /**
         * Initialize the application when DOM is ready
         */
        document.addEventListener('DOMContentLoaded', async function() {
            await initializeApp();
        });
        
        // Initialize Service Worker and Task Manager
        async function initializeApp() {
            try {
                console.log('🚀 Initializing Offline Task Manager...');
                
                // Try to register and initialize Service Worker
                if ('serviceWorker' in navigator) {
                    try {
                        await initializeServiceWorker();
                        console.log('✅ Service Worker initialized');
                    } catch (swError) {
                        console.warn('⚠️ Service Worker initialization failed:', swError.message);
                        console.log('📱 App will continue without Service Worker features');
                        
                        // Show helpful banner if it's due to file:// protocol
                        if (location.protocol === 'file:') {
                            showServiceWorkerBanner();
                        }
                    }
                } else {
                    console.warn('⚠️ Service Worker not supported in this browser');
                }
                
                // Initialize task manager (this should always work)
                taskManager = new TaskManager();
                await taskManager.init();
                
                // Setup cleanup for cross-tab sync when page unloads
                window.addEventListener('beforeunload', () => {
                    if (taskManager && taskManager.syncManager) {
                        taskManager.syncManager.destroy();
                    }
                });
                
                // Setup PWA features (only if possible)
                try {
                    setupPWA();
                } catch (pwaError) {
                    console.warn('⚠️ PWA features unavailable:', pwaError.message);
                }
                
                // Setup global access for debugging
                const urlParams = new URLSearchParams(window.location.search);
                if (urlParams.has('debug')) {
                    window.taskManager = taskManager;
                    window.safeCacheTaskData = safeCacheTaskData;
                    window.safeRequestBackgroundSync = safeRequestBackgroundSync;
                    
                    // Expose background sync functions for testing
                    if (taskManager.backgroundSyncManager) {
                        window.backgroundSyncManager = taskManager.backgroundSyncManager;
                        window.realtimeSync = taskManager.backgroundSyncManager.realtimeSync;
                        
                        window.testBackgroundSync = function() {
                            return taskManager.backgroundSyncManager.getStats();
                        };
                        window.forceSync = function() {
                            return taskManager.backgroundSyncManager.processQueue();
                        };
                        window.simulateOffline = function() {
                            Object.defineProperty(navigator, 'onLine', {
                                writable: true,
                                value: false
                            });
                            window.dispatchEvent(new Event('offline'));
                            console.log('📵 Simulated offline mode');
                        };
                        window.simulateOnline = function() {
                            Object.defineProperty(navigator, 'onLine', {
                                writable: true,
                                value: true
                            });
                            window.dispatchEvent(new Event('online'));
                            console.log('📶 Simulated online mode');
                        };
                        window.enableRealTimeSync = function(wsUrl = 'ws://localhost:8080/sync') {
                            console.log('🔌 Enabling real-time sync with URL:', wsUrl);
                            window.REALTIME_SYNC_URL = wsUrl;
                            taskManager.backgroundSyncManager.realtimeSync.connect();
                        };
                        window.disableRealTimeSync = function() {
                            console.log('🔌 Disabling real-time sync');
                            taskManager.backgroundSyncManager.realtimeSync.destroy();
                        };
                    }
                    
                    // Also expose direct functions if they exist
                    if (typeof cacheTaskData !== 'undefined') window.cacheTaskData = cacheTaskData;
                    if (typeof requestBackgroundSync !== 'undefined') window.requestBackgroundSync = requestBackgroundSync;
                    
                    console.log('🔧 Debug mode enabled - global access available');
                    console.log('🧪 Testing functions:');
                    console.log('  • testBackgroundSync() - Get sync statistics');
                    console.log('  • forceSync() - Force immediate sync');
                    console.log('  • simulateOffline() - Simulate offline mode');
                    console.log('  • simulateOnline() - Simulate online mode');
                    console.log('  • enableRealTimeSync(url) - Connect to real WebSocket server');
                    console.log('  • disableRealTimeSync() - Disconnect real-time sync');
                    console.log('💡 Real-time sync is disabled by default. Use enableRealTimeSync() with your server URL to test.');
                }
                
                console.log('✅ App initialization complete');
                
            } catch (error) {
                console.error('❌ Failed to initialize app:', error);
                
                // Show user-friendly error
                document.body.innerHTML = `
                    <div style="
                        display: flex; 
                        align-items: center; 
                        justify-content: center; 
                        min-height: 100vh; 
                        padding: 2rem;
                        text-align: center;
                        background: var(--color-background);
                        color: var(--color-text);
                    ">
                        <div>
                            <h1 style="margin-bottom: 1rem; color: var(--color-danger);">⚠️ Application Error</h1>
                            <p style="margin-bottom: 2rem; max-width: 400px;">
                                Failed to initialize the task manager. This might be due to your browser 
                                not supporting IndexedDB or other required features.
                            </p>
                            <p><strong>Error:</strong> ${error.message}</p>
                            <button onclick="location.reload()" style="
                                padding: 0.75rem 1.5rem;
                                background: var(--color-primary);
                                color: white;
                                border: none;
                                border-radius: 0.5rem;
                                cursor: pointer;
                            ">
                                Try Again
                            </button>
                        </div>
                    </div>
                `;
            }
        }
        
        /**
         * Show informational banner about Service Worker limitations
         */
        function showServiceWorkerBanner() {
            // Don't show if banner already exists
            if (document.getElementById('sw-info-banner')) return;
            
            const banner = document.createElement('div');
            banner.id = 'sw-info-banner';
            banner.innerHTML = `
                <div style="
                    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                    color: white;
                    padding: 1rem;
                    text-align: center;
                    position: fixed;
                    top: 0;
                    left: 0;
                    right: 0;
                    z-index: 1000;
                    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                    transform: translateY(-100%);
                    transition: transform 0.3s ease-in-out;
                ">
                    <div style="max-width: 800px; margin: 0 auto; font-size: 0.9rem;">
                        <strong>ℹ️ Limited Offline Features</strong>
                        <p style="margin: 0.5rem 0; opacity: 0.9;">
                            For full offline capabilities including background sync, serve this file via HTTP:
                            <code style="background: rgba(255,255,255,0.2); padding: 0.2rem 0.4rem; border-radius: 3px; margin: 0 0.5rem;">python -m http.server 8080</code>
                        </p>
                        <div style="margin-top: 0.5rem;">
                            <button onclick="copyServerCommand()" style="
                                background: rgba(255,255,255,0.2);
                                border: 1px solid rgba(255,255,255,0.3);
                                color: white;
                                padding: 0.3rem 0.8rem;
                                border-radius: 4px;
                                margin-right: 0.5rem;
                                cursor: pointer;
                                font-size: 0.8rem;
                            ">Copy Command</button>
                            <button onclick="dismissServiceWorkerBanner()" style="
                                background: transparent;
                                border: 1px solid rgba(255,255,255,0.3);
                                color: white;
                                padding: 0.3rem 0.8rem;
                                border-radius: 4px;
                                cursor: pointer;
                                font-size: 0.8rem;
                            ">Dismiss</button>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.appendChild(banner);
            
            // Animate in
            setTimeout(() => {
                banner.firstElementChild.style.transform = 'translateY(0)';
            }, 100);
            
            // Auto-dismiss after 10 seconds
            setTimeout(() => {
                dismissServiceWorkerBanner();
            }, 10000);
        }
        
        function copyServerCommand() {
            const command = 'python -m http.server 8080';
            navigator.clipboard.writeText(command).then(() => {
                console.log('📋 Server command copied to clipboard');
                // Show brief feedback
                const button = event.target;
                const originalText = button.textContent;
                button.textContent = 'Copied!';
                setTimeout(() => {
                    button.textContent = originalText;
                }, 1000);
            }).catch(() => {
                console.log('💡 Copy this command: ' + command);
            });
        }
        
        function dismissServiceWorkerBanner() {
            const banner = document.getElementById('sw-info-banner');
            if (banner) {
                banner.firstElementChild.style.transform = 'translateY(-100%)';
                setTimeout(() => banner.remove(), 300);
            }
        }
        
        /**
         * Initialize and register Service Worker
         */
        async function initializeServiceWorker() {
            try {
                // Check if we're in a supported environment
                if (!('serviceWorker' in navigator)) {
                    throw new Error('Service Worker not supported');
                }
                
                // Check current protocol and environment
                const protocol = location.protocol;
                const hostname = location.hostname;
                
                console.log(`🔍 Current environment: ${protocol}//${hostname || 'file'}`);
                
                // Service Workers have limitations with file:// protocol
                if (protocol === 'file:') {
                    console.warn('⚠️ Service Worker limitations with file:// protocol');
                    console.log('💡 For full Service Worker support, serve the file via HTTP server:');
                    console.log('   - python -m http.server 8080');
                    console.log('   - then open http://localhost:8080/offline-task-manager.html');
                    throw new Error('Service Worker not supported with file:// protocol');
                }
                
                // Check if we're in a secure context
                const isSecureContext = protocol === 'https:' || 
                                      hostname === 'localhost' || 
                                      hostname === '127.0.0.1';
                
                if (!isSecureContext) {
                    console.warn('⚠️ Service Worker requires HTTPS or localhost');
                    throw new Error('Service Worker requires secure context');
                }
                
                // Register Service Worker using the dedicated sw.js file
                console.log('🔧 Registering Service Worker: sw.js');
                
                const registration = await navigator.serviceWorker.register('sw.js', {
                    scope: './'
                });
                
                console.log('✅ Service Worker registered:', registration);
                
                // Setup message handling
                setupServiceWorkerMessaging();
                
                // Setup background sync
                setupBackgroundSync(registration);
                
                // Handle registration events
                registration.addEventListener('updatefound', () => {
                    console.log('🔄 Service Worker update found');
                    const newWorker = registration.installing;
                    
                    newWorker.addEventListener('statechange', () => {
                        if (newWorker.state === 'activated') {
                            console.log('✅ Service Worker updated and activated');
                            // Optional: Show user notification about update
                        }
                    });
                });
                
                // Wait for Service Worker to be ready
                await navigator.serviceWorker.ready;
                console.log('✅ Service Worker ready');
                
                return registration;
                
                // Create Service Worker file dynamically using a more reliable method
                // We'll use a combination of URL.createObjectURL with proper cleanup
                try {
                    // First, try to create and register a temporary SW file
                    const response = await createServiceWorkerFile(serviceWorkerCode);
                    
                    if (response) {
                        const registration = await navigator.serviceWorker.register(response.url, {
                            scope: './'
                        });
                        console.log('✅ Service Worker registered:', registration);
                        return registration;
                    }
                } catch (error) {
                    console.log('� Fallback: Trying alternative registration method');
                }
                
                // Fallback: Try direct registration with better error handling
                await registerServiceWorkerFallback(serviceWorkerCode);
                
                // Setup message handling
                setupServiceWorkerMessaging();
                
                // Setup background sync
                setupBackgroundSync();
                
                // Handle registration events
                registration.addEventListener('updatefound', () => {
                    console.log('🔄 Service Worker update found');
                    const newWorker = registration.installing;
                    
                    newWorker.addEventListener('statechange', () => {
                        if (newWorker.state === 'activated') {
                            console.log('✅ Service Worker updated and activated');
                            // Optional: Show user notification about update
                        }
                    });
                });
                
                // Wait for Service Worker to be ready
                await navigator.serviceWorker.ready;
                console.log('✅ Service Worker ready');
                
                return registration;
                
            } catch (error) {
                console.error('❌ Service Worker registration failed:', error);
                throw error;
            }
        }
        
        /**
         * Setup Service Worker messaging system
         */
        function setupServiceWorkerMessaging() {
            navigator.serviceWorker.addEventListener('message', handleServiceWorkerMessage);
            
            // Handle messages from Service Worker
            navigator.serviceWorker.addEventListener('message', (event) => {
                const { type, data } = event.data;
                
                switch (type) {
                    case 'SYNC_COMPLETE':
                        console.log('🔄 Background sync completed:', data);
                        // Optional: Refresh data or show notification
                        break;
                        
                    case 'CACHE_UPDATED':
                        console.log('💾 Cache updated:', data);
                        break;
                        
                    case 'NOTIFICATION_CLICKED':
                        console.log('🔔 Notification clicked:', data);
                        // Handle notification actions
                        break;
                        
                    default:
                        console.log('📨 Service Worker message:', event.data);
                }
            });
        }
        
        /**
         * Handle app installation prompt
         */
        let deferredPrompt;
        
        window.addEventListener('beforeinstallprompt', (e) => {
            // Prevent the mini-infobar from appearing on mobile
            e.preventDefault();
            // Stash the event so it can be triggered later
            deferredPrompt = e;
            
            // Show install button or banner
            showInstallPrompt();
        });
        
        function showInstallPrompt() {
            // Create install prompt UI
            const installBanner = document.createElement('div');
            installBanner.id = 'install-banner';
            installBanner.innerHTML = `
                <div style="
                    position: fixed;
                    bottom: 0;
                    left: 0;
                    right: 0;
                    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                    color: white;
                    padding: 1rem;
                    text-align: center;
                    box-shadow: 0 -2px 10px rgba(0,0,0,0.1);
                    z-index: 1000;
                    transform: translateY(100%);
                    transition: transform 0.3s ease-in-out;
                " onclick="installApp()">
                    <div style="max-width: 600px; margin: 0 auto;">
                        <strong>📱 Install Task Manager</strong>
                        <p style="margin: 0.5rem 0; opacity: 0.9;">Add to home screen for quick access</p>
                        <button onclick="installApp(); event.stopPropagation();" style="
                            background: rgba(255,255,255,0.2);
                            border: 1px solid rgba(255,255,255,0.3);
                            color: white;
                            padding: 0.5rem 1rem;
                            border-radius: 4px;
                            margin-right: 1rem;
                            cursor: pointer;
                        ">Install</button>
                        <button onclick="dismissInstallPrompt(); event.stopPropagation();" style="
                            background: transparent;
                            border: 1px solid rgba(255,255,255,0.3);
                            color: white;
                            padding: 0.5rem 1rem;
                            border-radius: 4px;
                            cursor: pointer;
                        ">Maybe Later</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(installBanner);
            
            // Animate in
            setTimeout(() => {
                installBanner.firstElementChild.style.transform = 'translateY(0)';
            }, 100);
        }
        
        async function installApp() {
            if (deferredPrompt) {
                // Show the install prompt
                deferredPrompt.prompt();
                
                // Wait for the user to respond
                const { outcome } = await deferredPrompt.userChoice;
                console.log(`👤 User response to install prompt: ${outcome}`);
                
                // Clear the deferred prompt
                deferredPrompt = null;
                
                // Remove install banner
                dismissInstallPrompt();
            }
        }
        
        function dismissInstallPrompt() {
            const banner = document.getElementById('install-banner');
            if (banner) {
                banner.firstElementChild.style.transform = 'translateY(100%)';
                setTimeout(() => banner.remove(), 300);
            }
        }
        
        // Handle app installed event
        window.addEventListener('appinstalled', (evt) => {
            console.log('📱 App was installed');
            // Optional: Track installation or show success message
        });
        
        /**
         * 🔍 MAJOR FUNCTION POINT #8: SERVICE WORKER IMPLEMENTATION
         * 
         * Service Workers provide the foundation for offline-first functionality:
         * - 🔄 **Background sync** for reliable data synchronization
         * - 📦 **Cache management** for offline app shell and resources
         * - 🔔 **Push notifications** for task reminders and updates
         * - 🛡️ **Network interception** for graceful offline fallbacks
         * - ⚡ **Background processing** without blocking UI
         * 
         * Key Benefits:
         * - True offline functionality - app works without internet
         * - Reliable sync when connection is restored
         * - Native app-like experience with background operations
         * - Improved performance through intelligent caching
         */
        
        /**
         * Setup Progressive Web App features with Service Worker
         */
        async function setupPWA() {
            // Register Service Worker first
            await initializeServiceWorker();
            
            // Create and inject manifest
            const manifestData = {
                name: 'Offline Task Manager',
                short_name: 'TaskManager',
                description: 'Offline-first task management system',
                start_url: '/',
                display: 'standalone',
                background_color: '#ffffff',
                theme_color: '#2563eb',
                orientation: 'portrait-primary',
                categories: ['productivity', 'utilities'],
                icons: [
                    {
                        src: 'data:image/svg+xml;base64,' + btoa(`
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 192 192" fill="#2563eb">
                                <rect x="20" y="20" width="152" height="152" rx="20" fill="#2563eb"/>
                                <path d="M60 96l20 20 40-40" stroke="white" stroke-width="8" fill="none" stroke-linecap="round" stroke-linejoin="round"/>
                                <rect x="40" y="60" width="12" height="12" rx="2" fill="white"/>
                                <rect x="40" y="80" width="12" height="12" rx="2" fill="white"/>
                                <rect x="40" y="100" width="12" height="12" rx="2" fill="white"/>
                                <rect x="40" y="120" width="12" height="12" rx="2" fill="white"/>
                            </svg>
                        `),
                        sizes: '192x192',
                        type: 'image/svg+xml'
                    },
                    {
                        src: 'data:image/svg+xml;base64,' + btoa(`
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" fill="#2563eb">
                                <rect x="50" y="50" width="412" height="412" rx="50" fill="#2563eb"/>
                                <path d="M160 256l60 60 120-120" stroke="white" stroke-width="20" fill="none" stroke-linecap="round" stroke-linejoin="round"/>
                                <rect x="100" y="160" width="32" height="32" rx="4" fill="white"/>
                                <rect x="100" y="220" width="32" height="32" rx="4" fill="white"/>
                                <rect x="100" y="280" width="32" height="32" rx="4" fill="white"/>
                                <rect x="100" y="340" width="32" height="32" rx="4" fill="white"/>
                            </svg>
                        `),
                        sizes: '512x512',
                        type: 'image/svg+xml'
                    }
                ]
            };
            
            // Inject manifest
            const manifestBlob = new Blob([JSON.stringify(manifestData)], { type: 'application/json' });
            const manifestURL = URL.createObjectURL(manifestBlob);
            const manifestLink = document.createElement('link');
            manifestLink.rel = 'manifest';
            manifestLink.href = manifestURL;
            document.head.appendChild(manifestLink);
            
            console.log('📱 PWA manifest injected');
        }
        
        /**
         * Generate Service Worker code as string (embedded approach)
         */
        function generateServiceWorkerCode() {
            return `
                'use strict';
                
                /* ============================================
                   🔧 SERVICE WORKER CONFIGURATION
                   ============================================ */
                
                const CACHE_NAME = 'task-manager-v1.0';
                const STATIC_CACHE = 'task-manager-static';
                const SYNC_TAG = 'task-sync';
                
                // Cache strategies
                const CACHE_STRATEGIES = {
                    CACHE_FIRST: 'cache-first',
                    NETWORK_FIRST: 'network-first',
                    CACHE_ONLY: 'cache-only',
                    NETWORK_ONLY: 'network-only'
                };
                
                /* ============================================
                   📦 SERVICE WORKER LIFECYCLE
                   ============================================ */
                
                // Installation phase
                self.addEventListener('install', event => {
                    console.log('🔧 Service Worker installing...');
                    
                    event.waitUntil(
                        caches.open(STATIC_CACHE).then(cache => {
                            // Cache the main application (self)
                            return cache.add('/');
                        }).then(() => {
                            console.log('✅ Static assets cached');
                            // Force activation
                            return self.skipWaiting();
                        })
                    );
                });
                
                // Activation phase
                self.addEventListener('activate', event => {
                    console.log('🚀 Service Worker activating...');
                    
                    event.waitUntil(
                        Promise.all([
                            // Clean up old caches
                            caches.keys().then(cacheNames => {
                                return Promise.all(
                                    cacheNames.map(cacheName => {
                                        if (cacheName !== CACHE_NAME && cacheName !== STATIC_CACHE) {
                                            console.log('🗑️ Deleting old cache:', cacheName);
                                            return caches.delete(cacheName);
                                        }
                                    })
                                );
                            }),
                            // Take control of all clients
                            self.clients.claim()
                        ]).then(() => {
                            console.log('✅ Service Worker activated and ready');
                        })
                    );
                });
                
                /* ============================================
                   🌐 NETWORK INTERCEPTION & CACHING
                   ============================================ */
                
                // Fetch event handling
                self.addEventListener('fetch', event => {
                    const request = event.request;
                    const url = new URL(request.url);
                    
                    // Only handle same-origin requests
                    if (url.origin !== location.origin) {
                        return;
                    }
                    
                    // Determine cache strategy based on request
                    const strategy = getCacheStrategy(request);
                    
                    event.respondWith(handleRequest(request, strategy));
                });
                
                /**
                 * Determine appropriate cache strategy
                 */
                function getCacheStrategy(request) {
                    const url = new URL(request.url);
                    
                    // HTML files: Network first (for updates)
                    if (request.destination === 'document') {
                        return CACHE_STRATEGIES.NETWORK_FIRST;
                    }
                    
                    // API calls: Network first
                    if (url.pathname.includes('/api/')) {
                        return CACHE_STRATEGIES.NETWORK_FIRST;
                    }
                    
                    // Static assets: Cache first
                    return CACHE_STRATEGIES.CACHE_FIRST;
                }
                
                /**
                 * Handle request with specified strategy
                 */
                async function handleRequest(request, strategy) {
                    const cache = await caches.open(CACHE_NAME);
                    
                    switch (strategy) {
                        case CACHE_STRATEGIES.CACHE_FIRST:
                            return handleCacheFirst(request, cache);
                            
                        case CACHE_STRATEGIES.NETWORK_FIRST:
                            return handleNetworkFirst(request, cache);
                            
                        case CACHE_STRATEGIES.CACHE_ONLY:
                            return cache.match(request);
                            
                        case CACHE_STRATEGIES.NETWORK_ONLY:
                            return fetch(request);
                            
                        default:
                            return handleCacheFirst(request, cache);
                    }
                }
                
                /**
                 * Cache-first strategy
                 */
                async function handleCacheFirst(request, cache) {
                    const cachedResponse = await cache.match(request);
                    
                    if (cachedResponse) {
                        // Return cached version immediately
                        return cachedResponse;
                    }
                    
                    try {
                        // Fetch and cache for future use
                        const networkResponse = await fetch(request);
                        cache.put(request, networkResponse.clone());
                        return networkResponse;
                    } catch (error) {
                        console.log('📴 Network unavailable for:', request.url);
                        // Return offline fallback if available
                        return getOfflineFallback(request);
                    }
                }
                
                /**
                 * Network-first strategy
                 */
                async function handleNetworkFirst(request, cache) {
                    try {
                        // Try network first
                        const networkResponse = await fetch(request);
                        
                        // Cache successful responses
                        if (networkResponse.ok) {
                            cache.put(request, networkResponse.clone());
                        }
                        
                        return networkResponse;
                    } catch (error) {
                        console.log('📴 Network failed, trying cache for:', request.url);
                        
                        // Fallback to cache
                        const cachedResponse = await cache.match(request);
                        if (cachedResponse) {
                            return cachedResponse;
                        }
                        
                        // Return offline fallback
                        return getOfflineFallback(request);
                    }
                }
                
                /**
                 * Get offline fallback response
                 */
                function getOfflineFallback(request) {
                    if (request.destination === 'document') {
                        // Return a simple offline page for HTML requests
                        return new Response(
                            '<html><body><h1>📴 Offline</h1><p>You are currently offline. Please check your connection and try again.</p></body></html>',
                            { headers: { 'Content-Type': 'text/html' } }
                        );
                    }
                    
                    // For other requests, return a basic error response
                    return new Response('Offline', { status: 503, statusText: 'Service Unavailable' });
                }
                
                /* ============================================
                   🔄 ENHANCED BACKGROUND SYNC (Phase 2)
                   ============================================ */
                
                // Enhanced background sync event handler
                self.addEventListener('sync', event => {
                    console.log('🔄 Background sync triggered:', event.tag);
                    
                    // Handle different sync types
                    if (event.tag === SYNC_TAG) {
                        event.waitUntil(syncTasks());
                    } else if (event.tag.startsWith('task-sync-')) {
                        // Handle specific operation sync
                        const operationId = event.tag.replace('task-sync-', '');
                        event.waitUntil(syncSpecificOperation(operationId));
                    } else if (event.tag === 'bulk-sync') {
                        event.waitUntil(syncBulkOperations());
                    }
                });
                
                // Message handler for communication with BackgroundSyncManager
                self.addEventListener('message', event => {
                    const { type, data } = event.data;
                    
                    switch (type) {
                        case 'QUEUE_SYNC_OPERATION':
                            event.waitUntil(queueSyncOperation(data));
                            break;
                        case 'GET_SYNC_STATS':
                            event.waitUntil(getSyncStats().then(stats => {
                                event.ports[0]?.postMessage({ type: 'SYNC_STATS', data: stats });
                            }));
                            break;
                        case 'FORCE_SYNC':
                            event.waitUntil(forceSyncAll());
                            break;
                    }
                });
                
                /**
                 * Enhanced sync system with queue management
                 */
                async function syncTasks() {
                    try {
                        console.log('🔄 Starting enhanced task synchronization...');
                        
                        // Get pending sync operations from our queue
                        const pendingOperations = await getPendingSyncOperations();
                        
                        if (pendingOperations.length === 0) {
                            console.log('✅ No pending operations to sync');
                            return;
                        }
                        
                        console.log(\`🔄 Processing \${pendingOperations.length} queued operations...\`);
                        
                        let successCount = 0;
                        let failureCount = 0;
                        
                        // Process operations with proper error handling
                        for (const operation of pendingOperations) {
                            try {
                                await processSyncOperation(operation);
                                await markOperationCompleted(operation.id);
                                successCount++;
                                console.log(\`✅ Synced \${operation.type} operation: \${operation.id}\`);
                                
                                // Notify main thread of individual success
                                notifyClients({
                                    type: 'OPERATION_SYNCED',
                                    data: { operationId: operation.id, success: true }
                                });
                                
                            } catch (error) {
                                console.error(\`❌ Failed to sync operation \${operation.id}:\`, error);
                                await handleSyncFailure(operation, error);
                                failureCount++;
                                
                                // Notify main thread of failure
                                notifyClients({
                                    type: 'OPERATION_SYNCED',
                                    data: { operationId: operation.id, success: false, error: error.message }
                                });
                            }
                        }
                        
                        // Update sync statistics
                        await updateSyncStats(successCount, failureCount);
                        
                        // Notify main thread of sync completion
                        notifyClients({
                            type: 'BACKGROUND_SYNC_COMPLETE',
                            data: { 
                                total: pendingOperations.length,
                                successful: successCount,
                                failed: failureCount,
                                timestamp: Date.now()
                            }
                        });
                        
                        console.log(\`✅ Background sync completed: \${successCount} success, \${failureCount} failed\`);
                        
                    } catch (error) {
                        console.error('❌ Background sync failed:', error);
                        
                        // Notify main thread of system failure
                        notifyClients({
                            type: 'BACKGROUND_SYNC_ERROR',
                            data: { error: error.message, timestamp: Date.now() }
                        });
                        
                        throw error; // Retry sync later
                    }
                }
                
                /**
                 * Sync a specific operation by ID
                 */
                async function syncSpecificOperation(operationId) {
                    try {
                        console.log(\`🎯 Syncing specific operation: \${operationId}\`);
                        
                        const operation = await getSyncOperation(operationId);
                        if (!operation) {
                            console.log(\`⚠️ Operation \${operationId} not found in queue\`);
                            return;
                        }
                        
                        await processSyncOperation(operation);
                        await markOperationCompleted(operationId);
                        
                        // Notify main thread
                        notifyClients({
                            type: 'OPERATION_SYNCED',
                            data: { operationId, success: true }
                        });
                        
                        console.log(\`✅ Successfully synced operation: \${operationId}\`);
                        
                    } catch (error) {
                        console.error(\`❌ Failed to sync operation \${operationId}:\`, error);
                        
                        // Handle failure with retry logic
                        const operation = await getSyncOperation(operationId);
                        if (operation) {
                            await handleSyncFailure(operation, error);
                        }
                        
                        // Notify main thread of failure
                        notifyClients({
                            type: 'OPERATION_SYNCED',
                            data: { operationId, success: false, error: error.message }
                        });
                    }
                }
                
                /**
                 * Process bulk sync operations
                 */
                async function syncBulkOperations() {
                    try {
                        console.log('📦 Starting bulk sync operations...');
                        
                        // Get all pending operations grouped by type
                        const pendingOperations = await getPendingSyncOperations();
                        const operationsByType = groupOperationsByType(pendingOperations);
                        
                        // Process operations in optimal order
                        const processingOrder = ['CREATE_TASK', 'UPDATE_TASK', 'DELETE_TASK'];
                        
                        for (const type of processingOrder) {
                            const operations = operationsByType[type] || [];
                            if (operations.length > 0) {
                                console.log(\`🔄 Processing \${operations.length} \${type} operations...\`);
                                await processBulkOperationType(type, operations);
                            }
                        }
                        
                        console.log('✅ Bulk sync operations completed');
                        
                    } catch (error) {
                        console.error('❌ Bulk sync failed:', error);
                        throw error;
                    }
                }
                
                /**
                 * Process operations by type for better efficiency
                 */
                async function processBulkOperationType(type, operations) {
                    const batchSize = 10; // Process in batches to avoid overwhelming the server
                    
                    for (let i = 0; i < operations.length; i += batchSize) {
                        const batch = operations.slice(i, i + batchSize);
                        
                        try {
                            // Process batch of operations
                            await Promise.all(batch.map(op => processSyncOperation(op)));
                            
                            // Mark all as completed
                            await Promise.all(batch.map(op => markOperationCompleted(op.id)));
                            
                            console.log(\`✅ Processed batch of \${batch.length} \${type} operations\`);
                            
                        } catch (error) {
                            console.error(\`❌ Batch processing failed for \${type}:\`, error);
                            
                            // Handle individual failures in the batch
                            for (const operation of batch) {
                                try {
                                    await processSyncOperation(operation);
                                    await markOperationCompleted(operation.id);
                                } catch (opError) {
                                    await handleSyncFailure(operation, opError);
                                }
                            }
                        }
                    }
                }
                
                /**
                 * Enhanced operation processing with conflict resolution
                 */
                async function processSyncOperation(operation) {
                    console.log(\`🔄 Processing \${operation.type} operation: \${operation.id}\`);
                    
                    // Add conflict detection
                    const hasConflict = await detectOperationConflict(operation);
                    if (hasConflict) {
                        console.log(\`🔧 Conflict detected for operation: \${operation.id}\`);
                        operation = await resolveOperationConflict(operation);
                    }
                    
                    // Process based on operation type
                    switch (operation.type) {
                        case 'CREATE_TASK':
                            return await syncCreateTaskOperation(operation);
                        case 'UPDATE_TASK':
                            return await syncUpdateTaskOperation(operation);
                        case 'DELETE_TASK':
                            return await syncDeleteTaskOperation(operation);
                        case 'BULK_UPDATE':
                            return await syncBulkUpdateOperation(operation);
                        default:
                            throw new Error(\`Unknown operation type: \${operation.type}\`);
                    }
                }
                
                /**
                 * Sync task creation operation
                 */
                async function syncCreateTaskOperation(operation) {
                    const { taskData } = operation.data;
                    
                    // Simulate API call with proper error handling
                    const response = await makeAPIRequest('POST', '/api/tasks', {
                        ...taskData,
                        clientId: operation.id,
                        timestamp: operation.timestamp
                    });
                    
                    if (response.ok) {
                        const serverTask = await response.json();
                        
                        // Update local task with server data
                        await updateLocalTask(taskData.id, {
                            serverId: serverTask.id,
                            version: serverTask.version,
                            lastSyncTime: Date.now()
                        });
                        
                        console.log(\`✅ Task created on server: \${serverTask.id}\`);
                    } else {
                        throw new Error(\`Server error: \${response.status} - \${response.statusText}\`);
                    }
                }
                
                /**
                 * Sync task update operation
                 */
                async function syncUpdateTaskOperation(operation) {
                    const { taskId, updates } = operation.data;
                    
                    // Get current task data for version checking
                    const localTask = await getLocalTask(taskId);
                    if (!localTask) {
                        throw new Error(\`Task \${taskId} no longer exists locally\`);
                    }
                    
                    const response = await makeAPIRequest('PUT', \`/api/tasks/\${taskId}\`, {
                        ...updates,
                        version: localTask.version || 1,
                        clientId: operation.id
                    });
                    
                    if (response.ok) {
                        const serverTask = await response.json();
                        
                        // Update local version
                        await updateLocalTask(taskId, {
                            version: serverTask.version,
                            lastSyncTime: Date.now()
                        });
                        
                        console.log(\`✅ Task updated on server: \${taskId}\`);
                    } else if (response.status === 409) {
                        // Conflict - trigger conflict resolution
                        throw new Error('CONFLICT_DETECTED');
                    } else {
                        throw new Error(\`Server error: \${response.status}\`);
                    }
                }
                
                /**
                 * Sync task deletion operation
                 */
                async function syncDeleteTaskOperation(operation) {
                    const { taskId } = operation.data;
                    
                    const response = await makeAPIRequest('DELETE', \`/api/tasks/\${taskId}\`);
                    
                    if (response.ok || response.status === 404) {
                        console.log(\`✅ Task deleted on server: \${taskId}\`);
                    } else {
                        throw new Error(\`Server error: \${response.status}\`);
                    }
                }
                
                /**
                 * Detect operation conflicts
                 */
                async function detectOperationConflict(operation) {
                    // Check if task was modified by another client
                    if (operation.type === 'UPDATE_TASK' || operation.type === 'DELETE_TASK') {
                        const { taskId } = operation.data;
                        
                        try {
                            // Check server version
                            const response = await makeAPIRequest('GET', \`/api/tasks/\${taskId}\`);
                            if (response.ok) {
                                const serverTask = await response.json();
                                const localTask = await getLocalTask(taskId);
                                
                                // Compare versions or timestamps
                                if (localTask && serverTask.version > localTask.version) {
                                    return true;
                                }
                            }
                        } catch (error) {
                            console.warn('Could not check for conflicts:', error);
                        }
                    }
                    
                    return false;
                }
                
                /**
                 * Resolve operation conflicts
                 */
                async function resolveOperationConflict(operation) {
                    console.log(\`🔧 Resolving conflict for operation: \${operation.id}\`);
                    
                    // Simple last-write-wins strategy
                    // In production, this would be more sophisticated
                    operation.conflictResolution = {
                        strategy: 'last-write-wins',
                        timestamp: Date.now()
                    };
                    
                    return operation;
                }
                
                /**
                 * Handle sync operation failure with retry logic
                 */
                async function handleSyncFailure(operation, error) {
                    const retryCount = operation.retryCount || 0;
                    const maxRetries = 3;
                    
                    if (retryCount < maxRetries) {
                        // Increment retry count and update operation
                        operation.retryCount = retryCount + 1;
                        operation.lastError = error.message;
                        operation.nextRetryAt = Date.now() + (Math.pow(2, retryCount) * 1000);
                        
                        await updateSyncOperation(operation);
                        
                        console.log(\`🔄 Scheduled retry \${operation.retryCount}/\${maxRetries} for operation: \${operation.id}\`);
                    } else {
                        // Mark as permanently failed
                        operation.status = 'failed';
                        operation.finalError = error.message;
                        operation.failedAt = Date.now();
                        
                        await updateSyncOperation(operation);
                        
                        console.error(\`❌ Operation permanently failed after \${maxRetries} retries: \${operation.id}\`);
                    }
                }
                
                /**
                 * Queue sync operation for background processing
                 */
                async function queueSyncOperation(operation) {
                    try {
                        // Store operation in IndexedDB
                        const db = await openSyncDatabase();
                        const tx = db.transaction(['operations'], 'readwrite');
                        const store = tx.objectStore('operations');
                        
                        await store.put(operation);
                        
                        console.log(\`📥 Queued sync operation: \${operation.type} - \${operation.id}\`);
                        
                        return true;
                    } catch (error) {
                        console.error('Failed to queue sync operation:', error);
                        return false;
                    }
                }
                
                /**
                 * Enhanced notification system for clients
                 */
                async function notifyClients(message) {
                    const clients = await self.clients.matchAll({
                        includeUncontrolled: true,
                        type: 'window'
                    });
                    
                    clients.forEach(client => {
                        client.postMessage(message);
                    });
                }
                
                /**
                 * Get pending sync operations from IndexedDB
                 */
                async function getPendingSyncOperations() {
                    try {
                        const db = await openSyncDatabase();
                        const tx = db.transaction(['operations'], 'readonly');
                        const store = tx.objectStore('operations');
                        const index = store.index('by-status');
                        
                        const pending = await index.getAll('pending');
                        const retrying = await index.getAll('retrying');
                        
                        // Combine and sort by timestamp
                        return [...pending, ...retrying].sort((a, b) => a.timestamp - b.timestamp);
                    } catch (error) {
                        console.error('Failed to get pending operations:', error);
                        return [];
                    }
                }
                
                /**
                 * Open sync operations database
                 */
                async function openSyncDatabase() {
                    return new Promise((resolve, reject) => {
                        const request = indexedDB.open('SyncQueueDB', 1);
                        request.onerror = () => reject(request.error);
                        request.onsuccess = () => resolve(request.result);
                        request.onupgradeneeded = (event) => {
                            const db = event.target.result;
                            if (!db.objectStoreNames.contains('operations')) {
                                const store = db.createObjectStore('operations', { keyPath: 'id' });
                                store.createIndex('by-status', 'status', { unique: false });
                                store.createIndex('by-timestamp', 'timestamp', { unique: false });
                                store.createIndex('by-type', 'type', { unique: false });
                            }
                        };
                    });
                }
                
                /**
                 * Helper functions for operation management
                 */
                async function getSyncOperation(operationId) {
                    const db = await openSyncDatabase();
                    const tx = db.transaction(['operations'], 'readonly');
                    const store = tx.objectStore('operations');
                    return await store.get(operationId);
                }
                
                async function markOperationCompleted(operationId) {
                    const db = await openSyncDatabase();
                    const tx = db.transaction(['operations'], 'readwrite');
                    const store = tx.objectStore('operations');
                    
                    const operation = await store.get(operationId);
                    if (operation) {
                        operation.status = 'completed';
                        operation.completedAt = Date.now();
                        await store.put(operation);
                    }
                }
                
                async function updateSyncOperation(operation) {
                    const db = await openSyncDatabase();
                    const tx = db.transaction(['operations'], 'readwrite');
                    const store = tx.objectStore('operations');
                    await store.put(operation);
                }
                
                /**
                 * Group operations by type for efficient batch processing
                 */
                function groupOperationsByType(operations) {
                    return operations.reduce((groups, operation) => {
                        const type = operation.type;
                        if (!groups[type]) {
                            groups[type] = [];
                        }
                        groups[type].push(operation);
                        return groups;
                    }, {});
                }
                
                /**
                 * Mock API request function (replace with actual implementation)
                 */
                async function makeAPIRequest(method, endpoint, data = null) {
                    // This is a mock implementation for testing
                    // In production, replace with actual API calls
                    
                    console.log(\`🌐 Mock API \${method} \${endpoint}\`, data);
                    
                    // Simulate network delay
                    await new Promise(resolve => setTimeout(resolve, 100 + Math.random() * 300));
                    
                    // Simulate various response scenarios
                    const random = Math.random();
                    
                    if (random < 0.05) {
                        // 5% failure rate
                        return { ok: false, status: 500, statusText: 'Internal Server Error' };
                    } else if (random < 0.1) {
                        // 5% conflict rate for updates
                        return { ok: false, status: 409, statusText: 'Conflict' };
                    } else {
                        // Success case
                        return {
                            ok: true,
                            status: 200,
                            statusText: 'OK',
                            json: async () => ({
                                id: data?.id || \`server-\${Date.now()}\`,
                                version: (data?.version || 0) + 1,
                                timestamp: Date.now(),
                                ...data
                            })
                        };
                    }
                }
                
                /**
                 * Get sync statistics
                 */
                async function getSyncStats() {
                    try {
                        const db = await openSyncDatabase();
                        const tx = db.transaction(['operations'], 'readonly');
                        const store = tx.objectStore('operations');
                        
                        const allOps = await store.getAll();
                        
                        const stats = {
                            total: allOps.length,
                            pending: allOps.filter(op => op.status === 'pending').length,
                            completed: allOps.filter(op => op.status === 'completed').length,
                            failed: allOps.filter(op => op.status === 'failed').length,
                            retrying: allOps.filter(op => op.status === 'retrying').length,
                            lastSyncTime: Math.max(...allOps.map(op => op.completedAt || 0))
                        };
                        
                        return stats;
                    } catch (error) {
                        console.error('Failed to get sync stats:', error);
                        return {
                            total: 0,
                            pending: 0,
                            completed: 0,
                            failed: 0,
                            retrying: 0,
                            lastSyncTime: null
                        };
                    }
                }
                
                /**
                 * Force sync all pending operations
                 */
                async function forceSyncAll() {
                    console.log('🚀 Force syncing all pending operations...');
                    await syncTasks();
                }
                
                /**
                 * Process a single sync operation
                 */
                async function processSyncOperation(operation) {
                    // This would handle the actual sync logic
                    // (to be implemented with full sync system)
                    console.log('Processing sync operation:', operation);
                }
                
                /**
                 * Remove completed sync operation
                 */
                async function removeSyncOperation(operationId) {
                    // Remove from IndexedDB pending operations
                    console.log('Removing sync operation:', operationId);
                }
                
                /**
                 * Notify all clients of sync completion
                 */
                function notifyClientsOfSync() {
                    self.clients.matchAll().then(clients => {
                        clients.forEach(client => {
                            client.postMessage({
                                type: 'SYNC_COMPLETED',
                                timestamp: Date.now()
                            });
                        });
                    });
                }
                
                /* ============================================
                   🔔 PUSH NOTIFICATIONS
                   ============================================ */
                
                // Push notification event
                self.addEventListener('push', event => {
                    console.log('🔔 Push notification received');
                    
                    const options = {
                        body: 'You have pending tasks to complete',
                        icon: '/icon-192.png',
                        badge: '/badge-72.png',
                        tag: 'task-reminder',
                        requireInteraction: false,
                        actions: [
                            {
                                action: 'open',
                                title: 'Open Tasks'
                            },
                            {
                                action: 'dismiss',
                                title: 'Dismiss'
                            }
                        ]
                    };
                    
                    if (event.data) {
                        const data = event.data.json();
                        options.body = data.message || options.body;
                        options.data = data;
                    }
                    
                    event.waitUntil(
                        self.registration.showNotification('Task Manager', options)
                    );
                });
                
                // Notification click event
                self.addEventListener('notificationclick', event => {
                    console.log('🔔 Notification clicked:', event.action);
                    
                    event.notification.close();
                    
                    if (event.action === 'open' || !event.action) {
                        // Open the app
                        event.waitUntil(
                            self.clients.matchAll().then(clients => {
                                // Focus existing window if available
                                for (const client of clients) {
                                    if (client.url.includes('/') && 'focus' in client) {
                                        return client.focus();
                                    }
                                }
                                
                                // Open new window
                                if (self.clients.openWindow) {
                                    return self.clients.openWindow('/');
                                }
                            })
                        );
                    }
                    
                    // Handle other actions (dismiss, etc.)
                    // Can be extended for specific task actions
                });
                
                /* ============================================
                   📱 MESSAGE HANDLING
                   ============================================ */
                
                // Handle messages from main thread
                self.addEventListener('message', event => {
                    console.log('📨 Service Worker received message:', event.data);
                    
                    const { type, data } = event.data;
                    
                    switch (type) {
                        case 'SKIP_WAITING':
                            self.skipWaiting();
                            break;
                            
                        case 'CACHE_TASK_DATA':
                            // Cache task data for offline access
                            cacheTaskData(data);
                            break;
                            
                        case 'QUEUE_SYNC':
                            // Queue operation for background sync
                            queueSyncOperation(data);
                            break;
                            
                        case 'REQUEST_SYNC':
                            // Request immediate sync if possible
                            triggerSync();
                            break;
                            
                        default:
                            console.log('Unknown message type:', type);
                    }
                });
                
                /**
                 * Cache task data for offline access
                 */
                async function cacheTaskData(taskData) {
                    try {
                        const cache = await caches.open(CACHE_NAME);
                        const response = new Response(JSON.stringify(taskData));
                        await cache.put('/task-data', response);
                        console.log('✅ Task data cached for offline access');
                    } catch (error) {
                        console.error('❌ Failed to cache task data:', error);
                    }
                }
                
                /**
                 * Queue operation for background sync
                 */
                function queueSyncOperation(operation) {
                    // This would add the operation to IndexedDB for later sync
                    console.log('📋 Queued sync operation:', operation);
                }
                
                /**
                 * Trigger immediate sync if online
                 */
                function triggerSync() {
                    if (navigator.onLine) {
                        syncTasks().catch(error => {
                            console.error('❌ Manual sync failed:', error);
                        });
                    } else {
                        console.log('📴 Cannot sync while offline');
                    }
                }
                
                console.log('✅ Service Worker script loaded successfully');
            `;
        }
        
        /**
         * Setup background sync for offline operations
         */
        async function setupBackgroundSync(registration) {
            if (!('sync' in window.ServiceWorkerRegistration.prototype)) {
                console.warn('⚠️ Background Sync not supported');
                return false;
            }
            
            try {
                // Register for background sync
                await registration.sync.register('task-sync');
                console.log('✅ Background sync registered');
                return true;
            } catch (error) {
                console.error('❌ Background sync registration failed:', error);
                return false;
            }
        }
        
        /**
         * Handle messages from Service Worker
         */
        function handleServiceWorkerMessage(event) {
            const { type, data } = event.data;
            
            switch (type) {
                case 'SYNC_COMPLETED':
                    console.log('🔄 Background sync completed');
                    if (window.taskManager) {
                        // Reload tasks to get any synced changes
                        window.taskManager.loadTasks().then(() => {
                            window.taskManager.render();
                        });
                    }
                    break;
                    
                case 'CACHE_UPDATED':
                    console.log('📦 Cache updated');
                    break;
                    
                case 'SYNC_ERROR':
                    console.error('❌ Background sync error:', data);
                    break;
                    
                default:
                    console.log('📨 Unknown message from Service Worker:', type);
            }
        }
        
        /**
         * Show update available notification
         */
        function showUpdateAvailableNotification() {
            const updateBanner = document.createElement('div');
            updateBanner.className = 'update-banner';
            updateBanner.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                background: var(--color-primary);
                color: white;
                padding: var(--space-md);
                text-align: center;
                z-index: 1000;
                box-shadow: var(--shadow-md);
            `;
            
            updateBanner.innerHTML = `
                <p style="margin: 0; margin-bottom: var(--space-sm);">
                    🔄 A new version of the app is available
                </p>
                <button onclick="location.reload()" style="
                    background: white;
                    color: var(--color-primary);
                    border: none;
                    padding: var(--space-xs) var(--space-md);
                    border-radius: var(--radius-md);
                    cursor: pointer;
                    font-weight: 500;
                    margin-right: var(--space-sm);
                ">
                    Update Now
                </button>
                <button onclick="this.parentElement.remove()" style="
                    background: transparent;
                    color: white;
                    border: 1px solid white;
                    padding: var(--space-xs) var(--space-md);
                    border-radius: var(--radius-md);
                    cursor: pointer;
                    font-weight: 500;
                ">
                    Later
                </button>
            `;
            
            document.body.appendChild(updateBanner);
        }
        
        /**
         * Request background sync for pending operations
         */
        async function requestBackgroundSync(operation) {
            if (!('serviceWorker' in navigator) || !navigator.serviceWorker.ready) {
                console.warn('⚠️ Service Worker not available for background sync');
                return false;
            }
            
            try {
                const registration = await navigator.serviceWorker.ready;
                
                // Send operation to Service Worker for queuing
                if (registration.active) {
                    registration.active.postMessage({
                        type: 'QUEUE_SYNC',
                        data: operation
                    });
                }
                
                // Register for background sync
                if ('sync' in registration) {
                    await registration.sync.register('task-sync');
                    console.log('🔄 Background sync requested for:', operation.type);
                    return true;
                }
                
                return false;
            } catch (error) {
                console.error('❌ Failed to request background sync:', error);
                return false;
            }
        }
        
        /**
         * Cache task data for offline access
         */
        async function cacheTaskData(taskData) {
            if (!('serviceWorker' in navigator) || !navigator.serviceWorker.ready) {
                return false;
            }
            
            try {
                const registration = await navigator.serviceWorker.ready;
                
                if (registration.active) {
                    registration.active.postMessage({
                        type: 'CACHE_TASK_DATA',
                        data: taskData
                    });
                }
                
                return true;
            } catch (error) {
                console.error('❌ Failed to cache task data:', error);
                return false;
            }
        }
        
        /**
         * Handle visibility change for background operations
         */
        document.addEventListener('visibilitychange', function() {
            if (document.visibilityState === 'visible') {
                console.log('👁️ App became visible - refreshing data');
                if (taskManager) {
                    taskManager.loadTasks().then(() => taskManager.render());
                }
            } else {
                console.log('🙈 App became hidden - pausing operations');
            }
        });
        
        // Expose taskManager globally for debugging
        window.taskManager = taskManager;
        
        console.log('🎯 Task Manager script loaded successfully');
    </script>
</body>
</html>