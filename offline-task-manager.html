<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Offline Task Manager</title>
    <meta name="description" content="Offline-first task management system with no external dependencies">
    
    <!-- PWA Meta Tags -->
    <meta name="theme-color" content="#2563eb">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="Task Manager">
    
    <style>
        /* ============================================
           🎨 CSS DESIGN SYSTEM & LAYOUT
           ============================================ */
        
        /* CSS Custom Properties for Theming */
        :root {
            /* Light theme colors */
            --color-primary: #2563eb;
            --color-primary-dark: #1d4ed8;
            --color-success: #10b981;
            --color-warning: #f59e0b;
            --color-danger: #ef4444;
            --color-background: #ffffff;
            --color-surface: #f8fafc;
            --color-surface-elevated: #ffffff;
            --color-text: #1e293b;
            --color-text-muted: #64748b;
            --color-border: #e2e8f0;
            --color-border-focus: #3b82f6;
            
            /* Spacing system */
            --space-xs: 0.25rem;
            --space-sm: 0.5rem;
            --space-md: 1rem;
            --space-lg: 1.5rem;
            --space-xl: 2rem;
            --space-2xl: 3rem;
            
            /* Typography scale */
            --text-xs: 0.75rem;
            --text-sm: 0.875rem;
            --text-base: 1rem;
            --text-lg: 1.125rem;
            --text-xl: 1.25rem;
            --text-2xl: 1.5rem;
            
            /* Border radius */
            --radius-sm: 0.125rem;
            --radius-md: 0.375rem;
            --radius-lg: 0.5rem;
            --radius-xl: 0.75rem;
            
            /* Shadows */
            --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
            --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
            
            /* Transitions */
            --transition-fast: 150ms ease-in-out;
            --transition-normal: 250ms ease-in-out;
            --transition-slow: 350ms ease-in-out;
        }
        
        /* Dark theme */
        [data-theme="dark"] {
            --color-background: #0f172a;
            --color-surface: #1e293b;
            --color-surface-elevated: #334155;
            --color-text: #f1f5f9;
            --color-text-muted: #94a3b8;
            --color-border: #334155;
        }
        
        /* Reset and base styles */
        *, *::before, *::after {
            box-sizing: border-box;
        }
        
        * {
            margin: 0;
            padding: 0;
        }
        
        html {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            line-height: 1.6;
            color: var(--color-text);
            background-color: var(--color-background);
        }
        
        body {
            min-height: 100vh;
            overflow-x: hidden;
        }
        
        /* ============================================
           📱 RESPONSIVE LAYOUT SYSTEM
           ============================================ */
        
        .app-container {
            display: grid;
            grid-template-areas: 
                "header"
                "main"
                "footer";
            grid-template-rows: auto 1fr auto;
            min-height: 100vh;
            background-color: var(--color-background);
        }
        
        @media (min-width: 768px) {
            .app-container {
                grid-template-areas: 
                    "header header"
                    "sidebar main"
                    "footer footer";
                grid-template-columns: 280px 1fr;
                grid-template-rows: auto 1fr auto;
            }
        }
        
        /* Header */
        .app-header {
            grid-area: header;
            background-color: var(--color-surface-elevated);
            border-bottom: 1px solid var(--color-border);
            padding: var(--space-md) var(--space-lg);
            box-shadow: var(--shadow-sm);
        }
        
        .header-content {
            display: flex;
            align-items: center;
            justify-content: space-between;
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .app-title {
            font-size: var(--text-xl);
            font-weight: 600;
            color: var(--color-primary);
            display: flex;
            align-items: center;
            gap: var(--space-sm);
        }
        
        .status-indicator {
            display: flex;
            align-items: center;
            gap: var(--space-sm);
            font-size: var(--text-sm);
            color: var(--color-text-muted);
        }
        
        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: var(--color-success);
        }
        
        .status-dot.offline {
            background-color: var(--color-danger);
        }
        
        /* Sidebar */
        .app-sidebar {
            grid-area: sidebar;
            background-color: var(--color-surface);
            border-right: 1px solid var(--color-border);
            padding: var(--space-lg);
            display: none;
        }
        
        @media (min-width: 768px) {
            .app-sidebar {
                display: block;
            }
        }
        
        /* Main content */
        .app-main {
            grid-area: main;
            padding: var(--space-lg);
            overflow-y: auto;
        }
        
        .main-content {
            max-width: 800px;
            margin: 0 auto;
        }
        
        /* Footer */
        .app-footer {
            grid-area: footer;
            background-color: var(--color-surface);
            border-top: 1px solid var(--color-border);
            padding: var(--space-md) var(--space-lg);
            text-align: center;
            font-size: var(--text-sm);
            color: var(--color-text-muted);
        }
        
        /* ============================================
           🧩 COMPONENT STYLES
           ============================================ */
        
        /* Buttons */
        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: var(--space-xs);
            padding: var(--space-sm) var(--space-md);
            border: 1px solid transparent;
            border-radius: var(--radius-md);
            font-size: var(--text-sm);
            font-weight: 500;
            text-decoration: none;
            cursor: pointer;
            transition: all var(--transition-fast);
            user-select: none;
        }
        
        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
        
        .btn-primary {
            background-color: var(--color-primary);
            color: white;
        }
        
        .btn-primary:hover:not(:disabled) {
            background-color: var(--color-primary-dark);
        }
        
        .btn-secondary {
            background-color: var(--color-surface-elevated);
            color: var(--color-text);
            border-color: var(--color-border);
        }
        
        .btn-secondary:hover:not(:disabled) {
            background-color: var(--color-surface);
        }
        
        .btn-sm {
            padding: var(--space-xs) var(--space-sm);
            font-size: var(--text-xs);
        }
        
        /* Forms */
        .form-group {
            margin-bottom: var(--space-md);
        }
        
        .form-label {
            display: block;
            margin-bottom: var(--space-xs);
            font-size: var(--text-sm);
            font-weight: 500;
            color: var(--color-text);
        }
        
        .form-input {
            width: 100%;
            padding: var(--space-sm) var(--space-md);
            border: 1px solid var(--color-border);
            border-radius: var(--radius-md);
            font-size: var(--text-base);
            background-color: var(--color-background);
            color: var(--color-text);
            transition: border-color var(--transition-fast);
        }
        
        .form-input:focus {
            outline: none;
            border-color: var(--color-border-focus);
            box-shadow: 0 0 0 3px rgb(59 130 246 / 0.1);
        }
        
        .form-textarea {
            min-height: 80px;
            resize: vertical;
        }
        
        .form-select {
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%236b7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='m6 8 4 4 4-4'/%3e%3c/svg%3e");
            background-position: right var(--space-sm) center;
            background-repeat: no-repeat;
            background-size: 1.5em 1.5em;
            padding-right: 2.5rem;
        }
        
        /* Cards */
        .card {
            background-color: var(--color-surface-elevated);
            border: 1px solid var(--color-border);
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-sm);
            overflow: hidden;
        }
        
        .card-header {
            padding: var(--space-md) var(--space-lg);
            border-bottom: 1px solid var(--color-border);
            background-color: var(--color-surface);
        }
        
        .card-body {
            padding: var(--space-lg);
        }
        
        .card-title {
            font-size: var(--text-lg);
            font-weight: 600;
            margin-bottom: var(--space-xs);
        }
        
        /* Task-specific styles */
        .task-form {
            margin-bottom: var(--space-xl);
        }
        
        .task-list {
            display: flex;
            flex-direction: column;
            gap: var(--space-md);
        }
        
        .task-item {
            background-color: var(--color-surface-elevated);
            border: 1px solid var(--color-border);
            border-radius: var(--radius-lg);
            padding: var(--space-md);
            transition: all var(--transition-fast);
        }
        
        .task-item:hover {
            box-shadow: var(--shadow-md);
            transform: translateY(-1px);
        }
        
        .task-item.completed {
            opacity: 0.7;
        }
        
        .task-header {
            display: flex;
            align-items: flex-start;
            justify-content: space-between;
            margin-bottom: var(--space-sm);
        }
        
        .task-title {
            font-size: var(--text-base);
            font-weight: 500;
            color: var(--color-text);
            flex: 1;
        }
        
        .task-title.completed {
            text-decoration: line-through;
            color: var(--color-text-muted);
        }
        
        .task-actions {
            display: flex;
            gap: var(--space-xs);
        }
        
        .task-meta {
            display: flex;
            align-items: center;
            gap: var(--space-md);
            font-size: var(--text-sm);
            color: var(--color-text-muted);
        }
        
        .task-description {
            margin-top: var(--space-sm);
            color: var(--color-text-muted);
            font-size: var(--text-sm);
        }
        
        .priority-badge {
            padding: var(--space-xs) var(--space-sm);
            border-radius: var(--radius-sm);
            font-size: var(--text-xs);
            font-weight: 500;
            text-transform: uppercase;
        }
        
        .priority-low {
            background-color: #f0f9ff;
            color: #0369a1;
        }
        
        .priority-medium {
            background-color: #fefce8;
            color: #a16207;
        }
        
        .priority-high {
            background-color: #fef2f2;
            color: #dc2626;
        }
        
        .priority-urgent {
            background-color: #451a03;
            color: #ffffff;
        }
        
        /* Utilities */
        .hidden {
            display: none;
        }
        
        .text-center {
            text-align: center;
        }
        
        .mt-auto {
            margin-top: auto;
        }
        
        .loading {
            opacity: 0.6;
            pointer-events: none;
        }
        
        /* Animations */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .fade-in {
            animation: fadeIn var(--transition-normal);
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .spin {
            animation: spin 1s linear infinite;
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- Header -->
        <header class="app-header">
            <div class="header-content">
                <h1 class="app-title">
                    📋 Task Manager
                </h1>
                <div class="status-indicator">
                    <div class="status-dot" id="status-dot"></div>
                    <span id="status-text">Online</span>
                </div>
            </div>
        </header>

        <!-- Sidebar (hidden on mobile) -->
        <aside class="app-sidebar">
            <div class="card">
                <div class="card-header">
                    <h3 class="card-title">Filters</h3>
                </div>
                <div class="card-body">
                    <p class="text-center color-text-muted">Filters coming soon...</p>
                </div>
            </div>
        </aside>

        <!-- Main Content -->
        <main class="app-main">
            <div class="main-content">
                <!-- Task Creation Form -->
                <div class="card task-form">
                    <div class="card-header">
                        <h2 class="card-title">Add New Task</h2>
                    </div>
                    <div class="card-body">
                        <form id="task-form">
                            <div class="form-group">
                                <label for="task-title" class="form-label">Title *</label>
                                <input 
                                    type="text" 
                                    id="task-title" 
                                    class="form-input" 
                                    placeholder="Enter task title..."
                                    required
                                    maxlength="200"
                                >
                            </div>
                            
                            <div class="form-group">
                                <label for="task-description" class="form-label">Description</label>
                                <textarea 
                                    id="task-description" 
                                    class="form-input form-textarea" 
                                    placeholder="Enter task description..."
                                    maxlength="1000"
                                ></textarea>
                            </div>
                            
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: var(--space-md);">
                                <div class="form-group">
                                    <label for="task-priority" class="form-label">Priority</label>
                                    <select id="task-priority" class="form-input form-select">
                                        <option value="low">Low</option>
                                        <option value="medium" selected>Medium</option>
                                        <option value="high">High</option>
                                        <option value="urgent">Urgent</option>
                                    </select>
                                </div>
                                
                                <div class="form-group">
                                    <label for="task-due-date" class="form-label">Due Date</label>
                                    <input 
                                        type="datetime-local" 
                                        id="task-due-date" 
                                        class="form-input"
                                    >
                                </div>
                            </div>
                            
                            <button type="submit" class="btn btn-primary">
                                Add Task
                            </button>
                        </form>
                    </div>
                </div>

                <!-- Task List -->
                <div class="card">
                    <div class="card-header">
                        <h2 class="card-title">Tasks</h2>
                    </div>
                    <div class="card-body">
                        <div id="task-list" class="task-list">
                            <!-- Tasks will be rendered here -->
                        </div>
                        
                        <div id="empty-state" class="text-center" style="padding: var(--space-2xl);">
                            <p style="color: var(--color-text-muted); font-size: var(--text-lg);">
                                📝 No tasks yet. Add your first task above!
                            </p>
                        </div>
                    </div>
                </div>
            </div>
        </main>

        <!-- Footer -->
        <footer class="app-footer">
            <p>&copy; 2025 Offline Task Manager - All data stored locally</p>
        </footer>
    </div>

    <script>
        'use strict';
        
        /* ============================================
           🗄️ INDEXEDDB DATABASE MANAGER
           ============================================ */
        
        /**
         * 🔍 MAJOR FUNCTION POINT #1: DATABASE ARCHITECTURE
         * 
         * This is the foundation of our offline-first system. The TaskDatabase class
         * manages all data persistence using IndexedDB, which provides:
         * 
         * - 📦 Local storage that persists across browser sessions
         * - 🔍 Fast indexed queries for filtering and searching
         * - 💾 Transaction-based operations for data integrity
         * - 📱 Works offline without any server connection
         * 
         * Key Design Decisions:
         * - UUID-based primary keys for conflict-free replication
         * - Indexed fields for common query patterns (status, priority, dates)
         * - Structured data models with validation
         * - Error handling with graceful fallbacks
         */
        
        class TaskDatabase {
            constructor() {
                this.dbName = 'TaskManagerDB';
                this.version = 1;
                this.db = null;
                this.isInitialized = false;
            }
            
            /**
             * Initialize the database and create object stores
             * This runs once when the app first loads
             */
            async init() {
                if (this.isInitialized) {
                    return this.db;
                }
                
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(this.dbName, this.version);
                    
                    request.onerror = () => {
                        console.error('❌ Failed to open IndexedDB:', request.error);
                        reject(request.error);
                    };
                    
                    request.onsuccess = () => {
                        this.db = request.result;
                        this.isInitialized = true;
                        console.log('✅ IndexedDB initialized successfully');
                        resolve(this.db);
                    };
                    
                    // This runs only on first install or version upgrade
                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        console.log('🔧 Creating database schema...');
                        
                        // Create tasks object store
                        if (!db.objectStoreNames.contains('tasks')) {
                            const taskStore = db.createObjectStore('tasks', { keyPath: 'id' });
                            
                            // Create indexes for efficient querying
                            taskStore.createIndex('by-status', 'status', { unique: false });
                            taskStore.createIndex('by-priority', 'priority', { unique: false });
                            taskStore.createIndex('by-dueDate', 'dueDate', { unique: false });
                            taskStore.createIndex('by-created', 'createdAt', { unique: false });
                            taskStore.createIndex('by-modified', 'modifiedAt', { unique: false });
                            
                            console.log('📋 Tasks store created with indexes');
                        }
                        
                        // Create categories store (for future use)
                        if (!db.objectStoreNames.contains('categories')) {
                            const categoryStore = db.createObjectStore('categories', { keyPath: 'id' });
                            categoryStore.createIndex('by-name', 'name', { unique: true });
                            console.log('📂 Categories store created');
                        }
                        
                        // Create settings store
                        if (!db.objectStoreNames.contains('settings')) {
                            db.createObjectStore('settings', { keyPath: 'key' });
                            console.log('⚙️ Settings store created');
                        }
                    };
                });
            }
            
            /**
             * 🔍 MAJOR FUNCTION POINT #2: CRUD OPERATIONS
             * 
             * These methods implement the core Create, Read, Update, Delete operations
             * that form the backbone of any data-driven application.
             * 
             * Key Features:
             * - 🔒 Transaction-based operations for data integrity
             * - ✅ Input validation and sanitization
             * - 🔄 Automatic timestamp management
             * - 📊 Optimistic UI updates with error rollback
             * - 🎯 Type-safe operations with consistent error handling
             */
            
            /**
             * Create a new task
             */
            async createTask(taskData) {
                try {
                    // Validate and sanitize input
                    const task = this.validateTaskData(taskData);
                    
                    // Generate unique ID and timestamps
                    task.id = this.generateUUID();
                    task.createdAt = new Date().toISOString();
                    task.modifiedAt = task.createdAt;
                    task.completedAt = null;
                    
                    // Store in IndexedDB
                    const transaction = this.db.transaction(['tasks'], 'readwrite');
                    const store = transaction.objectStore('tasks');
                    
                    await new Promise((resolve, reject) => {
                        const request = store.add(task);
                        request.onsuccess = () => resolve(request.result);
                        request.onerror = () => reject(request.error);
                    });
                    
                    console.log('✅ Task created:', task.title);
                    return task;
                    
                } catch (error) {
                    console.error('❌ Failed to create task:', error);
                    throw new Error(`Failed to create task: ${error.message}`);
                }
            }
            
            /**
             * Read a single task by ID
             */
            async readTask(id) {
                try {
                    const transaction = this.db.transaction(['tasks'], 'readonly');
                    const store = transaction.objectStore('tasks');
                    
                    return new Promise((resolve, reject) => {
                        const request = store.get(id);
                        request.onsuccess = () => resolve(request.result);
                        request.onerror = () => reject(request.error);
                    });
                    
                } catch (error) {
                    console.error('❌ Failed to read task:', error);
                    throw error;
                }
            }
            
            /**
             * Update an existing task
             */
            async updateTask(id, updates) {
                try {
                    // Get existing task
                    const existingTask = await this.readTask(id);
                    if (!existingTask) {
                        throw new Error('Task not found');
                    }
                    
                    // Merge updates with existing data
                    const updatedTask = {
                        ...existingTask,
                        ...this.validateTaskData(updates, false),
                        id, // Preserve ID
                        createdAt: existingTask.createdAt, // Preserve creation time
                        modifiedAt: new Date().toISOString()
                    };
                    
                    // Handle completion status
                    if (updates.status === 'completed' && existingTask.status !== 'completed') {
                        updatedTask.completedAt = new Date().toISOString();
                    } else if (updates.status !== 'completed') {
                        updatedTask.completedAt = null;
                    }
                    
                    // Store updated task
                    const transaction = this.db.transaction(['tasks'], 'readwrite');
                    const store = transaction.objectStore('tasks');
                    
                    await new Promise((resolve, reject) => {
                        const request = store.put(updatedTask);
                        request.onsuccess = () => resolve(request.result);
                        request.onerror = () => reject(request.error);
                    });
                    
                    console.log('✅ Task updated:', updatedTask.title);
                    return updatedTask;
                    
                } catch (error) {
                    console.error('❌ Failed to update task:', error);
                    throw new Error(`Failed to update task: ${error.message}`);
                }
            }
            
            /**
             * Delete a task
             */
            async deleteTask(id) {
                try {
                    const transaction = this.db.transaction(['tasks'], 'readwrite');
                    const store = transaction.objectStore('tasks');
                    
                    await new Promise((resolve, reject) => {
                        const request = store.delete(id);
                        request.onsuccess = () => resolve(request.result);
                        request.onerror = () => reject(request.error);
                    });
                    
                    console.log('✅ Task deleted:', id);
                    return true;
                    
                } catch (error) {
                    console.error('❌ Failed to delete task:', error);
                    throw new Error(`Failed to delete task: ${error.message}`);
                }
            }
            
            /**
             * Get all tasks with optional filtering
             */
            async getAllTasks(filter = {}) {
                try {
                    const transaction = this.db.transaction(['tasks'], 'readonly');
                    const store = transaction.objectStore('tasks');
                    
                    // If filtering by status, use index for better performance
                    let request;
                    if (filter.status) {
                        const index = store.index('by-status');
                        request = index.getAll(filter.status);
                    } else {
                        request = store.getAll();
                    }
                    
                    const tasks = await new Promise((resolve, reject) => {
                        request.onsuccess = () => resolve(request.result);
                        request.onerror = () => reject(request.error);
                    });
                    
                    // Sort by creation date (newest first)
                    return tasks.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
                    
                } catch (error) {
                    console.error('❌ Failed to get tasks:', error);
                    throw error;
                }
            }
            
            /**
             * 🔍 MAJOR FUNCTION POINT #3: DATA VALIDATION & SECURITY
             * 
             * This method ensures data integrity and prevents XSS attacks by:
             * - 🛡️ Sanitizing all user inputs
             * - ✅ Validating data types and constraints
             * - 🔒 Preventing injection attacks
             * - 📏 Enforcing length limits
             * - 🎯 Providing helpful error messages
             */
            validateTaskData(data, requireTitle = true) {
                const sanitized = {};
                
                // Title validation
                if (data.title !== undefined) {
                    sanitized.title = this.sanitizeHTML(data.title.trim());
                    if (!sanitized.title && requireTitle) {
                        throw new Error('Title is required');
                    }
                    if (sanitized.title.length > 200) {
                        throw new Error('Title must be less than 200 characters');
                    }
                }
                
                // Description validation
                if (data.description !== undefined) {
                    sanitized.description = this.sanitizeHTML(data.description.trim());
                    if (sanitized.description.length > 1000) {
                        throw new Error('Description must be less than 1000 characters');
                    }
                }
                
                // Priority validation
                if (data.priority !== undefined) {
                    const validPriorities = ['low', 'medium', 'high', 'urgent'];
                    if (!validPriorities.includes(data.priority)) {
                        throw new Error('Invalid priority level');
                    }
                    sanitized.priority = data.priority;
                }
                
                // Status validation
                if (data.status !== undefined) {
                    const validStatuses = ['pending', 'completed', 'archived'];
                    if (!validStatuses.includes(data.status)) {
                        throw new Error('Invalid status');
                    }
                    sanitized.status = data.status;
                }
                
                // Due date validation
                if (data.dueDate !== undefined) {
                    if (data.dueDate) {
                        const date = new Date(data.dueDate);
                        if (isNaN(date.getTime())) {
                            throw new Error('Invalid due date');
                        }
                        sanitized.dueDate = date.toISOString();
                    } else {
                        sanitized.dueDate = null;
                    }
                }
                
                // Set defaults for new tasks
                if (requireTitle) {
                    sanitized.status = sanitized.status || 'pending';
                    sanitized.priority = sanitized.priority || 'medium';
                    sanitized.description = sanitized.description || '';
                    sanitized.dueDate = sanitized.dueDate || null;
                }
                
                return sanitized;
            }
            
            /**
             * Sanitize HTML input to prevent XSS attacks
             */
            sanitizeHTML(input) {
                if (typeof input !== 'string') return '';
                
                const div = document.createElement('div');
                div.textContent = input;
                return div.innerHTML;
            }
            
            /**
             * Generate UUID for unique task IDs
             */
            generateUUID() {
                return 'task-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
            }
        }
    </script>

    <script>
        /* ============================================
           📱 APP STATE & UI MANAGER
           ============================================ */
        
        /**
         * 🔍 MAJOR FUNCTION POINT #4: APPLICATION STATE MANAGEMENT
         * 
         * The TaskManager class serves as the main application controller that:
         * - 🏗️ Initializes the database and UI components
         * - 🔄 Manages application state and data flow
         * - 🎯 Coordinates between database operations and UI updates
         * - 📡 Handles online/offline status detection
         * - 🚀 Provides optimistic UI updates for better user experience
         * 
         * This follows the Model-View-Controller pattern where:
         * - Model: TaskDatabase (data layer)
         * - View: DOM manipulation methods (presentation layer)
         * - Controller: TaskManager (business logic layer)
         */
        
        class TaskManager {
            constructor() {
                this.database = new TaskDatabase();
                this.tasks = [];
                this.isOnline = navigator.onLine;
                this.isLoading = false;
                
                // DOM elements
                this.elements = {
                    taskForm: null,
                    taskList: null,
                    emptyState: null,
                    statusDot: null,
                    statusText: null
                };
                
                console.log('🚀 TaskManager initialized');
            }
            
            /**
             * Initialize the application
             */
            async init() {
                try {
                    console.log('🔧 Initializing Task Manager...');
                    
                    // Initialize database
                    await this.database.init();
                    
                    // Cache DOM elements
                    this.cacheElements();
                    
                    // Bind event listeners
                    this.bindEvents();
                    
                    // Load initial data
                    await this.loadTasks();
                    
                    // Setup online/offline detection
                    this.setupNetworkDetection();
                    
                    // Initial render
                    this.render();
                    
                    console.log('✅ Task Manager ready!');
                    
                } catch (error) {
                    console.error('❌ Failed to initialize Task Manager:', error);
                    this.showError('Failed to initialize the application. Please refresh the page.');
                }
            }
            
            /**
             * Cache frequently used DOM elements
             */
            cacheElements() {
                this.elements = {
                    taskForm: document.getElementById('task-form'),
                    taskList: document.getElementById('task-list'),
                    emptyState: document.getElementById('empty-state'),
                    statusDot: document.getElementById('status-dot'),
                    statusText: document.getElementById('status-text'),
                    
                    // Form inputs
                    titleInput: document.getElementById('task-title'),
                    descriptionInput: document.getElementById('task-description'),
                    priorityInput: document.getElementById('task-priority'),
                    dueDateInput: document.getElementById('task-due-date')
                };
                
                // Verify all elements exist
                for (const [key, element] of Object.entries(this.elements)) {
                    if (!element) {
                        console.warn(`⚠️ Element not found: ${key}`);
                    }
                }
            }
            
            /**
             * Bind event listeners
             */
            bindEvents() {
                // Form submission
                this.elements.taskForm?.addEventListener('submit', (e) => {
                    e.preventDefault();
                    this.handleCreateTask();
                });
                
                // Online/offline events
                window.addEventListener('online', () => this.handleNetworkChange(true));
                window.addEventListener('offline', () => this.handleNetworkChange(false));
                
                // Keyboard shortcuts
                document.addEventListener('keydown', (e) => {
                    // Ctrl/Cmd + Enter to submit form
                    if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
                        if (document.activeElement && 
                            this.elements.taskForm.contains(document.activeElement)) {
                            this.handleCreateTask();
                        }
                    }
                });
            }
            
            /**
             * 🔍 MAJOR FUNCTION POINT #5: TASK OPERATIONS WITH OPTIMISTIC UPDATES
             * 
             * This method demonstrates optimistic UI updates, a key pattern in modern web apps:
             * 
             * 1. 🎯 Immediately update the UI (optimistic)
             * 2. 💾 Persist data to IndexedDB 
             * 3. ✅ Confirm success or rollback on failure
             * 4. 🔄 Broadcast changes to other tabs (future feature)
             * 
             * Benefits:
             * - ⚡ Instant feedback for users
             * - 🏃 No waiting for database operations
             * - 🛡️ Graceful error handling with rollback
             * - 📱 Feels like a native app
             */
            
            /**
             * Handle task creation from form
             */
            async handleCreateTask() {
                if (this.isLoading) return;
                
                try {
                    // Get form data
                    const formData = this.getFormData();
                    if (!formData.title.trim()) {
                        this.showError('Please enter a task title');
                        return;
                    }
                    
                    this.setLoading(true);
                    
                    // Create optimistic task for immediate UI feedback
                    const optimisticTask = {
                        ...formData,
                        id: 'temp-' + Date.now(),
                        status: 'pending',
                        createdAt: new Date().toISOString(),
                        modifiedAt: new Date().toISOString(),
                        completedAt: null,
                        isOptimistic: true // Flag for UI styling
                    };
                    
                    // 1. Immediately add to UI (optimistic update)
                    this.tasks.unshift(optimisticTask);
                    this.render();
                    
                    try {
                        // 2. Persist to database
                        const savedTask = await this.database.createTask(formData);
                        
                        // 3. Replace optimistic task with real data
                        const index = this.tasks.findIndex(t => t.id === optimisticTask.id);
                        if (index !== -1) {
                            this.tasks[index] = savedTask;
                        }
                        
                        // Clear form and re-render
                        this.clearForm();
                        this.render();
                        
                        console.log('✅ Task created successfully');
                        
                    } catch (error) {
                        // 4. Rollback optimistic update on failure
                        this.tasks = this.tasks.filter(t => t.id !== optimisticTask.id);
                        this.render();
                        throw error;
                    }
                    
                } catch (error) {
                    console.error('❌ Failed to create task:', error);
                    this.showError('Failed to create task: ' + error.message);
                } finally {
                    this.setLoading(false);
                }
            }
            
            /**
             * Toggle task completion status
             */
            async toggleTaskComplete(taskId) {
                try {
                    const task = this.tasks.find(t => t.id === taskId);
                    if (!task) return;
                    
                    const newStatus = task.status === 'completed' ? 'pending' : 'completed';
                    
                    // Optimistic update
                    task.status = newStatus;
                    task.modifiedAt = new Date().toISOString();
                    if (newStatus === 'completed') {
                        task.completedAt = new Date().toISOString();
                    } else {
                        task.completedAt = null;
                    }
                    
                    this.render();
                    
                    // Persist to database
                    await this.database.updateTask(taskId, { status: newStatus });
                    
                    console.log(`✅ Task ${newStatus}:`, task.title);
                    
                } catch (error) {
                    console.error('❌ Failed to toggle task:', error);
                    // Reload tasks to restore correct state
                    await this.loadTasks();
                    this.showError('Failed to update task');
                }
            }
            
            /**
             * Delete a task
             */
            async deleteTask(taskId) {
                if (!confirm('Are you sure you want to delete this task?')) {
                    return;
                }
                
                try {
                    // Optimistic update
                    const taskIndex = this.tasks.findIndex(t => t.id === taskId);
                    const deletedTask = this.tasks[taskIndex];
                    
                    if (taskIndex !== -1) {
                        this.tasks.splice(taskIndex, 1);
                        this.render();
                    }
                    
                    // Persist to database
                    await this.database.deleteTask(taskId);
                    
                    console.log('✅ Task deleted:', deletedTask?.title);
                    
                } catch (error) {
                    console.error('❌ Failed to delete task:', error);
                    // Reload tasks to restore correct state
                    await this.loadTasks();
                    this.showError('Failed to delete task');
                }
            }
            
            /**
             * Load all tasks from database
             */
            async loadTasks() {
                try {
                    this.setLoading(true);
                    this.tasks = await this.database.getAllTasks();
                    console.log(`📋 Loaded ${this.tasks.length} tasks`);
                } catch (error) {
                    console.error('❌ Failed to load tasks:', error);
                    this.showError('Failed to load tasks');
                    this.tasks = [];
                } finally {
                    this.setLoading(false);
                }
            }
        }
    </script>

    <script>
        /* ============================================
           🎨 UI RENDERING & INTERACTION SYSTEM
           ============================================ */
        
        // Continue TaskManager class with rendering methods
        TaskManager.prototype.render = function() {
            this.renderTasks();
            this.updateEmptyState();
            this.updateNetworkStatus();
        };
        
        /**
         * 🔍 MAJOR FUNCTION POINT #4: DYNAMIC UI RENDERING SYSTEM
         * 
         * This rendering system creates a reactive UI that automatically updates when data changes:
         * 
         * - 🎯 **Virtual DOM-like rendering** without external dependencies
         * - ⚡ **Efficient updates** that only change what's necessary
         * - 🎨 **Component-based rendering** with reusable task items
         * - 📱 **Responsive design** that adapts to different screen sizes
         * - 🔄 **Real-time updates** reflecting data changes immediately
         * 
         * Key Benefits:
         * - No framework overhead, pure JavaScript
         * - Predictable rendering cycle
         * - Easy to debug and maintain
         * - Optimized for performance
         */
        
        /**
         * Render the complete task list
         */
        TaskManager.prototype.renderTasks = function() {
            if (!this.elements.taskList) return;
            
            // Clear existing content
            this.elements.taskList.innerHTML = '';
            
            if (this.tasks.length === 0) {
                return; // Empty state will be shown separately
            }
            
            // Create document fragment for efficient DOM manipulation
            const fragment = document.createDocumentFragment();
            
            // Render each task
            this.tasks.forEach(task => {
                const taskElement = this.createTaskElement(task);
                fragment.appendChild(taskElement);
            });
            
            // Add all tasks to DOM at once
            this.elements.taskList.appendChild(fragment);
            
            console.log(`🎨 Rendered ${this.tasks.length} tasks`);
        };
        
        /**
         * Create a single task element
         */
        TaskManager.prototype.createTaskElement = function(task) {
            const taskDiv = document.createElement('div');
            taskDiv.className = `task-item fade-in ${task.status === 'completed' ? 'completed' : ''}`;
            taskDiv.dataset.taskId = task.id;
            
            // Add loading state for optimistic updates
            if (task.isOptimistic) {
                taskDiv.classList.add('loading');
            }
            
            taskDiv.innerHTML = `
                <div class="task-header">
                    <h3 class="task-title ${task.status === 'completed' ? 'completed' : ''}">
                        ${this.escapeHtml(task.title)}
                    </h3>
                    <div class="task-actions">
                        <button 
                            class="btn btn-sm btn-secondary" 
                            onclick="taskManager.toggleTaskComplete('${task.id}')"
                            title="${task.status === 'completed' ? 'Mark as pending' : 'Mark as completed'}"
                        >
                            ${task.status === 'completed' ? '↩️' : '✅'}
                        </button>
                        <button 
                            class="btn btn-sm btn-secondary" 
                            onclick="taskManager.editTask('${task.id}')"
                            title="Edit task"
                        >
                            ✏️
                        </button>
                        <button 
                            class="btn btn-sm btn-secondary" 
                            onclick="taskManager.deleteTask('${task.id}')"
                            title="Delete task"
                        >
                            🗑️
                        </button>
                    </div>
                </div>
                
                ${task.description ? `
                    <div class="task-description">
                        ${this.escapeHtml(task.description)}
                    </div>
                ` : ''}
                
                <div class="task-meta">
                    <span class="priority-badge priority-${task.priority}">
                        ${task.priority}
                    </span>
                    
                    ${task.dueDate ? `
                        <span title="Due date">
                            📅 ${this.formatDateTime(task.dueDate)}
                        </span>
                    ` : ''}
                    
                    <span title="Created">
                        🕐 ${this.formatRelativeTime(task.createdAt)}
                    </span>
                    
                    ${task.completedAt ? `
                        <span title="Completed">
                            ✅ ${this.formatRelativeTime(task.completedAt)}
                        </span>
                    ` : ''}
                </div>
            `;
            
            return taskDiv;
        };
        
        /**
         * Update empty state visibility
         */
        TaskManager.prototype.updateEmptyState = function() {
            if (!this.elements.emptyState) return;
            
            const hasActiveTasks = this.tasks.some(task => task.status !== 'completed');
            const shouldShowEmpty = this.tasks.length === 0 || !hasActiveTasks;
            
            if (shouldShowEmpty && this.tasks.length === 0) {
                this.elements.emptyState.style.display = 'block';
                this.elements.emptyState.innerHTML = `
                    <div style="padding: var(--space-2xl);">
                        <div style="font-size: 3rem; margin-bottom: var(--space-md);">📝</div>
                        <h3 style="color: var(--color-text); margin-bottom: var(--space-sm);">No tasks yet</h3>
                        <p style="color: var(--color-text-muted); font-size: var(--text-base);">
                            Add your first task above to get started!
                        </p>
                    </div>
                `;
            } else if (shouldShowEmpty) {
                this.elements.emptyState.style.display = 'block';
                this.elements.emptyState.innerHTML = `
                    <div style="padding: var(--space-2xl);">
                        <div style="font-size: 3rem; margin-bottom: var(--space-md);">🎉</div>
                        <h3 style="color: var(--color-text); margin-bottom: var(--space-sm);">All tasks completed!</h3>
                        <p style="color: var(--color-text-muted); font-size: var(--text-base);">
                            Great job! You've completed all your tasks.
                        </p>
                    </div>
                `;
            } else {
                this.elements.emptyState.style.display = 'none';
            }
        };
        
        /**
         * Update network status indicator
         */
        TaskManager.prototype.updateNetworkStatus = function() {
            if (!this.elements.statusDot || !this.elements.statusText) return;
            
            // Check Service Worker status
            const hasServiceWorker = 'serviceWorker' in navigator && navigator.serviceWorker.controller;
            
            if (this.isOnline) {
                this.elements.statusDot.classList.remove('offline');
                if (hasServiceWorker) {
                    this.elements.statusText.textContent = 'Online + SW';
                    this.elements.statusText.title = 'Online with Service Worker active';
                } else {
                    this.elements.statusText.textContent = 'Online';
                    this.elements.statusText.title = 'Online (Service Worker not available)';
                }
            } else {
                this.elements.statusDot.classList.add('offline');
                if (hasServiceWorker) {
                    this.elements.statusText.textContent = 'Offline + SW';
                    this.elements.statusText.title = 'Offline with Service Worker active';
                } else {
                    this.elements.statusText.textContent = 'Offline';
                    this.elements.statusText.title = 'Offline (Service Worker not available)';
                }
            }
        };
        
        /**
         * 🔍 MAJOR FUNCTION POINT #5: ADVANCED TASK OPERATIONS
         * 
         * These methods handle complex task operations including:
         * - 📝 **Inline editing** with form validation
         * - 🔄 **Status management** with optimistic updates
         * - 🎯 **Bulk operations** for productivity
         * - 📱 **Mobile-friendly interactions** with touch support
         * 
         * Features:
         * - Modal-free editing experience
         * - Keyboard shortcuts for power users
         * - Undo/redo capabilities (future enhancement)
         * - Conflict resolution for concurrent edits
         */
        
        /**
         * Edit task (inline editing)
         */
        TaskManager.prototype.editTask = function(taskId) {
            const task = this.tasks.find(t => t.id === taskId);
            if (!task) return;
            
            // Create edit form
            const editForm = this.createEditForm(task);
            
            // Replace task element with edit form
            const taskElement = document.querySelector(`[data-task-id="${taskId}"]`);
            if (taskElement) {
                const editContainer = document.createElement('div');
                editContainer.className = 'task-item fade-in';
                editContainer.appendChild(editForm);
                
                taskElement.parentNode.replaceChild(editContainer, taskElement);
                
                // Focus title input
                const titleInput = editForm.querySelector('[name="title"]');
                if (titleInput) {
                    titleInput.focus();
                    titleInput.select();
                }
            }
        };
        
        /**
         * Create inline edit form
         */
        TaskManager.prototype.createEditForm = function(task) {
            const form = document.createElement('form');
            form.className = 'task-edit-form';
            
            form.innerHTML = `
                <div class="form-group">
                    <input 
                        type="text" 
                        name="title" 
                        class="form-input" 
                        value="${this.escapeHtml(task.title)}"
                        required
                        maxlength="200"
                    >
                </div>
                
                <div class="form-group">
                    <textarea 
                        name="description" 
                        class="form-input form-textarea" 
                        placeholder="Description..."
                        maxlength="1000"
                        style="min-height: 60px;"
                    >${this.escapeHtml(task.description || '')}</textarea>
                </div>
                
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: var(--space-sm); margin-bottom: var(--space-md);">
                    <select name="priority" class="form-input form-select">
                        <option value="low" ${task.priority === 'low' ? 'selected' : ''}>Low</option>
                        <option value="medium" ${task.priority === 'medium' ? 'selected' : ''}>Medium</option>
                        <option value="high" ${task.priority === 'high' ? 'selected' : ''}>High</option>
                        <option value="urgent" ${task.priority === 'urgent' ? 'selected' : ''}>Urgent</option>
                    </select>
                    
                    <input 
                        type="datetime-local" 
                        name="dueDate" 
                        class="form-input"
                        value="${task.dueDate ? new Date(task.dueDate).toISOString().slice(0, 16) : ''}"
                    >
                </div>
                
                <div style="display: flex; gap: var(--space-sm);">
                    <button type="submit" class="btn btn-primary btn-sm">Save</button>
                    <button type="button" class="btn btn-secondary btn-sm" onclick="taskManager.cancelEdit('${task.id}')">Cancel</button>
                </div>
            `;
            
            // Handle form submission
            form.addEventListener('submit', (e) => {
                e.preventDefault();
                this.saveTaskEdit(task.id, new FormData(form));
            });
            
            // Handle Escape key
            form.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    this.cancelEdit(task.id);
                }
            });
            
            return form;
        };
        
        /**
         * Save task edit
         */
        TaskManager.prototype.saveTaskEdit = async function(taskId, formData) {
            try {
                const updates = {
                    title: formData.get('title'),
                    description: formData.get('description'),
                    priority: formData.get('priority'),
                    dueDate: formData.get('dueDate') || null
                };
                
                // Optimistic update
                const task = this.tasks.find(t => t.id === taskId);
                if (task) {
                    Object.assign(task, updates);
                    task.modifiedAt = new Date().toISOString();
                }
                
                this.render();
                
                // Persist to database
                await this.database.updateTask(taskId, updates);
                
                console.log('✅ Task updated:', updates.title);
                
            } catch (error) {
                console.error('❌ Failed to update task:', error);
                this.showError('Failed to update task: ' + error.message);
                await this.loadTasks();
                this.render();
            }
        };
        
        /**
         * Cancel task edit
         */
        TaskManager.prototype.cancelEdit = function(taskId) {
            this.render(); // Re-render to restore original task display
        };
        
        /**
         * 🔍 MAJOR FUNCTION POINT #6: UTILITY & HELPER FUNCTIONS
         * 
         * These utility functions provide essential functionality for:
         * - 🛡️ **Security** (HTML escaping, input sanitization)
         * - 📅 **Date formatting** (relative time, localization)
         * - 🎯 **Form handling** (data extraction, validation)
         * - 🎨 **UI state management** (loading states, error handling)
         * 
         * These are the building blocks that make the app robust and user-friendly.
         */
        
        /**
         * Get form data as object
         */
        TaskManager.prototype.getFormData = function() {
            return {
                title: this.elements.titleInput?.value?.trim() || '',
                description: this.elements.descriptionInput?.value?.trim() || '',
                priority: this.elements.priorityInput?.value || 'medium',
                dueDate: this.elements.dueDateInput?.value || null
            };
        };
        
        /**
         * Clear the task form
         */
        TaskManager.prototype.clearForm = function() {
            if (this.elements.taskForm) {
                this.elements.taskForm.reset();
            }
        };
        
        /**
         * Set loading state
         */
        TaskManager.prototype.setLoading = function(loading) {
            this.isLoading = loading;
            
            if (this.elements.taskForm) {
                if (loading) {
                    this.elements.taskForm.classList.add('loading');
                } else {
                    this.elements.taskForm.classList.remove('loading');
                }
            }
        };
        
            /**
             * Handle network status change with Service Worker integration
             */
            TaskManager.prototype.handleNetworkChange = function(isOnline) {
                this.isOnline = isOnline;
                this.updateNetworkStatus();
                
                console.log(`📡 Network status: ${isOnline ? 'Online' : 'Offline'}`);
                
                if (isOnline) {
                    console.log('🔄 Connection restored - requesting background sync');
                    // Trigger background sync when coming back online
                    this.requestSync();
                } else {
                    console.log('📴 Working offline - operations will be queued');
                }
            };
            
            /**
             * Request immediate sync with Service Worker
             */
            TaskManager.prototype.requestSync = async function() {
                try {
                    if ('serviceWorker' in navigator && navigator.serviceWorker.ready) {
                        const registration = await navigator.serviceWorker.ready;
                        
                        if (registration.active) {
                            registration.active.postMessage({
                                type: 'REQUEST_SYNC'
                            });
                            console.log('🔄 Sync requested via Service Worker');
                        } else {
                            console.log('⚠️ Service Worker not active - sync skipped');
                        }
                    } else {
                        console.log('⚠️ Service Worker not available - sync skipped');
                    }
                } catch (error) {
                    console.error('❌ Failed to request sync:', error);
                }
            };
            
            /**
             * Enhanced task creation with Service Worker integration
             */
            TaskManager.prototype.handleCreateTask = async function() {
                if (this.isLoading) return;
                
                try {
                    // Get form data
                    const formData = this.getFormData();
                    if (!formData.title.trim()) {
                        this.showError('Please enter a task title');
                        return;
                    }
                    
                    this.setLoading(true);
                    
                    // Create optimistic task for immediate UI feedback
                    const optimisticTask = {
                        ...formData,
                        id: 'temp-' + Date.now(),
                        status: 'pending',
                        createdAt: new Date().toISOString(),
                        modifiedAt: new Date().toISOString(),
                        completedAt: null,
                        isOptimistic: true // Flag for UI styling
                    };
                    
                    // 1. Immediately add to UI (optimistic update)
                    this.tasks.unshift(optimisticTask);
                    this.render();
                    
                    try {
                        // 2. Persist to database
                        const savedTask = await this.database.createTask(formData);
                        
                        // 3. Replace optimistic task with real data
                        const index = this.tasks.findIndex(t => t.id === optimisticTask.id);
                        if (index !== -1) {
                            this.tasks[index] = savedTask;
                        }
                        
                        // 4. Cache task data for offline access
                        await safeCacheTaskData(savedTask);
                        
                        // 5. If offline, queue for background sync
                        if (!this.isOnline) {
                            await safeRequestBackgroundSync({
                                type: 'CREATE_TASK',
                                data: savedTask,
                                timestamp: Date.now()
                            });
                        }
                        
                        // Clear form and re-render
                        this.clearForm();
                        this.render();
                        
                        console.log('✅ Task created successfully');
                        
                    } catch (error) {
                        // 4. Rollback optimistic update on failure
                        this.tasks = this.tasks.filter(t => t.id !== optimisticTask.id);
                        this.render();
                        throw error;
                    }
                    
                } catch (error) {
                    console.error('❌ Failed to create task:', error);
                    this.showError('Failed to create task: ' + error.message);
                } finally {
                    this.setLoading(false);
                }
            };
            
            /**
             * Enhanced task toggle with Service Worker integration
             */
            TaskManager.prototype.toggleTaskComplete = async function(taskId) {
                try {
                    const task = this.tasks.find(t => t.id === taskId);
                    if (!task) return;
                    
                    const newStatus = task.status === 'completed' ? 'pending' : 'completed';
                    const previousStatus = task.status;
                    
                    // Optimistic update
                    task.status = newStatus;
                    task.modifiedAt = new Date().toISOString();
                    if (newStatus === 'completed') {
                        task.completedAt = new Date().toISOString();
                    } else {
                        task.completedAt = null;
                    }
                    
                    this.render();
                    
                    try {
                        // Persist to database
                        await this.database.updateTask(taskId, { status: newStatus });
                        
                        // Cache updated task
                        await safeCacheTaskData(task);
                        
                        // Queue for background sync if offline
                        if (!this.isOnline) {
                            await safeRequestBackgroundSync({
                                type: 'UPDATE_TASK',
                                data: { id: taskId, status: newStatus },
                                timestamp: Date.now()
                            });
                        }
                        
                        console.log(`✅ Task ${newStatus}:`, task.title);
                        
                    } catch (error) {
                        // Rollback on failure
                        task.status = previousStatus;
                        task.modifiedAt = new Date().toISOString();
                        if (previousStatus === 'completed') {
                            task.completedAt = new Date().toISOString();
                        } else {
                            task.completedAt = null;
                        }
                        this.render();
                        throw error;
                    }
                    
                } catch (error) {
                    console.error('❌ Failed to toggle task:', error);
                    // Reload tasks to restore correct state
                    await this.loadTasks();
                    this.showError('Failed to update task');
                }
            };
            
            /**
             * Enhanced task deletion with Service Worker integration
             */
            TaskManager.prototype.deleteTask = async function(taskId) {
                if (!confirm('Are you sure you want to delete this task?')) {
                    return;
                }
                
                try {
                    // Store task for potential rollback
                    const taskIndex = this.tasks.findIndex(t => t.id === taskId);
                    const deletedTask = this.tasks[taskIndex];
                    
                    if (taskIndex === -1) return;
                    
                    // Optimistic update
                    this.tasks.splice(taskIndex, 1);
                    this.render();
                    
                    try {
                        // Persist to database
                        await this.database.deleteTask(taskId);
                        
                        // Queue for background sync if offline
                        if (!this.isOnline) {
                            await safeRequestBackgroundSync({
                                type: 'DELETE_TASK',
                                data: { id: taskId },
                                timestamp: Date.now()
                            });
                        }
                        
                        console.log('✅ Task deleted:', deletedTask?.title);
                        
                    } catch (error) {
                        // Rollback on failure
                        this.tasks.splice(taskIndex, 0, deletedTask);
                        this.render();
                        throw error;
                    }
                    
                } catch (error) {
                    console.error('❌ Failed to delete task:', error);
                    // Reload tasks to restore correct state
                    await this.loadTasks();
                    this.showError('Failed to delete task');
                }
            };
            
            /**
             * Enhanced task edit saving with Service Worker integration
             */
            TaskManager.prototype.saveTaskEdit = async function(taskId, formData) {
                try {
                    const updates = {
                        title: formData.get('title'),
                        description: formData.get('description'),
                        priority: formData.get('priority'),
                        dueDate: formData.get('dueDate') || null
                    };
                    
                    // Store previous state for rollback
                    const task = this.tasks.find(t => t.id === taskId);
                    const previousState = { ...task };
                    
                    // Optimistic update
                    if (task) {
                        Object.assign(task, updates);
                        task.modifiedAt = new Date().toISOString();
                    }
                    
                    this.render();
                    
                    try {
                        // Persist to database
                        await this.database.updateTask(taskId, updates);
                        
                        // Cache updated task
                        await safeCacheTaskData(task);
                        
                        // Queue for background sync if offline
                        if (!this.isOnline) {
                            await safeRequestBackgroundSync({
                                type: 'UPDATE_TASK',
                                data: { id: taskId, ...updates },
                                timestamp: Date.now()
                            });
                        }
                        
                        console.log('✅ Task updated:', updates.title);
                        
                    } catch (error) {
                        // Rollback on failure
                        if (task) {
                            Object.assign(task, previousState);
                        }
                        this.render();
                        throw error;
                    }
                    
                } catch (error) {
                    console.error('❌ Failed to update task:', error);
                    this.showError('Failed to update task: ' + error.message);
                    await this.loadTasks();
                    this.render();
                }
            };        /**
         * Setup network detection
         */
        TaskManager.prototype.setupNetworkDetection = function() {
            this.isOnline = navigator.onLine;
            this.updateNetworkStatus();
        };
        
        /**
         * Show error message to user
         */
        TaskManager.prototype.showError = function(message) {
            // Create toast notification
            const toast = document.createElement('div');
            toast.className = 'toast error';
            toast.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: var(--color-danger);
                color: white;
                padding: var(--space-md);
                border-radius: var(--radius-md);
                box-shadow: var(--shadow-lg);
                z-index: 1000;
                max-width: 300px;
                animation: slideIn 0.3s ease-out;
            `;
            
            toast.textContent = message;
            document.body.appendChild(toast);
            
            // Auto remove after 5 seconds
            setTimeout(() => {
                if (toast.parentNode) {
                    toast.style.animation = 'slideOut 0.3s ease-in';
                    setTimeout(() => {
                        if (toast.parentNode) {
                            toast.parentNode.removeChild(toast);
                        }
                    }, 300);
                }
            }, 5000);
            
            // Add animation styles if not present
            if (!document.getElementById('toast-styles')) {
                const style = document.createElement('style');
                style.id = 'toast-styles';
                style.textContent = `
                    @keyframes slideIn {
                        from { transform: translateX(100%); opacity: 0; }
                        to { transform: translateX(0); opacity: 1; }
                    }
                    @keyframes slideOut {
                        from { transform: translateX(0); opacity: 1; }
                        to { transform: translateX(100%); opacity: 0; }
                    }
                `;
                document.head.appendChild(style);
            }
        };
        
        /**
         * Escape HTML to prevent XSS
         */
        TaskManager.prototype.escapeHtml = function(text) {
            const div = document.createElement('div');
            div.textContent = text || '';
            return div.innerHTML;
        };
        
        /**
         * Helper functions for Service Worker features
         * These functions safely handle cases where Service Worker is not available
         */
        
        /**
         * Safely cache task data if Service Worker is available
         */
        async function safeCacheTaskData(taskData) {
            try {
                if (typeof cacheTaskData === 'function') {
                    await cacheTaskData(taskData);
                    console.log('💾 Task data cached');
                } else {
                    console.log('⚠️ Cache function not available - skipping cache');
                }
            } catch (error) {
                console.warn('⚠️ Failed to cache task data:', error.message);
            }
        }
        
        /**
         * Safely request background sync if Service Worker is available
         */
        async function safeRequestBackgroundSync(operation) {
            try {
                if (typeof requestBackgroundSync === 'function') {
                    await requestBackgroundSync(operation);
                    console.log('🔄 Background sync requested');
                } else {
                    console.log('⚠️ Background sync not available - operation will sync when online');
                }
            } catch (error) {
                console.warn('⚠️ Failed to request background sync:', error.message);
            }
        }
        
        /**
         * Format date/time for display
         */
        TaskManager.prototype.formatDateTime = function(dateString) {
            try {
                const date = new Date(dateString);
                const now = new Date();
                const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
                const taskDate = new Date(date.getFullYear(), date.getMonth(), date.getDate());
                
                const time = date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                
                if (taskDate.getTime() === today.getTime()) {
                    return `Today ${time}`;
                } else if (taskDate.getTime() === today.getTime() + 86400000) {
                    return `Tomorrow ${time}`;
                } else if (taskDate.getTime() === today.getTime() - 86400000) {
                    return `Yesterday ${time}`;
                } else {
                    return date.toLocaleDateString() + ' ' + time;
                }
            } catch (error) {
                return 'Invalid date';
            }
        };
        
        /**
         * Format relative time (e.g., "2 hours ago")
         */
        TaskManager.prototype.formatRelativeTime = function(dateString) {
            try {
                const date = new Date(dateString);
                const now = new Date();
                const diffMs = now - date;
                const diffMins = Math.floor(diffMs / 60000);
                const diffHours = Math.floor(diffMins / 60);
                const diffDays = Math.floor(diffHours / 24);
                
                if (diffMins < 1) return 'Just now';
                if (diffMins < 60) return `${diffMins} min ago`;
                if (diffHours < 24) return `${diffHours}h ago`;
                if (diffDays < 7) return `${diffDays}d ago`;
                
                return date.toLocaleDateString();
            } catch (error) {
                return 'Unknown';
            }
        };
        
        /* ============================================
           🚀 APPLICATION INITIALIZATION
           ============================================ */
        
        /**
         * 🔍 MAJOR FUNCTION POINT #7: APPLICATION BOOTSTRAP
         * 
         * This is where everything comes together:
         * - 🏗️ **Initialize the TaskManager** with all components
         * - 📱 **Setup PWA features** for app-like experience
         * - 🎯 **Register Service Worker** for offline functionality
         * - 🔧 **Error handling** for graceful degradation
         * 
         * The bootstrap process ensures the app works reliably across
         * different browsers and network conditions.
         */
        
        // Global task manager instance
        let taskManager;
        
        /**
         * Initialize the application when DOM is ready
         */
        document.addEventListener('DOMContentLoaded', async function() {
            await initializeApp();
        });
        
        // Initialize Service Worker and Task Manager
        async function initializeApp() {
            try {
                console.log('🚀 Initializing Offline Task Manager...');
                
                // Try to register and initialize Service Worker
                if ('serviceWorker' in navigator) {
                    try {
                        await initializeServiceWorker();
                        console.log('✅ Service Worker initialized');
                    } catch (swError) {
                        console.warn('⚠️ Service Worker initialization failed:', swError.message);
                        console.log('📱 App will continue without Service Worker features');
                        
                        // Show helpful banner if it's due to file:// protocol
                        if (location.protocol === 'file:') {
                            showServiceWorkerBanner();
                        }
                    }
                } else {
                    console.warn('⚠️ Service Worker not supported in this browser');
                }
                
                // Initialize task manager (this should always work)
                taskManager = new TaskManager();
                await taskManager.init();
                
                // Setup PWA features (only if possible)
                try {
                    setupPWA();
                } catch (pwaError) {
                    console.warn('⚠️ PWA features unavailable:', pwaError.message);
                }
                
                // Setup global access for debugging
                const urlParams = new URLSearchParams(window.location.search);
                if (urlParams.has('debug')) {
                    window.taskManager = taskManager;
                    window.safeCacheTaskData = safeCacheTaskData;
                    window.safeRequestBackgroundSync = safeRequestBackgroundSync;
                    // Also expose direct functions if they exist
                    if (typeof cacheTaskData !== 'undefined') window.cacheTaskData = cacheTaskData;
                    if (typeof requestBackgroundSync !== 'undefined') window.requestBackgroundSync = requestBackgroundSync;
                    console.log('🔧 Debug mode enabled - global access available');
                }
                
                console.log('✅ App initialization complete');
                
            } catch (error) {
                console.error('❌ Failed to initialize app:', error);
                
                // Show user-friendly error
                document.body.innerHTML = `
                    <div style="
                        display: flex; 
                        align-items: center; 
                        justify-content: center; 
                        min-height: 100vh; 
                        padding: 2rem;
                        text-align: center;
                        background: var(--color-background);
                        color: var(--color-text);
                    ">
                        <div>
                            <h1 style="margin-bottom: 1rem; color: var(--color-danger);">⚠️ Application Error</h1>
                            <p style="margin-bottom: 2rem; max-width: 400px;">
                                Failed to initialize the task manager. This might be due to your browser 
                                not supporting IndexedDB or other required features.
                            </p>
                            <p><strong>Error:</strong> ${error.message}</p>
                            <button onclick="location.reload()" style="
                                padding: 0.75rem 1.5rem;
                                background: var(--color-primary);
                                color: white;
                                border: none;
                                border-radius: 0.5rem;
                                cursor: pointer;
                            ">
                                Try Again
                            </button>
                        </div>
                    </div>
                `;
            }
        }
        
        /**
         * Show informational banner about Service Worker limitations
         */
        function showServiceWorkerBanner() {
            // Don't show if banner already exists
            if (document.getElementById('sw-info-banner')) return;
            
            const banner = document.createElement('div');
            banner.id = 'sw-info-banner';
            banner.innerHTML = `
                <div style="
                    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                    color: white;
                    padding: 1rem;
                    text-align: center;
                    position: fixed;
                    top: 0;
                    left: 0;
                    right: 0;
                    z-index: 1000;
                    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                    transform: translateY(-100%);
                    transition: transform 0.3s ease-in-out;
                ">
                    <div style="max-width: 800px; margin: 0 auto; font-size: 0.9rem;">
                        <strong>ℹ️ Limited Offline Features</strong>
                        <p style="margin: 0.5rem 0; opacity: 0.9;">
                            For full offline capabilities including background sync, serve this file via HTTP:
                            <code style="background: rgba(255,255,255,0.2); padding: 0.2rem 0.4rem; border-radius: 3px; margin: 0 0.5rem;">python -m http.server 8080</code>
                        </p>
                        <div style="margin-top: 0.5rem;">
                            <button onclick="copyServerCommand()" style="
                                background: rgba(255,255,255,0.2);
                                border: 1px solid rgba(255,255,255,0.3);
                                color: white;
                                padding: 0.3rem 0.8rem;
                                border-radius: 4px;
                                margin-right: 0.5rem;
                                cursor: pointer;
                                font-size: 0.8rem;
                            ">Copy Command</button>
                            <button onclick="dismissServiceWorkerBanner()" style="
                                background: transparent;
                                border: 1px solid rgba(255,255,255,0.3);
                                color: white;
                                padding: 0.3rem 0.8rem;
                                border-radius: 4px;
                                cursor: pointer;
                                font-size: 0.8rem;
                            ">Dismiss</button>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.appendChild(banner);
            
            // Animate in
            setTimeout(() => {
                banner.firstElementChild.style.transform = 'translateY(0)';
            }, 100);
            
            // Auto-dismiss after 10 seconds
            setTimeout(() => {
                dismissServiceWorkerBanner();
            }, 10000);
        }
        
        function copyServerCommand() {
            const command = 'python -m http.server 8080';
            navigator.clipboard.writeText(command).then(() => {
                console.log('📋 Server command copied to clipboard');
                // Show brief feedback
                const button = event.target;
                const originalText = button.textContent;
                button.textContent = 'Copied!';
                setTimeout(() => {
                    button.textContent = originalText;
                }, 1000);
            }).catch(() => {
                console.log('💡 Copy this command: ' + command);
            });
        }
        
        function dismissServiceWorkerBanner() {
            const banner = document.getElementById('sw-info-banner');
            if (banner) {
                banner.firstElementChild.style.transform = 'translateY(-100%)';
                setTimeout(() => banner.remove(), 300);
            }
        }
        
        /**
         * Initialize and register Service Worker
         */
        async function initializeServiceWorker() {
            try {
                // Check if we're in a supported environment
                if (!('serviceWorker' in navigator)) {
                    throw new Error('Service Worker not supported');
                }
                
                // Check current protocol and environment
                const protocol = location.protocol;
                const hostname = location.hostname;
                
                console.log(`🔍 Current environment: ${protocol}//${hostname || 'file'}`);
                
                // Service Workers have limitations with file:// protocol
                if (protocol === 'file:') {
                    console.warn('⚠️ Service Worker limitations with file:// protocol');
                    console.log('💡 For full Service Worker support, serve the file via HTTP server:');
                    console.log('   - python -m http.server 8080');
                    console.log('   - then open http://localhost:8080/offline-task-manager.html');
                    throw new Error('Service Worker not supported with file:// protocol');
                }
                
                // Check if we're in a secure context
                const isSecureContext = protocol === 'https:' || 
                                      hostname === 'localhost' || 
                                      hostname === '127.0.0.1';
                
                if (!isSecureContext) {
                    console.warn('⚠️ Service Worker requires HTTPS or localhost');
                    throw new Error('Service Worker requires secure context');
                }
                
                // Register Service Worker using the dedicated sw.js file
                console.log('🔧 Registering Service Worker: sw.js');
                
                const registration = await navigator.serviceWorker.register('sw.js', {
                    scope: './'
                });
                
                console.log('✅ Service Worker registered:', registration);
                
                // Setup message handling
                setupServiceWorkerMessaging();
                
                // Setup background sync
                setupBackgroundSync(registration);
                
                // Handle registration events
                registration.addEventListener('updatefound', () => {
                    console.log('🔄 Service Worker update found');
                    const newWorker = registration.installing;
                    
                    newWorker.addEventListener('statechange', () => {
                        if (newWorker.state === 'activated') {
                            console.log('✅ Service Worker updated and activated');
                            // Optional: Show user notification about update
                        }
                    });
                });
                
                // Wait for Service Worker to be ready
                await navigator.serviceWorker.ready;
                console.log('✅ Service Worker ready');
                
                return registration;
                
                // Create Service Worker file dynamically using a more reliable method
                // We'll use a combination of URL.createObjectURL with proper cleanup
                try {
                    // First, try to create and register a temporary SW file
                    const response = await createServiceWorkerFile(serviceWorkerCode);
                    
                    if (response) {
                        const registration = await navigator.serviceWorker.register(response.url, {
                            scope: './'
                        });
                        console.log('✅ Service Worker registered:', registration);
                        return registration;
                    }
                } catch (error) {
                    console.log('� Fallback: Trying alternative registration method');
                }
                
                // Fallback: Try direct registration with better error handling
                await registerServiceWorkerFallback(serviceWorkerCode);
                
                // Setup message handling
                setupServiceWorkerMessaging();
                
                // Setup background sync
                setupBackgroundSync();
                
                // Handle registration events
                registration.addEventListener('updatefound', () => {
                    console.log('🔄 Service Worker update found');
                    const newWorker = registration.installing;
                    
                    newWorker.addEventListener('statechange', () => {
                        if (newWorker.state === 'activated') {
                            console.log('✅ Service Worker updated and activated');
                            // Optional: Show user notification about update
                        }
                    });
                });
                
                // Wait for Service Worker to be ready
                await navigator.serviceWorker.ready;
                console.log('✅ Service Worker ready');
                
                return registration;
                
            } catch (error) {
                console.error('❌ Service Worker registration failed:', error);
                throw error;
            }
        }
        
        /**
         * Setup Service Worker messaging system
         */
        function setupServiceWorkerMessaging() {
            navigator.serviceWorker.addEventListener('message', handleServiceWorkerMessage);
            
            // Handle messages from Service Worker
            navigator.serviceWorker.addEventListener('message', (event) => {
                const { type, data } = event.data;
                
                switch (type) {
                    case 'SYNC_COMPLETE':
                        console.log('🔄 Background sync completed:', data);
                        // Optional: Refresh data or show notification
                        break;
                        
                    case 'CACHE_UPDATED':
                        console.log('💾 Cache updated:', data);
                        break;
                        
                    case 'NOTIFICATION_CLICKED':
                        console.log('🔔 Notification clicked:', data);
                        // Handle notification actions
                        break;
                        
                    default:
                        console.log('📨 Service Worker message:', event.data);
                }
            });
        }
        
        /**
         * Handle app installation prompt
         */
        let deferredPrompt;
        
        window.addEventListener('beforeinstallprompt', (e) => {
            // Prevent the mini-infobar from appearing on mobile
            e.preventDefault();
            // Stash the event so it can be triggered later
            deferredPrompt = e;
            
            // Show install button or banner
            showInstallPrompt();
        });
        
        function showInstallPrompt() {
            // Create install prompt UI
            const installBanner = document.createElement('div');
            installBanner.id = 'install-banner';
            installBanner.innerHTML = `
                <div style="
                    position: fixed;
                    bottom: 0;
                    left: 0;
                    right: 0;
                    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                    color: white;
                    padding: 1rem;
                    text-align: center;
                    box-shadow: 0 -2px 10px rgba(0,0,0,0.1);
                    z-index: 1000;
                    transform: translateY(100%);
                    transition: transform 0.3s ease-in-out;
                " onclick="installApp()">
                    <div style="max-width: 600px; margin: 0 auto;">
                        <strong>📱 Install Task Manager</strong>
                        <p style="margin: 0.5rem 0; opacity: 0.9;">Add to home screen for quick access</p>
                        <button onclick="installApp(); event.stopPropagation();" style="
                            background: rgba(255,255,255,0.2);
                            border: 1px solid rgba(255,255,255,0.3);
                            color: white;
                            padding: 0.5rem 1rem;
                            border-radius: 4px;
                            margin-right: 1rem;
                            cursor: pointer;
                        ">Install</button>
                        <button onclick="dismissInstallPrompt(); event.stopPropagation();" style="
                            background: transparent;
                            border: 1px solid rgba(255,255,255,0.3);
                            color: white;
                            padding: 0.5rem 1rem;
                            border-radius: 4px;
                            cursor: pointer;
                        ">Maybe Later</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(installBanner);
            
            // Animate in
            setTimeout(() => {
                installBanner.firstElementChild.style.transform = 'translateY(0)';
            }, 100);
        }
        
        async function installApp() {
            if (deferredPrompt) {
                // Show the install prompt
                deferredPrompt.prompt();
                
                // Wait for the user to respond
                const { outcome } = await deferredPrompt.userChoice;
                console.log(`👤 User response to install prompt: ${outcome}`);
                
                // Clear the deferred prompt
                deferredPrompt = null;
                
                // Remove install banner
                dismissInstallPrompt();
            }
        }
        
        function dismissInstallPrompt() {
            const banner = document.getElementById('install-banner');
            if (banner) {
                banner.firstElementChild.style.transform = 'translateY(100%)';
                setTimeout(() => banner.remove(), 300);
            }
        }
        
        // Handle app installed event
        window.addEventListener('appinstalled', (evt) => {
            console.log('📱 App was installed');
            // Optional: Track installation or show success message
        });
        
        /**
         * 🔍 MAJOR FUNCTION POINT #8: SERVICE WORKER IMPLEMENTATION
         * 
         * Service Workers provide the foundation for offline-first functionality:
         * - 🔄 **Background sync** for reliable data synchronization
         * - 📦 **Cache management** for offline app shell and resources
         * - 🔔 **Push notifications** for task reminders and updates
         * - 🛡️ **Network interception** for graceful offline fallbacks
         * - ⚡ **Background processing** without blocking UI
         * 
         * Key Benefits:
         * - True offline functionality - app works without internet
         * - Reliable sync when connection is restored
         * - Native app-like experience with background operations
         * - Improved performance through intelligent caching
         */
        
        /**
         * Setup Progressive Web App features with Service Worker
         */
        async function setupPWA() {
            // Register Service Worker first
            await initializeServiceWorker();
            
            // Create and inject manifest
            const manifestData = {
                name: 'Offline Task Manager',
                short_name: 'TaskManager',
                description: 'Offline-first task management system',
                start_url: '/',
                display: 'standalone',
                background_color: '#ffffff',
                theme_color: '#2563eb',
                orientation: 'portrait-primary',
                categories: ['productivity', 'utilities'],
                icons: [
                    {
                        src: 'data:image/svg+xml;base64,' + btoa(`
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 192 192" fill="#2563eb">
                                <rect x="20" y="20" width="152" height="152" rx="20" fill="#2563eb"/>
                                <path d="M60 96l20 20 40-40" stroke="white" stroke-width="8" fill="none" stroke-linecap="round" stroke-linejoin="round"/>
                                <rect x="40" y="60" width="12" height="12" rx="2" fill="white"/>
                                <rect x="40" y="80" width="12" height="12" rx="2" fill="white"/>
                                <rect x="40" y="100" width="12" height="12" rx="2" fill="white"/>
                                <rect x="40" y="120" width="12" height="12" rx="2" fill="white"/>
                            </svg>
                        `),
                        sizes: '192x192',
                        type: 'image/svg+xml'
                    },
                    {
                        src: 'data:image/svg+xml;base64,' + btoa(`
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" fill="#2563eb">
                                <rect x="50" y="50" width="412" height="412" rx="50" fill="#2563eb"/>
                                <path d="M160 256l60 60 120-120" stroke="white" stroke-width="20" fill="none" stroke-linecap="round" stroke-linejoin="round"/>
                                <rect x="100" y="160" width="32" height="32" rx="4" fill="white"/>
                                <rect x="100" y="220" width="32" height="32" rx="4" fill="white"/>
                                <rect x="100" y="280" width="32" height="32" rx="4" fill="white"/>
                                <rect x="100" y="340" width="32" height="32" rx="4" fill="white"/>
                            </svg>
                        `),
                        sizes: '512x512',
                        type: 'image/svg+xml'
                    }
                ]
            };
            
            // Inject manifest
            const manifestBlob = new Blob([JSON.stringify(manifestData)], { type: 'application/json' });
            const manifestURL = URL.createObjectURL(manifestBlob);
            const manifestLink = document.createElement('link');
            manifestLink.rel = 'manifest';
            manifestLink.href = manifestURL;
            document.head.appendChild(manifestLink);
            
            console.log('📱 PWA manifest injected');
        }
        
        /**
         * Generate Service Worker code as string (embedded approach)
         */
        function generateServiceWorkerCode() {
            return `
                'use strict';
                
                /* ============================================
                   🔧 SERVICE WORKER CONFIGURATION
                   ============================================ */
                
                const CACHE_NAME = 'task-manager-v1.0';
                const STATIC_CACHE = 'task-manager-static';
                const SYNC_TAG = 'task-sync';
                
                // Cache strategies
                const CACHE_STRATEGIES = {
                    CACHE_FIRST: 'cache-first',
                    NETWORK_FIRST: 'network-first',
                    CACHE_ONLY: 'cache-only',
                    NETWORK_ONLY: 'network-only'
                };
                
                /* ============================================
                   📦 SERVICE WORKER LIFECYCLE
                   ============================================ */
                
                // Installation phase
                self.addEventListener('install', event => {
                    console.log('🔧 Service Worker installing...');
                    
                    event.waitUntil(
                        caches.open(STATIC_CACHE).then(cache => {
                            // Cache the main application (self)
                            return cache.add('/');
                        }).then(() => {
                            console.log('✅ Static assets cached');
                            // Force activation
                            return self.skipWaiting();
                        })
                    );
                });
                
                // Activation phase
                self.addEventListener('activate', event => {
                    console.log('🚀 Service Worker activating...');
                    
                    event.waitUntil(
                        Promise.all([
                            // Clean up old caches
                            caches.keys().then(cacheNames => {
                                return Promise.all(
                                    cacheNames.map(cacheName => {
                                        if (cacheName !== CACHE_NAME && cacheName !== STATIC_CACHE) {
                                            console.log('🗑️ Deleting old cache:', cacheName);
                                            return caches.delete(cacheName);
                                        }
                                    })
                                );
                            }),
                            // Take control of all clients
                            self.clients.claim()
                        ]).then(() => {
                            console.log('✅ Service Worker activated and ready');
                        })
                    );
                });
                
                /* ============================================
                   🌐 NETWORK INTERCEPTION & CACHING
                   ============================================ */
                
                // Fetch event handling
                self.addEventListener('fetch', event => {
                    const request = event.request;
                    const url = new URL(request.url);
                    
                    // Only handle same-origin requests
                    if (url.origin !== location.origin) {
                        return;
                    }
                    
                    // Determine cache strategy based on request
                    const strategy = getCacheStrategy(request);
                    
                    event.respondWith(handleRequest(request, strategy));
                });
                
                /**
                 * Determine appropriate cache strategy
                 */
                function getCacheStrategy(request) {
                    const url = new URL(request.url);
                    
                    // HTML files: Network first (for updates)
                    if (request.destination === 'document') {
                        return CACHE_STRATEGIES.NETWORK_FIRST;
                    }
                    
                    // API calls: Network first
                    if (url.pathname.includes('/api/')) {
                        return CACHE_STRATEGIES.NETWORK_FIRST;
                    }
                    
                    // Static assets: Cache first
                    return CACHE_STRATEGIES.CACHE_FIRST;
                }
                
                /**
                 * Handle request with specified strategy
                 */
                async function handleRequest(request, strategy) {
                    const cache = await caches.open(CACHE_NAME);
                    
                    switch (strategy) {
                        case CACHE_STRATEGIES.CACHE_FIRST:
                            return handleCacheFirst(request, cache);
                            
                        case CACHE_STRATEGIES.NETWORK_FIRST:
                            return handleNetworkFirst(request, cache);
                            
                        case CACHE_STRATEGIES.CACHE_ONLY:
                            return cache.match(request);
                            
                        case CACHE_STRATEGIES.NETWORK_ONLY:
                            return fetch(request);
                            
                        default:
                            return handleCacheFirst(request, cache);
                    }
                }
                
                /**
                 * Cache-first strategy
                 */
                async function handleCacheFirst(request, cache) {
                    const cachedResponse = await cache.match(request);
                    
                    if (cachedResponse) {
                        // Return cached version immediately
                        return cachedResponse;
                    }
                    
                    try {
                        // Fetch and cache for future use
                        const networkResponse = await fetch(request);
                        cache.put(request, networkResponse.clone());
                        return networkResponse;
                    } catch (error) {
                        console.log('📴 Network unavailable for:', request.url);
                        // Return offline fallback if available
                        return getOfflineFallback(request);
                    }
                }
                
                /**
                 * Network-first strategy
                 */
                async function handleNetworkFirst(request, cache) {
                    try {
                        // Try network first
                        const networkResponse = await fetch(request);
                        
                        // Cache successful responses
                        if (networkResponse.ok) {
                            cache.put(request, networkResponse.clone());
                        }
                        
                        return networkResponse;
                    } catch (error) {
                        console.log('📴 Network failed, trying cache for:', request.url);
                        
                        // Fallback to cache
                        const cachedResponse = await cache.match(request);
                        if (cachedResponse) {
                            return cachedResponse;
                        }
                        
                        // Return offline fallback
                        return getOfflineFallback(request);
                    }
                }
                
                /**
                 * Get offline fallback response
                 */
                function getOfflineFallback(request) {
                    if (request.destination === 'document') {
                        // Return a simple offline page for HTML requests
                        return new Response(
                            '<html><body><h1>📴 Offline</h1><p>You are currently offline. Please check your connection and try again.</p></body></html>',
                            { headers: { 'Content-Type': 'text/html' } }
                        );
                    }
                    
                    // For other requests, return a basic error response
                    return new Response('Offline', { status: 503, statusText: 'Service Unavailable' });
                }
                
                /* ============================================
                   🔄 BACKGROUND SYNC
                   ============================================ */
                
                // Background sync event
                self.addEventListener('sync', event => {
                    console.log('🔄 Background sync triggered:', event.tag);
                    
                    if (event.tag === SYNC_TAG) {
                        event.waitUntil(syncTasks());
                    }
                });
                
                /**
                 * Sync pending tasks when connection is restored
                 */
                async function syncTasks() {
                    try {
                        console.log('🔄 Starting task synchronization...');
                        
                        // Get pending sync operations from IndexedDB
                        const pendingOperations = await getPendingSyncOperations();
                        
                        if (pendingOperations.length === 0) {
                            console.log('✅ No pending operations to sync');
                            return;
                        }
                        
                        console.log(\`🔄 Syncing \${pendingOperations.length} pending operations...\`);
                        
                        // Process each pending operation
                        for (const operation of pendingOperations) {
                            try {
                                await processSyncOperation(operation);
                                await removeSyncOperation(operation.id);
                                console.log('✅ Synced operation:', operation.type);
                            } catch (error) {
                                console.error('❌ Failed to sync operation:', operation, error);
                                // Keep operation for next sync attempt
                            }
                        }
                        
                        // Notify main thread of sync completion
                        notifyClientsOfSync();
                        
                        console.log('✅ Background sync completed');
                        
                    } catch (error) {
                        console.error('❌ Background sync failed:', error);
                        throw error; // Retry sync later
                    }
                }
                
                /**
                 * Get pending sync operations from IndexedDB
                 */
                async function getPendingSyncOperations() {
                    // This would interface with IndexedDB to get pending operations
                    // For now, return empty array (to be implemented with full sync system)
                    return [];
                }
                
                /**
                 * Process a single sync operation
                 */
                async function processSyncOperation(operation) {
                    // This would handle the actual sync logic
                    // (to be implemented with full sync system)
                    console.log('Processing sync operation:', operation);
                }
                
                /**
                 * Remove completed sync operation
                 */
                async function removeSyncOperation(operationId) {
                    // Remove from IndexedDB pending operations
                    console.log('Removing sync operation:', operationId);
                }
                
                /**
                 * Notify all clients of sync completion
                 */
                function notifyClientsOfSync() {
                    self.clients.matchAll().then(clients => {
                        clients.forEach(client => {
                            client.postMessage({
                                type: 'SYNC_COMPLETED',
                                timestamp: Date.now()
                            });
                        });
                    });
                }
                
                /* ============================================
                   🔔 PUSH NOTIFICATIONS
                   ============================================ */
                
                // Push notification event
                self.addEventListener('push', event => {
                    console.log('🔔 Push notification received');
                    
                    const options = {
                        body: 'You have pending tasks to complete',
                        icon: '/icon-192.png',
                        badge: '/badge-72.png',
                        tag: 'task-reminder',
                        requireInteraction: false,
                        actions: [
                            {
                                action: 'open',
                                title: 'Open Tasks'
                            },
                            {
                                action: 'dismiss',
                                title: 'Dismiss'
                            }
                        ]
                    };
                    
                    if (event.data) {
                        const data = event.data.json();
                        options.body = data.message || options.body;
                        options.data = data;
                    }
                    
                    event.waitUntil(
                        self.registration.showNotification('Task Manager', options)
                    );
                });
                
                // Notification click event
                self.addEventListener('notificationclick', event => {
                    console.log('🔔 Notification clicked:', event.action);
                    
                    event.notification.close();
                    
                    if (event.action === 'open' || !event.action) {
                        // Open the app
                        event.waitUntil(
                            self.clients.matchAll().then(clients => {
                                // Focus existing window if available
                                for (const client of clients) {
                                    if (client.url.includes('/') && 'focus' in client) {
                                        return client.focus();
                                    }
                                }
                                
                                // Open new window
                                if (self.clients.openWindow) {
                                    return self.clients.openWindow('/');
                                }
                            })
                        );
                    }
                    
                    // Handle other actions (dismiss, etc.)
                    // Can be extended for specific task actions
                });
                
                /* ============================================
                   📱 MESSAGE HANDLING
                   ============================================ */
                
                // Handle messages from main thread
                self.addEventListener('message', event => {
                    console.log('📨 Service Worker received message:', event.data);
                    
                    const { type, data } = event.data;
                    
                    switch (type) {
                        case 'SKIP_WAITING':
                            self.skipWaiting();
                            break;
                            
                        case 'CACHE_TASK_DATA':
                            // Cache task data for offline access
                            cacheTaskData(data);
                            break;
                            
                        case 'QUEUE_SYNC':
                            // Queue operation for background sync
                            queueSyncOperation(data);
                            break;
                            
                        case 'REQUEST_SYNC':
                            // Request immediate sync if possible
                            triggerSync();
                            break;
                            
                        default:
                            console.log('Unknown message type:', type);
                    }
                });
                
                /**
                 * Cache task data for offline access
                 */
                async function cacheTaskData(taskData) {
                    try {
                        const cache = await caches.open(CACHE_NAME);
                        const response = new Response(JSON.stringify(taskData));
                        await cache.put('/task-data', response);
                        console.log('✅ Task data cached for offline access');
                    } catch (error) {
                        console.error('❌ Failed to cache task data:', error);
                    }
                }
                
                /**
                 * Queue operation for background sync
                 */
                function queueSyncOperation(operation) {
                    // This would add the operation to IndexedDB for later sync
                    console.log('📋 Queued sync operation:', operation);
                }
                
                /**
                 * Trigger immediate sync if online
                 */
                function triggerSync() {
                    if (navigator.onLine) {
                        syncTasks().catch(error => {
                            console.error('❌ Manual sync failed:', error);
                        });
                    } else {
                        console.log('📴 Cannot sync while offline');
                    }
                }
                
                console.log('✅ Service Worker script loaded successfully');
            `;
        }
        
        /**
         * Setup background sync for offline operations
         */
        async function setupBackgroundSync(registration) {
            if (!('sync' in window.ServiceWorkerRegistration.prototype)) {
                console.warn('⚠️ Background Sync not supported');
                return false;
            }
            
            try {
                // Register for background sync
                await registration.sync.register('task-sync');
                console.log('✅ Background sync registered');
                return true;
            } catch (error) {
                console.error('❌ Background sync registration failed:', error);
                return false;
            }
        }
        
        /**
         * Handle messages from Service Worker
         */
        function handleServiceWorkerMessage(event) {
            const { type, data } = event.data;
            
            switch (type) {
                case 'SYNC_COMPLETED':
                    console.log('🔄 Background sync completed');
                    if (window.taskManager) {
                        // Reload tasks to get any synced changes
                        window.taskManager.loadTasks().then(() => {
                            window.taskManager.render();
                        });
                    }
                    break;
                    
                case 'CACHE_UPDATED':
                    console.log('📦 Cache updated');
                    break;
                    
                case 'SYNC_ERROR':
                    console.error('❌ Background sync error:', data);
                    break;
                    
                default:
                    console.log('📨 Unknown message from Service Worker:', type);
            }
        }
        
        /**
         * Show update available notification
         */
        function showUpdateAvailableNotification() {
            const updateBanner = document.createElement('div');
            updateBanner.className = 'update-banner';
            updateBanner.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                background: var(--color-primary);
                color: white;
                padding: var(--space-md);
                text-align: center;
                z-index: 1000;
                box-shadow: var(--shadow-md);
            `;
            
            updateBanner.innerHTML = `
                <p style="margin: 0; margin-bottom: var(--space-sm);">
                    🔄 A new version of the app is available
                </p>
                <button onclick="location.reload()" style="
                    background: white;
                    color: var(--color-primary);
                    border: none;
                    padding: var(--space-xs) var(--space-md);
                    border-radius: var(--radius-md);
                    cursor: pointer;
                    font-weight: 500;
                    margin-right: var(--space-sm);
                ">
                    Update Now
                </button>
                <button onclick="this.parentElement.remove()" style="
                    background: transparent;
                    color: white;
                    border: 1px solid white;
                    padding: var(--space-xs) var(--space-md);
                    border-radius: var(--radius-md);
                    cursor: pointer;
                    font-weight: 500;
                ">
                    Later
                </button>
            `;
            
            document.body.appendChild(updateBanner);
        }
        
        /**
         * Request background sync for pending operations
         */
        async function requestBackgroundSync(operation) {
            if (!('serviceWorker' in navigator) || !navigator.serviceWorker.ready) {
                console.warn('⚠️ Service Worker not available for background sync');
                return false;
            }
            
            try {
                const registration = await navigator.serviceWorker.ready;
                
                // Send operation to Service Worker for queuing
                if (registration.active) {
                    registration.active.postMessage({
                        type: 'QUEUE_SYNC',
                        data: operation
                    });
                }
                
                // Register for background sync
                if ('sync' in registration) {
                    await registration.sync.register('task-sync');
                    console.log('🔄 Background sync requested for:', operation.type);
                    return true;
                }
                
                return false;
            } catch (error) {
                console.error('❌ Failed to request background sync:', error);
                return false;
            }
        }
        
        /**
         * Cache task data for offline access
         */
        async function cacheTaskData(taskData) {
            if (!('serviceWorker' in navigator) || !navigator.serviceWorker.ready) {
                return false;
            }
            
            try {
                const registration = await navigator.serviceWorker.ready;
                
                if (registration.active) {
                    registration.active.postMessage({
                        type: 'CACHE_TASK_DATA',
                        data: taskData
                    });
                }
                
                return true;
            } catch (error) {
                console.error('❌ Failed to cache task data:', error);
                return false;
            }
        }
        
        /**
         * Handle visibility change for background operations
         */
        document.addEventListener('visibilitychange', function() {
            if (document.visibilityState === 'visible') {
                console.log('👁️ App became visible - refreshing data');
                if (taskManager) {
                    taskManager.loadTasks().then(() => taskManager.render());
                }
            } else {
                console.log('🙈 App became hidden - pausing operations');
            }
        });
        
        // Expose taskManager globally for debugging
        window.taskManager = taskManager;
        
        console.log('🎯 Task Manager script loaded successfully');
    </script>
</body>
</html>